# インデックス
## インデックスによる性能向上
#### インデックス候補となるカラムの特徴
- (必須) WHERE / JOINの対象
- カーディナリティが高い (値の種類が多い)
- 選択率が低い (少ない行に絞り込めること = 5~10%未満に絞り込めること)
- レコード件数が多い
- 外部キーを表現している

#### 複合インデックス
- 先に指定したカラムからインデックスが使用されるため、カーディナリティが高い -> 低い順で指定する

#### インデックスが利用できないケース
- 中間一致・後方一致のLIKE述語
- 索引列で演算を行っている
  - × `where col * 1.1 > 100`
  - ○ `where col > 100 / 1.1`
- 索引列で`is null`述語を使っている
- 索引列で関数を使っている
- 索引列で否定系を用いている

## インデックスの種類
#### B-treeインデックス
- データを木構造で保持する
- 実際にはB+treeインデックスが多く利用される
  - 検索をより効率的・安定的に行う
  - ツリーのリーフノードにだけキー値を保持する
- ルートとリーフの距離は一定に保たれる
- 木の深さが3~4レベル
- データはソートして保持される

#### ビットマップインデックス
- データをビットフラグに変換して保持する
- カーディナリティの低い列に対して効果を発揮する
- 更新時のオーバーヘッドが大きい

#### ハッシュインデックス
- キーをハッシュ分散することにより等値検索を高速化する
- 選択率の高い等置検索以外では効果が低い

## 参照
- SQL実践入門: 高速でわかりやすいクエリの書き方 10
