# パフォーマンスチューニング
- スループットを最大化 -> ホスティングコストの抑制
- レイテンシの最小化 -> ユーザー体験の向上

#### インフラの観点
- OSのキャッシュを最大限活用する
- 分散の考慮 (書き込みが発生するマシンは分散が難しい)
- アルゴリズム、データ構造

#### プログラムの観点
- メモリを最大限活用する (ディスクのシーク回数を最小化する)
- データ量の増加に強いアルゴリズム、データ構造を扱う
- データ圧縮、検索技術を活用する

#### CPU負荷を下げる
- CPUの数を増やす

#### IO負荷を下げる
- Linuxはメモリが空いている場合可能な限りキャッシュを行う
  - メモリを増設することでディスクへの読み込みを減らす (= IO負荷を下げる) ことができる
  - マシンの物理メモリが扱うデータ規模よりも大きい場合: 全てのデータをキャッシュで扱うことができる
  - マシンの物理メモリが扱うデータ規模よりも小さい場合: 複数マシンへスケールアウトする (局所性を考慮)

#### 局所性を生かしたデータの分散
- データを分割し、アクセスパターンの近いデータ同士を同じマシンに置く
  - テーブルによる分割
  - リクエストパターンによる分割

## Tips
- 同じプロセスで完結させる (外部コマンド実行ではなくライブラリの使用が望ましい)
- 本番環境では冗長なログを出力しない

### GVLの影響を踏まえたRuby製アプリケーションサーバでのチューニング
#### レイテンシの最適化
- (基本) 一つのCPUコアに対して一つのプロセスを実行する
- IO待機時間が50%以下の場合のスレッド数は2〜3個が適切 (増やしすぎるとレイテンシが大幅に悪化)

#### その他の観点
- JITコンパイラを有効にする
- メモリアロケータにjemallocを使う

## 参照
- ［Web開発者のための］大規模サービス技術入門 ― データ構造、メモリ、OS、DB、サーバ/インフラ
- 達人が教えるWebパフォーマンスチューニング 〜ISUCONから学ぶ高速化の実践
- [デプロイ用パフォーマンスチューニング](https://railsguides.jp/tuning_performance_for_deployment.html)
