# Elixir
- [elixir](https://elixir-lang.jp/)
- [getting-started](https://elixir-lang.jp/getting-started/introduction.html)
- [リファレンス](https://hexdocs.pm/elixir)
- プログラミングElixir 第1章 / 第14章 / 第20章
- Elixir実践ガイド 1.2 / 5.2.9 / 11.1.1

## Erlang/OTP
- Erlang言語処理系
  - ERTS - ランタイムシステム
  - BEAM - ErlangVM
  - OTP - Erlang標準ライブラリ
- ElixirはOTPによって実装されている
- ElixirのコンパイラはElixirのソースコードを
  BEAM上で実行可能なバイトコードへ変換する

### アトムテーブル
- BEAMは内部にアトムテーブルという記憶領域を持つ
- アトムテーブルはデフォルトで約100万個のアトムを格納することができる

## コンパイル
- `$ elixirc` - ソースコードをバイトコードへコンパイルする
  - コンパイルに成功すると、`.beam`拡張子を持つバイトコードファイルが生成される
  - バイトコードファイルは`$ elixir -e '関数'`コマンドで直接実行できる

### コンパイルの工程
1. ソースコードをASTに変換
2. ASTに含まれるマクロを展開
3. ASTをバイトコードに変換

## 関数とマクロの評価タイミングの違い
- マクロはコンパイル時に評価される
- 関数は実行時に評価される

## IEx
- `$ iex`

### オプション
- `-S mix` - IExに`mix.exs`を適用する
  - Ubuntu20.4では別途`erlang-dev`のインストールが必要

### IExヘルパー
- `h 検索したいモジュールや関数` - ヘルプガイド
- `i 検索したい値` - 値についての情報を表示する
- `c "ファイル名"` - ソースファイルをコンパイルしてIExへロードする
  - あるいはコマンドラインで`$ iex ファイル名`を実行

### IExデバッグ
- ソースコード中で`require IEx; IEx.pry`を呼ぶことで
  ブレークポイントを仕込むことができる
  - `pry`モード中に`binding`を呼ぶとその時点でのローカル変数を出力できる
- IEx中に`require IEx; break! 対象の関数`を呼ぶことで
  任意のパブリックな関数にブレークポイントを仕込むことができる

### サーバーモニタリングツール
- `:observer.start()`
  - 基本的なシステム情報の表示
  - 動的な負荷のグラフ
  - ErlangETSテーブルの情報と内容
  - 実行中のプロセス
  - 実行中のアプリケーション
  - メモリ割り当て
  - 関数呼び出し、メッセージ、イベントトレース

## ソースファイル
- `.ex` - バイナリ形式にへコンパイルして実行するファイル
  - Ex. アプリケーションファイル
- `.exs` - コンパイルなしでスクリプトを実行するファイル
  - Ex. テストファイル

## ライブラリ
- Elixir標準ライブラリを使う
- Erlang標準ライブラリを使う
- [Hex](https://hex.pm/)を使う
- GitHubから探す

## アプリケーション仕様ファイル
- `xxx.app` - ランタイム環境にアプリケーションを定義する際に使用される
- アプリケーション仕様ファイルは`mix.exs`にある情報と、
  アプリケーションをコンパイルするときに集めた情報をつなげて生成される
- アプリケーションを実行する際はアプリケーション仕様ファイルに基づいてロードされる
- アプリケーション仕様ファイルは`_build/ENV/lib/xxx/ebin`以下に置かれる
