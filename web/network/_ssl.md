# SSL/TLS
- 参照: [How is data secure over https?](https://blog.joshsoftware.com/2019/08/23/how-is-data-secure-over-https/)
- 参照: よくわかるHTTP/2の教科書P18-20/124-125
- 参照: SSLをはじめよう ～「なんとなく」から「ちゃんとわかる！」へ～
- 参照: [図解で学ぶネットワークの基礎：SSL編](https://xtech.nikkei.com/it/article/COLUMN/20071002/283518/)

## TL;DR
### SSL (Secure socket layer)
- クライアント-サーバー間で間で機密情報を送信するため、インターネット接続を安全に行う技術

### TLS (Transport layer security)
- より安全なSSLの上位互換バージョン

### HTTPS (Hyper text transfer Protocol SECURE)
- SSL/TLSで保護されたデータの転送に使用されるHTTPプロトコル(HTTP + SSL/TLS)

### SSL/TLSによる通信の特性
- 機密性 -> データを第三者に見られない(暗号化)
- 完全性 -> データが改ざんされない(改ざんの検知)
- 真正性 -> 通信相手が正しい相手である(証明書)

### プロトコル
- アプリケーション(Ex. Webブラウザ)とTCPの間に位置する
- 送信側WebブラウザがSSL/TLSに渡したデータをSSL/TLSが暗号化し、TCPに渡す
  TCPはデータが暗号化されていることを示すため
  受信側サーバーの443番ポートあてにデータを送り出す
- 受信側は443番ポートあてのデータを暗号化されているものとみなし
  受信側SSLサーバーが暗号化されたデータを復号して
  Webサーバー・アプリケーションに渡す

## 暗号方式
- 共通鍵暗号方式と公開鍵暗号方式の組み合わせによって暗号化を行う
  - 共通鍵暗号方式 - 暗号化と復号に同じ鍵を使う
  - 公開鍵暗号方式 - 公開鍵と秘密鍵から成るペアの鍵を使う

```
1. クライアントがサーバーにSSL通信の要求を送る
2. サーバーは自身の公開鍵が入った証明書をクライアントに返信する
3. クライアントは入手したサーバーの公開鍵を使い
   「アプリケーション同士の暗号通信に使う共通鍵」を暗号化してサーバーに送る
4. サーバーは秘密鍵を使ってクライアントから送られてきた暗号データを復号し
   「暗号通信に使う共通鍵」を取り出す
5. 共有した共通鍵を使って，クライアントとサーバー間でデータの暗号化/復号を処理する
```

## 接続手順
### TLS1.2
1. ハンドシェイクの開始
    - (1) Client-Hello: クライアント -> サーバーへ開始メッセージを送信
      - SSL/TLSバージョン、使用する暗号スイート、データ圧縮方法などのクライアント情報
    - (2) Server-Hello: サーバー -> クライアントへ開始メッセージを送信
      - クライアントが提供するリストから選択された暗号スイート、SSL証明書(公開鍵含む)などのサーバー情報
    - (1)(2)によってクライアント - サーバー間で使用される情報についての同意が生まれる
      - SSL/TLSバージョン、暗号化/復号化に使用される暗号スイートの暗号化アルゴリズム
2. クライアントによるサーバー認証
    - クライアントがサーバーから提供されたSSL証明書を検証する
      - 証明書の有効期限、認証局、証明書のドメイン名の確認する -> サーバー認証成功/失敗
      - クライアントは、信頼できる認証局(CA)のリストを保持している
3. DH秘密鍵交換
    - サーバーが使い捨ての公開鍵・秘密鍵のペアを生成する(DH用公開鍵・秘密)
    - クライアントが使い捨ての公開鍵・秘密鍵のペアを生成する(DH用公開鍵・秘密)
    - サーバーがSSL証明書に含まれる公開鍵でサーバーのDH用公開鍵を暗号化してクライアントに渡す
    - クライアントがSSL証明書に含まれる公開鍵でサーバーのDH用公開鍵を復号
    - クライアントがサーバーのDH用公開鍵でクライアントのDH用公開鍵を暗号化してサーバーに渡す
      - プリマスターシークレット - サーバーのDH用公開鍵とクライアントのDH用公開鍵
    - プリマスターシークレットによって共通鍵を生成
4. ハンドシェイクの終了
    - クライアント -> サーバーへ秘密キーで暗号化された終了メッセージを送信
      - ハンドシェイクのクライアント部分が完了したことを示す
    - サーバー -> クライアントへ秘密キーで暗号化された終了メッセージを送信
      - ハンドシェイクのサーバー部分が完了したことを示す
5. データ交換
    - セッションの間、クライアント - サーバーは共通鍵で暗号化したデータを交換する

### TLS1.3
- TLS1.2よりもメッセージの往復回数が減っている
1. ハンドシェイクの開始
    - (1) Client-Hello
    - (2) Server-Hello
      - SSL証明書、秘密鍵の所有を証明するCertificate、CertificateVerifyメッセージ
3. ハンドシェクの終了
  - クライアント -> サーバーへFinishedメッセージ、アプリケーションデータ

## HTTP/2における仕様
- TLS1.2以上
- TLS SNIのサポート
- 圧縮機能無効化 -> HTTP/2自身が圧縮を行う
- 再ネゴシエーション禁止 -> クライアント証明書の要求はコネクションプリフェイス前に実行される必要がある
- 暗号スイート
  - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`をサポート
  - 仕様で禁止されている暗号スイートの使用禁止

### 暗号スイートの条件が合わない場合
- `INADEQUEATE_SECURITY`エラーコネクションによって切断される場合がある -> コネクションエラー
  - ALPNネゴシエーションと暗号スイートの選択が独立して行われるため、
    暗号スイートの条件が一致しない場合がある

## SSL証明書
### 種類
- クライアント証明書 - クライアントの身元を証明する
- サーバー証明書     - サーバーの身元を証明する

### 役割
- なりすまし防止
  - レスポンスが正しいサーバーから送信されたことを認証する
- データの改ざん防止
  - リクエストデータが送信中に改ざんされていないことを確認する
  - レスポンスデータが送信中に改ざんされていないことを確認する
- 情報漏洩防止
  - リクエストデータが漏洩しないように暗号化する
  - レスポンスデータが漏洩しないように暗号化する

## サーバー証明書
### クライアント - サーバー間の認証
- クライアントは予め信頼できるルート認証局の証明書を複数インストールしている
- クライアントは予め自身にインストールされている証明書と
  サーバーから送信されたルート認証局の証明書が一致するかを確認する
  (クライアントにはサーバー証明書とルート認証局の自己証明書が両方送信される)
  一致したら受信した証明書は信頼できると判断する
- クライアントはルート認証局の証明書の中に入っている公開鍵でサーバー証明書に付けられた署名を検証する
  一致したら受信した証明書は信頼できると判断する↲

### 種類
- DV証明書 - ドメインの所有確認
- OV証明書 - ドメインの所有確認、発行先の組織の存在を示す
- EV証明書 - ドメインの所有確認、発行先の組織の存在をガイドラインに従って厳格に示す

### 証明書発行手順
1. OpenSSLで秘密鍵を生成
```
$ openssl genrsa -out ./xxx.key 2048`
$ chmod 600 ./xxx.key
```

2. 秘密鍵からCSR(証明書署名リクエスト)を作成
```
$ openssl req -new -key xxx.key -out xxx.csr
```
3. 認証局にCSRを提出しSSL証明書の発行を依頼
  - FujiSSL
4. CAによる審査・証明書の発行
5. CAから発行される値でネームサーバー上にTXTレコードを作りDNS認証
6. SSL証明書・中間CA証明書が届く
    - SSL証明書(`.crt`)
    - 中間CA証明書(`.ca`)
    - SSL証明書 + 中間CA証明書
7. WebサーバーにSSL証明書・中間CA証明書を設置
    - 証明書を一ファイルにまとめる(`$ awk 1 xxx.crt yyy.ca > zzz.crt`)
8. Webサーバー上にHTTPSのバーチャルホストを作成
    - 秘密鍵・SSL証明書 + 中間CA証明書・暗号スイート・TLSプロトコルバージョンを指定

### CAA(Certification Authority Authorization)レコード
- 運営者以外の第三者がSSL証明書を勝手に発行することを防止するための仕組み
- 該当のドメインの証明書を発行できる認証局を事前に設定しておく

### SSLターミネーション
- Webサーバー手前のロードバランサーにSSL証明書を設置する手法
- ロードバランサーとWebサーバー間はHTTPで通信を行う
