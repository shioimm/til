# コネクションのライフサイクル
## 接続開始 (3wayハンドシェイク)
1. クライアント
    - サーバーへSYNフラグをセットしたセグメントを送信 (アクティブオープンの開始)
      - クライアント自身の初期シーケンス番号の通知
    - クライアント: CLOSED -> SYN-SENT / サーバー: LISTEN
    - シーケンス番号: クライアントが無作為に選んだ番号x
2. サーバー
    - クライアントからSYNフラグをセットしたセグメントを受信 (パッシブオープンの開始)
    - クライアントへSYNフラグ・ACKフラグをセットしたセグメントを送信
      - クライアントのSYNに対する確認応答とサーバー自身の初期シーケンス番号の通知
    - クライアント: SYN-SENT / サーバー: LISTEN -> SYN-RECEIVED
    - シーケンス番号: サーバーが無作為に選んだ番号y
    - 確認応答番号: クライアントから受け取った番号x + 1
3. クライアント
    - サーバーからSYN・ACKフラグをセットしたセグメントを受信
    - サーバーへACKフラグをセットしたセグメントを送信
      - サーバーのSYNに対する確認応答
    - クライアント: SYN-SENT -> ESTABLISHED / サーバー: SYN-RECEIVED
    - シーケンス番号: サーバーから受け取った番号x + 1
    - 確認応答番号: クライアントから受け取った番号y + 1
4. サーバー
    - クライアントからACKフラグをセットしたセグメントを受信
      - コネクションが確立する
    - クライアント: ESTABLISHED / サーバー: SYN-RECEIVED -> ESTABLISHED

### シーケンス番号と確認応答
- TCPコネクション上を流れる全てのバイトにはランダムな論理シーケンス番号が振られ、
  そのコネクションのストリーム内での位置を示す
- TCPセグメント送信時はセグメントの先頭バイトのシーケンス番号をTCPヘッダに格納する
- シーケンス番号は32ビットの幅を持ち、最大値に達すると0に戻る
- 受信側はセグメントを正常に受信すると送信側へ確認応答(ACKフラグがセットされたセグメント)を返す
- 確認応答番号フィールドは次に期待する論理シーケンス番号を表す
- 送信TCPはセグメント送信時にタイマーを仕掛ける
  タイマーが切れる前に確認応答しなければそのセグメントを再送する

## 接続確立
- クライアント - サーバー間で実際のアプリケーションデータのやりとりを行う
- データ転送の信頼性を保つためにフロー制御・輻輳制御・再送制御を利用する

## 接続終了 (4wayハンドシェイク)
- クライアント・サーバーのうちどちらかがFINパケットを送出し (アクティブクローズ)、
  相手ホストがそれを受け付ける (パッシブクローズ)
- 両ホストが送信するパケットのコントロールビットを
  FIN / ACK -> ACK -> FIN / ACK -> ACKの順にやりとりすることによって終了確認を行う
1. アプリケーションからクローズ処理の要求が入る
2. クライアント
    - サーバーへFIN / ACKフラグをセットしたセグメントを送信
    - サーバーも実行できるが通常は通常はクライアントが実行する
    - クライアント: - -> FIN-WAIT1 / サーバー: -
    - シーケンス番号: クライアントが無作為に選んだ番号x
3. サーバー
    - クライアントからFIN / ACKフラグをセットしたセグメントを受信
    - クライアントへACKフラグをセットしたセグメントを送信
    - クライアントのFINに対する確認応答
    - 以降サーバーが当該ソケットを`read()`するとEOFを検出する
    - サーバーはアプリケーションからのクローズ要求を待つ
    - クライアント: FIN-WAIT1 / サーバー: - -> CLOSE-WAIT
    - 確認応答番号: クライアントから受け取った番号x + 1
4. クライアント
    - サーバーからACKフラグをセットしたセグメントを受信
    - クライアント: FIN-WAIT1 -> FIN-WAIT2 / サーバー: CLOSE-WAIT
5. サーバー
    - アプリケーションからクローズ処理の要求を受け取る
    - クライアントへFIN / ACKフラグをセットしたセグメントを送信
    - クライアント: FIN-WAIT2 / サーバー: LAST-ACK
    - シーケンス番号: サーバーが無作為に選んだ番号y
6. クライアント
    - サーバーからFIN / ACKフラグをセットしたセグメントを受信
    - サーバーへACKフラグをセットしたセグメントを送信
    - サーバーのFINに対する確認応答
    - クライアント: FIN-WAIT2 -> TIME-WAIT / サーバー: LAST-ACK
    - 確認応答番号: サーバーから受け取った番号y + 1
7. サーバー
    - クライアントからACKフラグをセットしたセグメントを受信
    - コネクションを削除
    - コネクションのために確保していたリソースを解放
    - クライアント: TIME-WAIT / サーバー: LAST-ACK -> CLOSED
8. クライアント
    - 設定された時間を待ってコネクションを削除
    - コネクションのために確保していたリソースを解放
    - クライアント: TIME-WAIT -> CLOSED / サーバー: CLOSED

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
- パケットキャプチャの教科書
