# TCPエンドポイント
- TCPコネクションの一方の接続端点に対応するカーネルが管理する情報(受信TCP / 送信TCP)
  - 送信バッファ
  - 受信バッファ
  - 接続済みエンドポイントを同期するための状態情報
- TCPコネクションの管理のため両端TCPエンドポイントはステートマシンを実装する
  - TCPは状態を持つ
  - TCPはイベントをきっかけにある状態から別の状態へ遷移する

## TCPの状態
#### `LISTEN`
- ピアTCPからの接続要求を待っている

#### `SYN_SENT`
- アプリケーションがアクティブオープンを実行し、TCPがSYNを送信し、
  コネクションを完了するべくピアTCPからのSYNに対する応答を待っている

#### `SYN_RECV`
- `LISTEN`状態だったTCPがSYNを受信し、SYN/ACKを返し、
  コネクションを完了するべくピアTCPからのACKを待っている

#### `ESTABLISHED`
- ピアTCPへのコネクションが確立された

#### [アクティブクローズ]`FIN_WAIT1`
- アプリケーションがコネクションをアクティブクローズし、
  自TCPはピアTCPへFINを送信し、ACKを待っている
  - -> `FIN_WAIT2`
  - -> `CLOSING`

#### [アクティブクローズ]`FIN_WAIT2`
- `FIN_WAIT1`だったTCPがACKを受信した
  - -> `TIME_WAIT`

#### [アクティブクローズ]`CLOSING`
- `FIN_WAIT1`だったTCPのピアTCPがアクティブクローズし、
  自TCPがピアTCPからFINを受信した
  - -> `TIME_WAIT`

#### [アクティブクローズ]`TIME_WAIT`
- TCPがアクティブクローズを実行し、ピアTCPがパッシブクローズを実行し、
  自TCPがピアTCPからFINを受信した
- 規定時間経過後にコネクションはクローズされ、使用していたカーネルリソースが解放される
  規定時間は2MSL(最長セグメント寿命)(Linuxは1MSLが30秒)
  - 規定時間中に同じポートを別ソケットにバインドしようとすると`EADDRINUSE`が発生する
  - `SO_REUSEADDR`オプションは`TIME_WAIT`の信頼性を維持しつつ`EADDRINUSE`を回避する

#### [パッシブクローズ]`CLOSE_WAIT`
- ピアアプリケーションがアクティブクローズを実行し、自TCPがピアTCPからFINを受信した
  - -> `LAST_ACK`

#### [パッシブクローズ]`LAST_ACK`
- アプリケーションがパッシブクローズを実行し、`CLOSE_WAIT`だったTCPがFINを送信し、
  ピアTCPからのACKを待っている
- ACKを受信するとコネクションはクローズされ、使用していたカーネルリソースが解放される

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
