# 名前解決
1. クライアントが`www.example.com`ドメインにアクセスを試行する
2. DNSクライアント (スタブリゾルバ) -> ローカルDNSサーバ: 問い合わせを送信
3. ローカルDNSサーバ -> ルートサーバ: 問い合わせを送信
4. ローカルDNSサーバ <- ルートサーバ: 応答 (`com`の権限元のDNSサーバ) を送信
5. ローカルDNSサーバ -> `com`の権限元DNSサーバ: 問い合わせを送信
6. ローカルDNSサーバ <- `com`の権限元DNSサーバ: 応答 (`example.com`の権限元のDNSサーバ) を送信
7. ローカルDNSサーバ -> `example.com`の権限元DNSサーバ: 問い合わせを送信
8. ローカルDNSサーバ <- `example.com`の権限元DNSサーバ: 応答 (`www.example.com`の権限元DNSサーバ) を送信
9. ローカルDNSサーバ -> `www.example.com`の権限元DNSサーバ: 問い合わせを送信
10. ローカルDNSサーバ <- `www.example.com`の権限元DNSサーバ: 応答 (IPアドレス) を送信
11. ローカルDNSサーバがDNSクライアントにIPアドレスを返す

#### スタブリゾルバ (DNSクライアント)
- 解決したいドメイン名の問い合わせリクエストをフルリゾルバへ送信するクライアント
- クライアント端末のOSにAPIとして実装
- フルサービスリゾルバやフォワーダに再帰的問い合わせを送信する
- OSのネットワーク設定の「ネームサーバ」欄に利用するフルサービスリゾルバ、フォワーダのIPアドレスを設定する

#### フォワーダ
- スタブリゾルバや別のフォワーダからのリクエストをフルサービスリゾルバや別のフォワーダに転送するリゾルバ

#### フルリゾルバ (DNSキャッシュサーバ / フルサービスリゾルバ)
- スタブリゾルバからのリクエストに対して、情報を持っている権威サーバからレコードを取得して返すDNSサーバ
  - 名前解決した結果はキャッシュに保存しておき、再利用する
  - フルリゾルバは自分よりも更に上位のサーバへ再帰的にアクセスを行い、
    最終的にそのドメインの権威サーバへたどり着く

#### 権威サーバ (ネームサーバ / DNSコンテンツサーバ / 権威DNSサーバ)
- リソースレコードを管理するホストやソフトウェア
- 自身が設置された階層のドメインに関する情報を管理する
  - それぞれのドメインの階層ごとに権威サーバが配置される

#### ルートサーバ (ルートネームサーバ)
- 全てのトップレベルドメイン (.com、.jpなど) のネームサーバ情報を持つサーバ

#### 委任
- 各ネームサーバが受け持つゾーンのうち、一部を他のネームサーバに任せること
- ゾーンを委任されたネームサーバはそのドメインについて権威を持つ
  - サブドメインを作った受け持つゾーンのうちその一部を更に他のネームサーバに委任することができる

#### TTL
- 名前解決のキャッシュ保持時間
- DNSを切り替えた後、TTLが切れると切り替えが成立する -> DNSが浸透する

#### DNSゾーン
- DNSサーバが管理を任された名前空間 (DNS名のグループ)
- 一つのゾーンファイル (DB) で管理するドメイン名の範囲

#### ゾーン転送
- 通常冗長化を行う目的で2つの機器 (サーバ) の間でゾーンデータを転送する際に発生する
- ゾーン内のプライマリDNSコンテンツサーバのゾーンファイルを
  セカンダリDNSコンテンツサーバに同期することで冗長化を図る仕組み
- バージョン確認 - セカンダリサーバがプライマリサーバへSOAレコードを要求すること (UDP)
- 完全ゾーン転送 - 機器間でゾーン全体を転送する
- 増分ゾーン転送 - ゾーン情報の一部のみを転送する

## 参照
- DNSをはじめよう ～基礎からトラブルシューティングまで～ 改訂第2版
- サーバ・インフラエンジニアの基本がこれ一冊でしっかり身につく本 3.4
- Real World HTTP 第2版
- 実践パケット解析 第3版
- [RubyKaigiとDNS-over-HTTPSとDDR](https://blog.kmc.gr.jp/entry/2023/05/10/165300)
