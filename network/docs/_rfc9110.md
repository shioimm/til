# RFC 9110 HTTP Semantics
## Terminology and Core Concepts
- resource - リクエストの対象。URIによって識別される
- representation - リソースの状態の反映。リクエストに基づきコンテンツネゴシエーションによって選択される
- client - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- server - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- messages - 接続を介して交換される情報
- user agent - リクエストを開始するさまざまなクライアントアプリケーション (Webブラウザなど)
  - Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- origin server - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- intermediary - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
  - proxy - クライアントが利用するメッセージ転送エージェント
  - gateway (reverse proxy) - オリジンサーバが利用するメッセージ転送エージェント
  - tunnel - メッセージを変更せずにユーザーエージェント/オリジンサーバ間を中継する
- cache - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP
### URI References
- HTTPではURI Referencesの形式ごとに使用可能な場面を厳密に定義している
  - 明示がない場合URI ReferencesはターゲットURIを基準として相対的に解析される

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

### Authoritative Access
- 特定の識別子を解決して識別されたリソースへのアクセスを行う際、
  そのアクセスがリソース所有者によって制御されているとクライアントが信頼できる形で行われること
- アクセスが許可されるかどうかのプロセスはURIスキームによって定義される

#### URI Origin
- 正規化されたスキーム / ホスト / ポートの3要素からなる組。HTTPにおける名前空間と権限の境界を形成する。

#### http Origin
- URIに含まれるauthority (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバがそのURIを代表しているとみなされるオリジン (論理的な起点)

#### https Origin
- URIに含まれるhost:portではなく、そのoriginに対して有効であるとクライアントが信頼する証明書に対応する秘密鍵を持つ
  サーバに対して確立される権威 (authority) に基づくオリジン
- H1 - URI originのhostに対してTLSで保護された接続が直接確立されている場合にauthorityを認める
- H2/H3 - 証明書に含まれる複数のhostに対して接続可能であるとクライアントが信頼できる場合にauthorityを認める

#### https Certificate Verification
- httpsでURIをdereferenceする際、クライアントは接続先サービスの身元がそのURIのoriginと正しく一致していることを
  RFC6125に基づく証明書検証によって確認する

#### IP-ID Reference Identity
- httpsでホストにIPリテラルを用いる場合、参照アイデンティティはIP-ID (P Address Identity) となり、
  証明書のsubjectAltNameに含まれるiPAddressと完全一致する必要がある

## Fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される
-
### Field Names

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
- プロキシはConnectionヘッダフィールドにそのフィールド名が列挙されていない限り
  or 当該フィールドを遮断もしくは変換するよう明示的に設定されていない限り、
  認識できないヘッダフィールドをオリジンに転送しなければならない
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する

### Field Lines and Combined Field Value / Field Order
- フィールドは任意数のフィールド行から構成され、フィールド行はフィールド名とフィールド行値から構成される
- 同一フィールド名が複数行で現れた場合、フィールド値は各行の値を順にカンマ区切りで連結したものとして解釈される
  - 送信者は原則として複数同名フィールドを複数送信してはいけない (実務上の都合によりSet-Cookieを除く)
  - サーバはヘッダ全体を受信し終えるまで処理してはならない

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
- サーバ側では大きすぎるヘッダを受け取った場合、適切な4xxを返す
- クライアント側では大きすぎるヘッダを受け取った場合、レスポンスの意味を変えない範囲で破棄したり切り詰めても良い

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
- CR / LF / NULを含むfield valueは無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
- Singleton fields - フィールド値として単一の要素のみを想定するフィールド
- List-based fields - フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される

### Common Rules for Defining Field Values
- カンマ区切りの値の列の可読性を上げるために`#rule`ABNF拡張が定義されている

```
<n>#<m>element

最低n個~最大m個のelementをカンマ + OWS区切りで並べる

e.g.
  example-list      = 1#example-list-elmt
  example-list-elmt = token

において、

<有効>
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"

<無効>
  ""
  ","
  ",   ,"
```

- 送信者は空要素を生成してはいけない。受信者は妥当な範囲で空要素を無視する。
- token - 最も基本的な識別子。1文字以上、空白や区切り文字を含まない、可視ASCIIのうちdelimiterを除いた集合
- OWS - 任意空白。送信者は生成可能、受信者はSP1個に正規化可能
- RWS - 必須空白。送信者はSP 1個を生成推奨、受信者はSP 1個に正規化可能
- BWS - 悪い空白。送信者は生成禁止、受信者は必ず削除
- quoted-string - `"`で囲まれた空白・カンマ・特殊文字を含む値
- パラメータ構文 - フィールド値に付加情報を付ける共通形式

```
パラメータ構文

; name=value

name  ... token (大文字小文字を区別しない)
value ... token or quoted-string
= の前後に空白は禁止
```

- 日時形式はUTC (GMT) 固定。送信者はIMF-fixdateのみ生成可能、送信者はIMF-fixdate、RFC 850形式、asctime形式を受理

## Message Abstraction (HTTPメッセージの抽象データ型)
- メッセージの構成要素
  - Control data (制御データ) メッセージの種別・経路決定に必要な即時情報
  - Headers lookup table (ヘッダ表) 制御データを拡張し追加情報を伝えるための名前:値の組の集合
  - Content (本文ストリーム) 任意・サイズ無制限のデータ
  - Trailers lookup table (トレーラ表) 本文送信中に得られた情報を伝えるための名前:値の組の集合
- メッセージはストリームとして前方から順に処理される
  - 制御データは受信者が即座に知る必要のある事項
  - ヘッダフィールドは受信者がコンテンツ受信前に知る必要のある事項
  - コンテンツはメッセージのセマンティクスを満たすために受信者が必要とする本体
  - トレーラフィールドはコンテンツ送信前には不明であった任意のメタデータ
- メッセージはそれ自体で意味が完結することを意図 (自己記述性)
- クライアントは対応するレスポンスを解析・解釈・キャッシュする際には
  それに対応するリクエストに関する知識を保持していなければならない

### Framing and Completeness
- メッセージフレーミング = 各メッセージがどこから始まり、どこで終わるのかを示す仕組み
  - メッセージは同一の接続上を流れる他のメッセージと区別される必要がある
- メッセージデータを長さで区切る (length-delimited) 形式で送信することによって明示的フレーミングを行う
  - Content-Length
  - Transfer-Encoding: chunked
  - HTTP/2 / HTTP/3のフレーム境界
- そのフレーミングによって示されたすべてのオクテットが受信可能になった時点でそのメッセージは完了
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- リクエストメッセージの制御データ
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データ
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前: 制御データはメッセージの最初の行で送信される
- HTTP/2 / HTTP/3: 制御データは予約された名前プレフィックスを持つ疑似ヘッダフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージはバージョンを持つ
  - バージョンはメッセージ内で明示される場合やメッセージが受信された接続から推定される場合がある
  - 受信者はバージョン情報を用いて送信者との以後の通信における制約や可能性を判断する
  - メッセージが転送される場合は中継者が使うバージョンに更新される (上流のプロトコルバージョンはViaヘッダに記載)
  - クライアントは自身が準拠している中で最高の、かつサーバがサポートしている最高以下のバージョンを送信する
  - サーバは自身が準拠している中で最高の、かつ受信したリクエストの最高以下のバージョンを送信する

### Header Fields
- 本文 (Content) より前に送受信され、メッセージの意味を補足・拡張したり、追加の情報を記述するためのメタデータ
- ヘッダフィールド = ヘッダフィールド行 (フィールド名 + フィールド値) の並び

### Content
- メッセージフレーミングによって区切られたヘッダの後に送信されるバイトストリーム (フレーミングを除去した実データ)

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

#### Identifying Content
- 完全または部分的な表現がメッセージ本文として転送される場合、
  その本文がどのリソースのどの表現なのかを識別できることが望ましい

### Trailer Fields
- 本文 (Content) より後に送受信され、本文を送信し終えた後でしか確定しない情報を伝えるためのメタデータ
  - メッセージ整合性チェック
  - デジタル署名
  - 配送メトリクス
  - 後処理の結果や状態情報 など
- ヘッダセクションのフィールドとは別個に処理・保存されるべき
- 特定のヘッダフィールドの有無はメッセージ全体の扱いに影響するため、
  その場合は後からトレーラが到着しても取り消すことはできない

#### Limitations on Use of Trailers
- 使用中のHTTPバージョンが対応しており、かつ明示的なフレーミング機構によって有効化されている場合にのみ利用できる
- トレーラは中間者によって破棄される可能性がある
  - サーバはトレーラーフィールドとしてユーザーエージェントが必ず受信すべき情報を送信すべきではない
- 受信者は、対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラ値を安全に統合できる方法を
  明示的に許可・規定されいる場合を除き、トレラーフィールドをヘッダーセクションに統合してはならない
- リクエストの`TE`ヘッダに`trailers`が含まれる場合、クライアントがトレーラを受け取っても破棄しないという同意を示す
  - ただし処理をするとは言っていない

#### Processing Trailer Fields
- トレーラセクションで送信される可能性のあるフィールド名を事前に示すために`Trailer`ヘッダフィールドを利用できる
- 同じ名前を持つトレーラーフィールドは受信した順序で処理される
- 同一名のトレーラフィールド行が複数存在する場合、値はリストとして連結される

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- メッセージが生成された日時 (HTTP-date 形式)
- 時計を持つオリジンサーバは、2xx、3xx、4xx系レスポンスにおいては必ず`Date`ヘッダフィールドを生成しなければならない
- 時計を持たないオリジンサーバは、`Date`ヘッダフィールドを生成してはならない
- 時計を持つ受信者が`Date`ヘッダフィールドを含まないレスポンスを受信した場合、
  そのレスポンスを受信した時刻を記録し、そのレスポンスをキャッシュまたは下流へ転送する際には
  ヘッダセクションに対応する`Date`ヘッダフィールドを追加しなければならない

#### Trailer
- そのメッセージ内でトレーラフィールドとして送信される予定のフィールド名の一覧

## Routing HTTP Messages
- リクエストメッセージのルーティングは対象リソース、クライアントのプロキシ設定、
  インバウンド接続の確立または再利用に基づいてクライアントが決定する
- 対応するレスポンスのルーティングは同じ接続経路を逆方向にたどってサーバからクライアントへ返送される

### Determining the Target Resource
- Target Resource (対象リソース) - クライアントが操作したいリソースそのもの
- Target URI (対象URI) - Target Resourceを一意に識別するために使われる絶対URI (URI参照を解決して得られる)
  - クライアントの設定 (URL、プロキシ設定、既定ホストなど) はURI参照とみなすことがでくる
  - URI参照を解決して絶対URIを取得し、フラグメントを除外することで対象URIが確定する
- クライアントは対象リソースに対する操作を行うため、受信者が同一のリソースを特定できる
  解析済みTarget URIの構成要素 (request target) を含むリクエストメッセージを送信する
  - request targetはメソッド定義に従い、メッセージの制御データおよびHostヘッダフィールドとして送信される
  - 例外1) CONNECT - request targetはトンネル先のホスト名とポート番号をコロンで連結した形式となる
  - 例外2) OPTIONS - request targetとしてアスタリスク`*`を使用できる
- サーバは受信した情報から対象URIを再構築する (再構成方法はHTTPのメジャーバージョンごとに異なる)

### Host and :authority
- リクエストにおける`Host`ヘッダフィールドは、対象URIに含まれるホストおよびポート情報を提供し、
  オリジンサーバが複数のホスト名に対するリクエストを処理する際に対象のリソースを識別できるようにする
  - HTTP/2 or 3では場合によってリクエスト制御データに含まれる`:authority`擬似ヘッダフィールドが`Host`の役割を担う
- クライアントはリクエストに`Host`ヘッダフィールドもしくは`:authority`擬似ヘッダーフィールドを必ず含める

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

### Routing Inbound Requests
- クライアントは対象URIおよびそのオリジンの確定後、
  ネットワークリクエストが必要かどうかを判断し、必要である場合にはそのリクエストをどこへ送信するかを決定する

#### To a Cache
- クライアントがキャッシュを持っており、そのキャッシュでリクエストを満たせる場合、
  キャッシュに対してリクエストが向けられる

#### To a Proxy
- キャッシュでリクエストが満たされず、設定に基づいてプロキシが適用可能と判断された場合、
  そのプロキシに対してインバウンド接続を確立 (または再利用) し、
  クライアントのTarget URIに一致するリクエストターゲットを含むHTTPリクエストメッセージを送信する
  - プロキシの設定方法は実装依存
  - 多くの場合はURIプレフィックスの一致、authorityの選択的な一致、あるいはその両方に基づいて判断される
  - プロキシ自体は通常、httpまたはhttpsのURIによって識別される

#### To the Origin
- 適用可能なプロキシが存在しない場合、対象URIのスキームに固有のハンドラ処理を起動し、
  識別されたリソースへのアクセスを試みる
  - 対象がhttpリソースの場合、識別されたオリジンサーバへのインバウンド接続を確立 (または再利用) し、
    対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する
  - 対象がhttpsリソースの場合、識別されたオリジンに対して権威を持つオリジンサーバとのセキュアなインバウンド接続を
    確立 (または再利用) し、その上で対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する

### Rejecting Misdirected Requests
- サーバがリクエストを受信し、対象URIを判定できる程度まで解析すると、サーバはそのリクエストへの対応を決定する
  - 自ら処理する
  - 別のサーバへ転送する
  - クライアントを別のリソースへリダイレクトする
  - エラーで応答する
  - 接続を切断する など
- 接続が信頼されたゲートウェイからのものでないとき、サーバは対象URIに対し、
  スキーム固有の要件が満たされていないリクエストを必ず拒否しなければならない
  - 特にhttpsリソースに対するリクエストは、対象URIのオリジンに対して有効な証明書によって
    セキュア化された接続上で受信されていない限り、拒否しなければならない
- オリジンサーバがそのリクエストを誤配送と判断して拒否する場合、ステータスコード421 Misdirected Request を返す

### Response Correlation
- 1つの接続は複数のリクエスト - レスポンス交換に使用される場合がある
- リクエストとレスポンスの組みを対応付ける仕組みはHTTPのバージョンによって異なる
- すべてのレスポンスは、ステータスコードにかかわらずリクエストの受信後であればいつでも送信できる
  - リクエストがまだ完了していない場合であっても、レスポンスが先に完了することもある
  - クライアントはレスポンスを待つために特定の時間だけ待機することを期待されてはいない
    - クライアントは、合理的な時間内にレスポンスを受信できない場合、そのリクエストを放棄することがある
  - 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に中止を示す指示を受け取らない限り、
    当該リクエストの送信を継続すべき

### Message Forwarding
- 中間者 (intermediary) はHTTP リクエストおよびレスポンスの処理においてさまざまな目的で使用される
  - 性能・可用性向上 (キャッシュ、ロードバランシング)
  - アクセス制御 (認証・認可、フィルタリング、セキュリティゲートウェイ)
- HTTPストリームはpipe-and-filter型の性質を持つため、リクエスト方向・レスポンス方向のどちらに対しても
  中間者が処理を追加・変更・干渉する際の理論的上限はない
- 中間者はプロトコル要素を認識できない場合であっても、メッセージを転送することが期待される
- トンネルとして動作していない中間者は、Connectionヘッダーフィールドを実装しなければならず、
  かつ受信側接続のみに向けられたフィールドを転送から除外しなければならない
- 中間者は、無限のリクエストループから保護されていない限り、自分自身にメッセージを転送してはならない
- 中間者は自身のサーバ名を認識し、自分自身を指す宛先へのリクエストには直接応答すべき
- HTTPメッセージは下流への逐次処理や転送のために、ストリームとして解析することができる
  - 一方送信者や受信者は、部分メッセージが逐次的に配送されることを前提にしてはならない
  - 実装によってはさまざまな理由でメッセージ転送をバッファリングまたは遅延させる場合があるため

#### Connection
- `Connection`ヘッダフィールドは、送信者が現在の接続限りで有効な制御オプションを列挙するためのもの
  - HTTPでは二種類のヘッダがあり、`Connection`ヘッダはこの区別を明示するための仕組み
    - hop-by-hop - 現在の接続の相手だけに意味があり、次の中継先へは送ってはいけない
    - end-to-end - メッセージ全体に意味を持ち、中継を越えて伝える
  - 大文字・小文字を区別しない
  - `Connection`以外のフィールドを用いて現在の接続に関する制御情報を提供する場合、
    `Connection`ヘッダフィールド内に対応するフィールド名を列挙しなければならない
    - HTTPの一部バージョンでは、そのような情報をフィールドで表現すること自体が禁止されている
- トンネルとして動作していない中間者は、メッセージを転送する前に受信した`Connection`ヘッダフィールドを必ず解析し、
  このフィールドに含まれる各オプションと同名のヘッダまたはトレーラフィールドはメッセージから削除し、
  `Connection`ヘッダフィールド自体も削除する
  - または転送されるメッセージに対する中間者自身の制御オプションに置き換える
- 中間者は、仕様としてhop-by-hopであると決まっているフィールドについては、
  それらがオプションとして列挙されているか否かにかかわらず、当該フィールドの意味論を適用した上で削除または置換すべき
  - `Proxy-Connection`, `Keep-Alive`, `TE`, `Transfer-Encoding`, `Upgrade`など
- 送信者は、コンテンツのすべての受信者を対象とするフィールドに対応するオプションを送信してはならない
  - `Cache-Control`など
- オプションは必ずしも実在するフィールドと対応する必要はない
  - `Connection`にないのに接続専用フィールドが来た場合、受信者は無視するべき

#### Max-Forwards
- `Max-Forwards`ヘッダフィールドは、TRACEおよびOPTIONSリクエストメソッドにおいて
  プロキシによる転送回数の上限 (このリクエストメッセージが今後転送され得る残り回数を示す10進整数) を明示するもの
  - `Max-Forwards`ヘッダフィールドを含むTRACE / OPTIONSリクエストを受信した中間者は、
    リクエストを転送する前に、`Max-Forwards`の値を必ず確認・更新する
    - 受信した値が0: 中間者はリクエストを転送せずに最終受信者としてレスポンスを返す
    - 受信した値が0より大きい: `Max-Forwards` = `[受信した値 - 1, 中間者がサポートするMax-Forwardsの最大値].min`
- TRACE / OPTIONS 以外のリクエストメソッドで受信した`Max-Forwards`ヘッダフィールドについては無視してもよい

#### Via
- `Via`ヘッダフィールドは、クライアント - サーバ間に存在する中間プロトコルおよび中間受信者を示すもの
- `Via`フィールド値の各要素は、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中間者は自身がそのメッセージをどのように受信したかの情報を`Via`フィールド値の末尾に追加 するため、
    最終的な`Via`の並び順は、転送経路の順序を表す
- プロキシは転送するすべてのメッセージに対して、`Via`ヘッダフィールドを必ず送信しなければならない
  - HTTP-to-HTTPゲートウェイはすべての受信リクエストに対して必ず`Via`を送信しなければならない。
    転送するレスポンスに対しては送信してもよい。

```
Via: 1.0 fred, 1.1 p.example.net

1. クライアント -> fred (HTTP/1.0)
2. fred -> p.example.net (HTTP/1.1)
3. p.example.net -> オリジンサーバへ
```

### Message Transformations
- HTTP-to-HTTPプロキシのうち、意味的に重要な形でメッセージを変更するよう設計または設定されているものは
  変換プロキシ (transforming proxy) と呼ばれる
  - 共有アノテーションサーバ
  - マルウェアフィルタ
  - フォーマット変換
  - プライバシーフィルタ
- これらの変換はそのプロキシを選択したクライアントによって意図的に望まれているものとみなされる
- プロキシが受信した対象URIのホスト名がFQDNでない場合、プロキシはリクエスト転送時に自身のドメインを付加してもよい
  - 対象URIにFQDNが含まれている場合、プロキシはホスト名を変更してはならない
  - 転送プロトコル上必要とされる場合を除き、対象URIのabsolute-pathおよびquery部分を変更してはならない
- プロキシはレスポンスメッセージのコンテンツに`no-transform`キャッシュディレクティブが含まれている場合、
  そのコンテンツを変換してはならない (コンテンツ自体を変更しない変換を除く)
  - `no-transform`が含まれていないメッセージについては、プロキシはコンテンツを変換してもよい
- プロキシが200 OK レスポンスのコンテンツを変換した場合、下流の受信者に変換が行われたことを示すために、
  レスポンスステータスコードを203 Non-Authoritative Informationに変更して通知することができる。
- プロキシは通信経路のエンドポイント、リソースの状態、または選択された表現に関する情報を提供するヘッダフィールドを
  変更すべきではない
  - そのフィールド定義が明示的に許可している場合、またはプライバシーやセキュリティ上必要と判断される場合を除く

### Upgrade
