# RFC 9110 HTTP Semantics https://www.ietf.org/rfc/rfc9110.html
## Length Requirements https://www.ietf.org/rfc/rfc9110.html#name-length-requirements
- [SHOULD] 受信者は受信したプロトコル要素を防御的に解析すべきである
  - その要素がABNF文法に完全に適合していることや、妥当なバッファサイズ内に収まることについては、
    最小限の期待しか置かない前提で処理するべきである
- HTTPでは多くのプロトコル要素について明確な長さの制限を定めていない
  - 配備環境や実装の目的によって適切な長さが大きく異なるため
  - 送信者と受信者の相互運用性は、各プロトコル要素について妥当な長さが何であるかという共有された期待に依存する
    - HTTPが利用されてきた過去30年余りの間に、いくつかのプロトコル要素について妥当と理解される長さは変化しており、
      将来にわたっても変化し続けると考えられる
- [MUST] 受信者は同種のプロトコル要素について、
  自らが他のメッセージで生成しうる長さと同等以上の長さを解析および処理できなければならない
  - オリジンサーバが自身のリソースに対して非常に長いURI参照を公開している場合、
    そのサーバはそれらが対象URIとして受信された際にも同じ参照を解析・処理できる必要がある
- 受信されるプロトコル要素の多くは、下流へ転送するために必要な範囲でのみ解析される
  - 中継者は、受信したフィールドをフィールド名とフィールド値に分解して解析するが、
    フィールド値の内部構造までは解析せず、そのまま転送することがある

## Error Handling https://www.ietf.org/rfc/rfc9110.html#name-length-requirements
- [MUST] 受信者は本仕様および本仕様への拡張で定義されている意味論に従い、受信したプロトコル要素を解釈する
  - 受信者が経験や設定を通じて、送信者がその意味論に含意される挙動を誤って実装していると判断した場合は
    この限りではない
    - e.g. `User-Agent`ヘッダフィールドを調査した結果、特定の実装バージョンがある種のコンテンツコーディングを
      受信すると失敗することが知られている場合、オリジンサーバは受信した`Accept-Encoding`の内容を無視することがある
- [MAY] 特に明記されていない限り、受信者は不正な構造から利用可能なプロトコル要素を回復しようと試みてもよい
  - HTTPは、セキュリティに直接影響する場合を除き、具体的なエラー処理機構を定義していない
    (プロトコルの利用形態によって適切なエラー処理戦略が異なるためである)
    - e.g. Webブラウザは、`Location`ヘッダフィールドがABNFに従って解析できないレスポンスからでも、
      透過的に回復することを望むかもしれない一方で、システム制御用のクライアントは、
      いかなる形のエラー回復であっても危険と見なす可能性がある
- 基盤となる接続障害が発生した場合には、クライアントが一部のリクエストを自動的に再試行できる場合がある
  (Idempotent Methods)

## Terminology and Core Concepts https://www.ietf.org/rfc/rfc9110.html#name-terminology-and-core-concep
- リソース Resource
  - リクエストの対象。URIによって識別される
- 表現 Representation
  - ある時点におけるリソースの状態を、HTTPメッセージで伝送可能な形にしたもの
  - リクエストに基づきコンテンツネゴシエーションによって選択される
- クライアント Client
  - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- サーバ server
  - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- メッセージ Messages
  - 接続を介して交換される情報
  - クライアントは、メソッドおよび対象リソースを含むリクエストメッセージをサーバへ送信する
    - リクエストにはリクエスト修飾子、クライアント情報、表現メタデータのためのヘッダフィールド、
      メソッドに従って処理されることを意図したボディ、
      ボディの送信中に収集された情報を伝達するためのトレーラフィールドが含まれる場合がある
 - サーバは、クライアントのリクエストに対し、1つ以上のレスポンスメッセージを送信することで応答する
   - レスポンスにはステータスコードが含まれる
   - レスポンスにはサーバ情報、リソースメタデータ、表現メタデータのためのヘッダフィールド、
     ステータスコードに従って解釈されるボディ、
     ボディの送信中に収集された情報を伝達するためのトレーラフィールドが含まれる場合がある
- ユーザエージェント User Agent
  - リクエストを開始するさまざまなクライアントアプリケーション
  - e.g. Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- オリジンサーバ Origin Server
  - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - e.g. 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- 中継者 Intermediary
  - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
    - プロキシ Proxy - クライアントが利用するメッセージ転送エージェント
    - ゲートウェイ Gateway (Reverse Proxy) - オリジンサーバが利用するメッセージ転送エージェント
    - トンネル Tunnel - メッセージを変更せずにユーザエージェント/オリジンサーバ間を中継する
- キャッシュ Cache
  - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP https://www.ietf.org/rfc/rfc9110.html#name-identifiers-in-http
### URI References
- URI参照はリクエストの対象を指定し、リダイレクトを示し、リソース間の関係を定義するために用いられる

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

- HTTPにおいてURI参照を許可する各プロトコル要素は、そのABNF定義の中でどの形式の参照を許可するかを示す
  - 任意の形式のURI参照 (URI-reference) を許可するか、絶対URI (absolute-URI) のみを許可するか、
    パスと任意のクエリ要素のみ（partial-URI）を許可するか、あるいはそれらの組み合わせかが明示される
    - 特に明記されていない限りURI参照は対象URIに対して相対的に解釈される
- [RECOMMENDED] すべての送信者および受信者は、プロトコル要素内で8000オクテット長以上のURIをサポートすることが
  推奨される
  - 一部の構造や通信路上の表現は、場合によっては必然的により大きくなりうる

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

#### http URI Scheme
- http URIスキームは、特定のポートでTCP接続を待ち受ける可能性のあるHTTPオリジンサーバによって管理される、
  階層的な名前空間内で識別子を発行するために定義される

```
http-URI = "http" "://" authority path-abempty [ "?" query ]
```

- http URIのオリジンサーバは、`authority`構成要素によって識別される
  - `authority`にはホスト識別子と任意のポート番号が含まれる
  - ポートの副要素が空である場合または指定されていない場合はTCP ポート80が既定値となる
  - オリジンは識別されたリソースを対象とするリクエストに対して、誰が権威をもって応答できるかを決定する
- [MUST NOT] 送信者はホスト識別子が空のhttp URIを生成してはならない
  - [MUST] そのようなURI参照を処理する受信者は、それを無効として拒否しなければならない
- 階層的な`path`構成要素および任意の`query`構成要素は、オリジンサーバの名前空間内における対象リソースを識別する

#### https URI Scheme
- https URIスキームは、特定のポートでTCP接続を待ち受け、HTTP 通信のためにセキュアに確立されたTLS接続を確立できる
  可能性のあるオリジンサーバによって管理される、階層的な名前空間内で識別子を発行するために定義される

```
セキュア:

当該`authority`を代表して動作していることがサーバとして認証されていること、
当該サーバとのすべてのHTTP通信がクライアントおよびサーバ双方にとって
受容可能な機密性および完全性の保護を備えていること
```

```
https-URI = "https" "://" authority path-abempty [ "?" query ]
```

- http URIのオリジンサーバは、`authority`構成要素によって識別される
  - `authority`にはホスト識別子と任意のポート番号が含まれる
  - ポートの副要素が空である場合または指定されていない場合はTCP ポート80が既定値となる
  - オリジンは識別されたリソースを対象とするリクエストに対して、誰が権威をもって応答できるかを決定する
- [MUST NOT] 送信者は、ホスト識別子が空のhttps URIを生成してはならない
  - [MUST] そのようなURI参照を処理する受信者は、それを無効として拒否しなければならない
- 階層的な`path`構成要素および任意の`query`構成要素は、そのオリジンサーバの名前空間内における対象リソースを識別する
- [MUST] クライアントは、httpsリソースに対するHTTPリクエストがセキュアであることを通信前に保証する
- [MUST] クライアントは、それらのリクエストに対してセキュアなレスポンスのみを受け入れる
  - どの暗号学的機構がクライアントおよびサーバにとって受容可能であるかの定義は、
    通常はネゴシエーションによって決定され、時間とともに変化し得る
- httpsスキームを通じて提供されるリソースは、httpスキームと同一のアイデンティティを共有しない
  - https / httpは別個のオリジンであり、独立した名前空間を持つ
    - Cookieプロトコルのように、同一ホストを持つすべてのオリジンに適用されるHTTP拡張は、
      一方のサービスによって設定された情報が、対応するホストドメイン群内の他のサービスとの通信に影響を与えることを
      許している
      - [ought to] このような拡張は、セキュアな接続から得られた情報が意図せず
        非セキュアな文脈に交換されることを防ぐため、細心の注意を払って設計されるべき

#### http(s) Normalization and Comparison
- httpまたはhttpsスキームを持つURIは、各スキームに対して前述の既定値を用い、[URI] 6で定義されている方法に従って
  正規化および比較される
- HTTPは同値性を判断するための特定の方法を必須としていない
  - キャッシュキーは構文ベースの正規化後に単純な文字列として比較される場合もあれば、
    スキームベースの正規化後に比較される場合もある
- httpおよびhttps URIに対するスキームベースの正規化 [URI] 6.2.3 には、以下の追加規則が含まれる:
  - ポートがそのスキームの既定ポートと等しい場合、正規形ではポート副要素を省略する
  - OPTIONSリクエストのターゲットとして使用されていない場合、空の`path`要素は絶対パス`/`と等価であるため、
    正規形では`path`を`/`とする
  - スキームおよびホストは大文字・小文字を区別せず、通常は小文字で提供される
    - 他の構成要素は大文字・小文字を区別して比較される
- `reserved`集合に含まれない文字は、パーセントエンコードされたオクテットと等価
  - 正規形ではそれらをエンコードしない [URI] 2.1 / [URI] 2.2

```
(以下は等価)

http://example.com:80/~smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
```

- 正規化後に等価となる2つのHTTP URIは、同一のリソースを識別しているとみなしてよい
  - [MAY] HTTPのいかなる構成要素も正規化を行ってもよい
  - [SHOULD NOT] その結果として、正規化後に等価となるHTTP URIを用いて異なるリソースを識別すべきではない

#### Deprecation of userinfo in http(s) URIs
- URIの汎用構文における`authority`には、ユーザ認証情報をURIに含めるための`userinfo`要素 [URI] 3.2.1 が含まれる
  - この副要素において`user:password`形式の使用は非推奨
  - 一部の実装では、URI中の`userinfo`要素を、コマンド実行時のオプション、設定ファイル、
    ブックマークリストなどにおける内部的な認証情報設定として利用している場合がある
    - そのような使用は、ユーザ識別子やパスワードを露出させる可能性がある。
- [MUST NOT] 送信者はメッセージ内で対象URIまたはフィールド値としてhttpまたはhttps URI参照を生成する際、
  `userinfo`およびその区切り文字`@`を生成してはならない
- [SHOULD] 信頼できない送信元から受信したhttpまたはhttps URI 参照を利用する前に、
  受信者は`userinfo`の有無を解析し、その存在をエラーとして扱うべき
  (フィッシング攻撃の目的で`authority`を偽装するために用いられている可能性が高いため)

#### http(s) References with Fragment Identifiers
- フラグメント識別子は [URI] 3.5 で定義されているとおり、URIスキームとは独立に
  二次的なリソースを間接的に識別するためのもの
  - URIを参照する一部のプロトコル要素ではフラグメントの包含が許可されているが、他の要素では許可されていない
    - これらはフラグメントを許可する場合に用いられるABNF規則が使用されているかどうかによって区別される
    - フラグメントが許可されない場合には、それを除外する特定の規則が用いられる
- フラグメント識別子要素はURIスキームの定義の一部ではなく、httpおよびhttps URIスキームのABNF定義には
  フラグメントは含まれていない

### Authoritative Access (権威的アクセス)
- 特定の識別子を参照して識別されたリソースへアクセスする際
  そのアクセスが権威的である = リソース所有者によって制御されているとクライアントが信頼している方法で行われること
  - アクセスが許可されるかどうかを判断するプロセスはURIスキームによって定義される
    - 汎用構文が用いられる場合には`authority`構成要素のようなURI構成要素内のデータがしばしば利用される
- 権威を持っている = そのURIを代表している

#### URI Origin
- あるURIに対するオリジン originとは、スキーム・ホスト・ポートの3要素の組
  - スキームおよびホストは小文字に正規化され、ポートは先頭の0を除去する形で正規化される
  - URIからポートが省略されている場合は、そのスキームに対する既定のポートが用いられる

```
e.g.

URI
https://Example.Com/happy.js

オリジン (スキーム・ホスト・ポート)
{ "https", "example.com", "443" }

正規化済みURIプレフィックス
https://example.com:443
```

- 各オリジンはそれぞれ独自の名前空間を定義し、その名前空間内の識別子がどのようにリソースへ対応付けられるか制御する
- 利用者がURIに結び付けて理解する意味論は、
  オリジンが有効なリクエストに対し、時間を通じて一貫した応答を行うことによって形成される
  - その意味論が有用であることにより、最終的にこれらは将来にわたって参照・アクセスされるリソースとして機能する
- スキーム、ホスト、またはポートのいずれかが異なるオリジン同士は異なるオリジン同士とされる
  - たとえ同一の主体が2つの異なるオリジンを管理していることが検証できたとしても、
    そのオリジンに対して権威を持つサーバによって明示的にエイリアス化されない限り、
    それぞれのオリジン配下の名前空間は別個のもの

#### http Origin
- httpスキームでは、URIに含まれる`authority` (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバが権威を持つとみなされる
- ホスト識別子がIPアドレスの場合、そのIPアドレス上の指定TCPポートで待ち受けているサーバがオリジンサーバ
- ホスト識別子が登録名の場合、その登録名は名前解決を介し適切なオリジンサーバのアドレスを見つけるための間接的識別子
- [MAY] http URIが、示されたリソースへのアクセスを要請する文脈で用いられた場合、
  クライアントはホスト識別子をIPアドレスに解決し、指定ポートでTCP接続を確立し、
  その接続上でクライアントの対象URIに一致するリクエストターゲットを含むHTTPリクエストメッセージを送信することで、
  アクセスを試みてもよい
  - そのようなリクエストに対してサーバが (中間ではない) HTTPレスポンスを返した場合、そのレスポンスは、
    クライアントのリクエストに対する権威的な応答とみなされる
    - 上記は権威的な応答を得るための唯一の手段ではなく、常に権威的な応答が必要であるわけでもない
      - e.g. オリジンサーバは`Alt-Svc`ヘッダフィールドを用いて、そのオリジンに対して権威を持つ他のサービスを
        示すことができる

#### https Certificate Verification
- httpsスキームでは、URIに含まれるhost:portではなく、当該オリジンサーバに対して有効であるとクライアントが信頼する
  証明書に対応する秘密鍵を持つサーバが権威を持つと見なされる
  - クライアントは通常、事前に取り決められたまたは設定されたトラストアンカーから伝達される信頼の連鎖に基づいて
    その証明書を信頼できるものと判断する
- HTTP/1.1以前では、クライアントは当該URIオリジンのホストに対して特定的に確立され、
  かつセキュアに保護された接続上で通信している場合にのみ、サーバに権威を帰属させる
  - 接続の確立および証明書検証は、権威の証拠として用いられる。
- HTTP/2およびHTTP/3 では、クライアントは正常に確立されセキュアに保護された接続上で通信しており、
  かつURIオリジンのホストがサーバ証明書に含まれるいずれかのホストと一致し、
  さらにそのURIに対して当該ホストへの接続を開けるとクライアントが信じられる場合に、サーバに権威を帰属させる
  - 実際にはクライアントはDNS問い合わせを行い、オリジンのホストが確立済み接続と同じサーバIPアドレスを
    指していることを確認する
    - この制約はオリジンサーバが同等性を示す`ORIGIN フレーム`を送信することで緩和できる
- リクエスト対象のホストおよびポートの値はHTTPリクエスト内で渡され、オリジンを識別するとともに、
  同一サーバが制御している可能性のある他の名前空間と区別する
  - 証明書の秘密鍵を制御できる任意のサービスが対応するhttps名前空間の管理について同等の責任を負うこと、
    または少なくとも誤って配送されたように見えるリクエストを拒否できることを保証するのはオリジンの責任
- オリジンサーバはたとえ権威を有していても、特定の対象URIに対するリクエスト処理を望まない場合がある
  - e.g. 同一ホストが異なるポートで別々のサービスを提供している場合、接続がセキュアに確立された後であっても
    オリジンサーバで対象URIを検査することが必要なため
    - さもなくばネットワーク攻撃者が、あるポート向けの接続を別のポートで受信させることにより、
      ある対象URIへのレスポンスを、別ポートからの一見権威的なレスポンスに置き換えることを許可するおそれがある
- httpsスキームは権威の関連付けにTCPや接続先ポート番号を用いない
  - これらはセキュアな通信の外側にあり、決定的なものとして信頼できないため
    - そのためHTTP通信はセキュアに保護された任意のチャネル上で行われ得る
- [MAY] https URIが示されたリソースへのアクセスを要請する文脈で用いられた場合、
  クライアントはホスト識別子をIPアドレスに解決し、指定ポートでTCP接続を確立し、
  TCP上でTLSを正常に開始して機密性および完全性の保護により接続をEnd-to-Endで保護し、
  その接続上でクライアントの対象URIに一致するリクエスト対象を含むHTTPリクエストメッセージを送信することで、
  アクセスを試みてもよい
  - そのようなリクエストに対して、サーバが (中間ではない) HTTP レスポンスを返した場合、
    そのレスポンスは、クライアントのリクエストに対する権威的な応答とみなされる
    - 上記は権威的な応答を得るための唯一の手段ではなく、常に権威的な応答が必要であるわけでもない

#### IP-ID Reference Identity
- https URIの`host`フィールドにIP アドレスのリテラルが用いられて識別されるサーバは、
  IP-ID (P Address Identity) 型の参照アイデンティティを持つ
  - IPv4 アドレスはIPv4addressのABNF規則を使用する
  - IPv6アドレスはIP-literal生成規則のうちIPv6addressの選択肢を使用する
- IP-ID型の参照アイデンティティは、IPアドレスをデコードしたバイト列を含む
- IPv4 アドレスは4 オクテット、IPv6アドレスは16オクテット
- IP-IDの使用はこれら以外のIP バージョンについては定義されていない
  - 証明書の subjectAltName 拡張におけるiPAddressの選択肢は、IPバージョンを明示的に含まないため、
    アドレス長によってバージョンを区別する
  - IP-ID型の参照アイデンティティは、そのアドレスが証明書のsubjectAltName拡張に含まれるiPAddressの値と
    完全に一致する場合に一致すると判定される

## Fields https://www.ietf.org/rfc/rfc9110.html#name-fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される

### Field Names

- フィールド名は、対応するフィールド値がその名前によって定義された意味論を持つことを示す

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- [ought to] フィールド名はHypertext Transfer Protocol (HTTP) Field Name Registryに登録されていることが望ましい
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
  - そのフィールドが存在しない場合における受信者の既定の振る舞いは変化し得る
  - [ought to] `Host`および`Connection`は、HTTP/1.1 への適合を明示的に主張していない場合であっても、
    すべてのHTTP実装が認識すべき
- 新しいフィールドは、認識しない受信者が安全に無視できるように意味論が定義されていれば
  プロトコルバージョンを変更することなく導入できる
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する
- [MUST] プロキシは、認識できないヘッダフィールドであってもそのフィールド名が`Connection`に列挙されていない、
  あるいは当該フィールドを遮断・変換するよう明示的に設定されていない限り、
  当該フィールドををオリジンに転送しなければならない
  - [SHOULD] その他の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視すべき
    - これらの要件に従うことで、配備済みの中継者を更新または撤去することなくHTTPの機能を拡張できる

### Field Lines and Combined Field Value
- フィールドは任意数のフィールド行から構成される
- フィールド行はフィールド名とフィールド行値から構成される
- 同名のフィールド名が複数の別の行で現れた場合、
  フィールド値は各行の値をその出現順にカンマ区切りで連結したリストとして解釈される

```
Example-Field: Foo, Bar
Example-Field: Baz
```

### Field Order
- [MAY] 受信者は、1つのフィールドセクション内に同一のフィールド名を持つ複数のフィールド行が存在する場合、
  それらを1つのフィールド行に結合してもよい
  - 最初のフィールド行値に続けて、後続の各フィールド行値を出現順に、`,`と任意の空白 (OWS) で区切って追加する
  - 整合性のため、カンマ + SP を用いることが推奨される
- [MUST NOT] プロキシはメッセージを転送する際、これらのフィールド行値の順序を変更してはならない
  - [MUST NOT] 送信者は同一名のフィールド行をヘッダ/トレーラを含むメッセージ内に複数生成してはならない
  - [MUST NOT] 同名のフィールド行がすでに存在する場合に新たなフィールド行を追加してはならない
  - 当該フィールドの定義が、複数のフィールド行値をカンマ区切りリストとして再結合できることを許している場合を除く
- [ought to] `Set-Cookie`ヘッダフィールドはは単一のフィールド値に結合できないため、
  受信者はフィールド処理において特別扱いすべき
  - `Set-Cookie`はレスポンスメッセージ内で複数のフィールド行として現れることが多く、
    リスト構文を用いないため、上記の「同一名フィールド行」に関する要件に反する
- 異なるフィールド名を持つフィールド行同士の順序は解釈上は重要ではないが、
  実装が可能な限り早期にメッセージを処理しない判断を下せるよう、
  追加の制御情報を含むヘッダを先に送信するのは良いプラクティス
- [MUST NOT] サーバは、リクエストヘッダセクション全体を受信し終えるまでそのリクエストを対象リソースに適用しない
  - 後続のヘッダ行に条件付きリクエスト、資格情報、そのほか処理に影響を与え得る意図的に誤解を招く重複ヘッダが
    含まれる可能性があるため

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
  - 実際には個々のフィールドの意味論に依存して、アドホックな長さ制限が設けられていることが多い
- [MUST] サーバは、大きすぎる大きなリクエストヘッダのフィールド行、フィールド値、フィールド集合を受信した場合、
  適切な4xxステータスコードで応答しなければならない
- [MAY] クライアントは、大きすぎるフィールド行を受信した場合、そのフィールドの意味論上、
  値を破棄または切り詰めてもメッセージのフレーミングやレスポンスの意味論が変化しないのであれば、
  それらのフィールド行を破棄または切り詰めてもよい

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値には先頭や末尾の空白文字は含まれない
  - [MUST] 特定のHTTPバージョンでそのような空白がメッセージ中に現れ得る場合、
    フィールド解析実装はフィールド値を評価する前にそれらの空白を除去しなければならない
- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
  - 歴史的にはHTTPはISO-8859-1文字集合 [ISO-8859-1] のテキストを含むフィールド内容を許可しており、
    他の文字集合は [RFC2047] のエンコーディングを通じてのみサポートされてきた
  - [SHOULD] 新たに定義されるフィールドの仕様は、その値を可視US-ASCIIオクテット (VCHAR) 、SP、HTABに制限すべき
  - [SHOULD] 受信者は、フィールド内容中のその他の許可オクテット (obs-text) を不透明なデータとして扱うべきである
- CR / LF / NULを含むフィールド値は無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
  - [MUST] CR / LF / NUL文字をフィールド値内に受信した受信者はメッセージを拒否するか、
    各文字をSPに置き換えた上で処理または転送を続行しなければならない
  - [MAY] 他のCTL文字を含むフィールド値も無効であるが、安全な文脈に限っては堅牢性のために保持してもよい
- Singleton fields ... フィールド値として単一の要素のみを想定するフィールド
- List-based fields ... フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
  - [ought to] HTTP-dateやURI-referenceのように要素内部にカンマを含み得るフィールドは、
    そのデータ内のカンマとリスト区切りのカンマを区別できるよう、区切り記号で囲む形で定義されるべき

```
Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される
  - [ought to]両形式を許可する場合、パラメータ値の意味は
    tokenとして受信された場合でもquoted-stringとして受信された場合でも同一であるべき

### Common Rules for Defining Field Values
#### Lists (#rule ABNF Extension)
- リストベースのフィールド値定義の可読性を高めるために [RFC5234] のABNF 規則に対する`#rule`拡張が用いられる

```
<n>#<m>element

最小 <n> 個、最大 <m> 個のelementからなるリスト
各要素は単一のカンマと任意の空白 (OWS) で区切る
```

- 送信者の要件:
  - [MUST NOT] リスト構文を使用するすべての生成規則において、送信者は空のリスト要素を生成してはならない
  - 送信者は次の構文を満たすリストのみを生成しなければならない:
    - `1#element => element *( OWS "," OWS element )`
    - `#element => [ 1#element ]`
    - n ≥ 1 かつ m > 1 の場合:
      - `<n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )`
- 受信者の要件:
  - 空の要素は要素数のカウントに含めない
  - [MUST] 受信者は、合理的な数の空要素を解析して無視しなければならない。空の要素は要素数のカウントに含めない
    - 値の結合など送信者のよくある誤りに対処できる程度である一方、DoS攻撃に利用されない範囲に限定される必要がある
  - 受信者は次の構文を満たすリストを受け入れなければならない:
    - `#element => [ element ] *( OWS "," OWS [ element ] )`
  - すべてのケースは、個数指定がないものとして扱われる。

```
e.g.
example-list      = 1#example-list-elmt
example-list-elmt = token ; 5.6.2 節参照

このとき、

以下の値はexample-listとして有効:
"foo,bar"
"foo ,bar,"
"foo , ,bar,charlie"

以下の値はexample-listとして無効:
""
","
",   ,"
```

#### Tokens
- トークンは、空白や区切り文字を含まない短いテキスト識別子

```
token          = 1*tchar

tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
               / DIGIT / ALPHA
               ; 区切り文字を除く任意の VCHAR
```

- 多くのHTTP フィールド値は、共通の構文要素を空白、または特定の区切り文字で分離して定義されている
- 区切り文字は、トークンに含めることが許可されていないUS-ASCIIの可視文字から選ばれる
  - DQUOTE および `"(),/:;<=>?@[\]{}`

#### Whitespace
- OWS (optional whitespace)
  - 0個以上の線形空白オクテットが出現し得る場所で用いられる空白
  - [SHOULD] 可読性向上のために任意空白が望ましい場合、送信者は単一のSP として生成する
  - [SHOULD NOT] それ以外の場合、送信者は必要な場合を除き任意空白を生成すべきではない
- RWS (required whitespace)
  - フィールドトークンを分離するため、少なくとも1つの線形空白が必要な場合に用いられる空白
  - [SHOULD] 送信者はRWSを単一のSPとして生成する
  - OWSとRWSは、意味論的には単一のSPと同等
    - [MAY] OWSまたはRWSと定義されているコンテントは、解釈や転送の前に単一のSP に置き換えてよい
- BWS ("bad" whitespace)
  - 歴史的理由のみで文法が任意空白を許している箇所に用いられる空白
  - [MUST NOT] 送信者はBWSを生成してはならない
  - [MUST]受信者はBWSを解析して除去しなければならない
  - BWS には意味論はない。BWS と定義されている内容は、解釈や転送の前に 削除してよい（MAY）。

```
OWS =  *( SP / HTAB ) ; optional whitespace
RWS = 1*( SP / HTAB ) ; required whitespace
BWS = OWS             ; "bad" whitespace
```

#### Quoted Strings
- テキストの文字列は二重引用符`"`で囲まれている場合、単一の値として解析される

```
quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
```

- `"\"`は、quoted-stringおよびcomment構文内での1オクテットのエスケープ機構として使用できる
- [MUST] quoted-stringの値を処理する受信者はquoted-pairを、バックスラッシュの直後のオクテットに置き換えたものとして
  扱わなければならない

```
quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```

- [SHOULD NOT] 送信者は、引用符付き文字列内に存在するDQUOTEおよび`\`を引用符で囲む必要がある場合を除き、
  quoted-string内にquoted-pairを生成すべきではない
- [SHOULD NOT] 送信者は、コメント内に存在する括弧`()`および`\`を引用符で囲む必要がある場合を除き、
  comment内にquoted-pairを生成すべきではない

#### Comments
- 丸括弧で囲むことにより、いくつかのHTTPフィールド内にコメントを含めることができる
- コメントは、フィールド値定義に`comment`が含まれているフィールドにのみ許可される

```
comment        = "(" *( ctext / quoted-pair / comment ) ")"
ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

#### Parameters
- パラメータは`name/value`の組として表現される (e.g. `Media-Type`、`Accept`)
  - フィールド値に補助的な情報を付加するための共通構文としてよく用いられる
  - 各パラメータは通常、直前のセミコロン`;`によって区切られる

```
parameters      = *( OWS ";" OWS [ parameter ] )
parameter       = parameter-name "=" parameter-value
parameter-name  = token
parameter-value = ( token / quoted-string )
```

- パラメータ名は大文字・小文字を区別しない
- パラメータ値が大文字・小文字を区別するかどうかは、そのパラメータ名の意味論に依存する
- token構文に合致するparameter値は、tokenとして送信しても、quoted-string として送信しても等価
- parameterでは、`=`の前後にいかなる空白も許可されない

#### Date/Time Formats
- 歴史的経緯により日付/時刻フォーマットは3形式が定義されている
- 推奨フォーマットは、Internet Message Format [RFC5322] で用いられる日付・時刻仕様のうち、
  固定長かつ単一タイムゾーンに限定したサブセット

```
HTTP-date = IMF-fixdate / obs-date

推奨形式:
Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

廃止形式:
Sunday, 06-Nov-94 08:49:37 GMT   ; 廃止されたRFC 850形式
Sun Nov  6 08:49:37 1994         ; ANSI Cのasctime() 形式
```

```
推奨形式:
IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT

day-name     = %s"Mon" / %s"Tue" / %s"Wed"
             / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

date1        = day SP month SP year
             ; 例: 02 Jun 1982

day          = 2DIGIT
month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
             / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
             / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
year         = 4DIGIT

GMT          = %s"GMT"

time-of-day  = hour ":" minute ":" second
             ; 00:00:00 - 23:59:60（うるう秒を含む）

hour         = 2DIGIT
minute       = 2DIGIT
second       = 2DIGIT
```

```
廃止形式:

obs-date      = rfc850-date / asctime-date

rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
date2        = day "-" month "-" 2DIGIT
             ; 例: 02-Jun-82

day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
             / %s"Thursday" / %s"Friday" / %s"Saturday"
             / %s"Sunday"

asctime-date = day-name SP date3 SP time-of-day SP year
date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
             ; 例: Jun␠␠2
```

- [MUST] HTTPフィールド内のタイムスタンプ値を解析する受信者は、これら3種類すべてのHTTP-date形式を受け入れる
- [MUST] 送信者がHTTP-dateとして定義されたタイムスタンプを含むフィールドを生成する場合、
  必ずIMF-fixdate形式で生成しなければならない
- HTTP-dateの値はUTC時刻を表す
  - クロックは、UTCにおける現在時刻を妥当に近似して提供できる実装のこと
  - クロック実装はNTP [RFC5905] やそれに類するプロトコルを用いてUTCと同期することが望ましい
- HTTP-dateは大文字・小文字を区別する
  - [CACHING] 4.2 にて、キャッシュ受信者に対してこの制約が緩和されている
- [MUST NOT] 送信者は、文法でSPとして明示的に含まれているもの以外の追加の空白を HTTP-date 内に生成してはならない
- day-name、day、month、year、time-of-dayの意味論は、Internet Message Formatの構成要素 [RFC5322] 3.3 と同一
- [MUST] RFC 850形式のように2桁の年を用いるタイムスタンプを受信した場合、
  現在より50年以上未来を指しているように見える値は、過去で最も近い同じ下2桁の年として解釈しなければならない
- フィールド定義で特に制限されていない限り、受信者はタイムスタンプ解析において堅牢であることが推奨される
  - HTTP以外の情報源から転送されたメッセージが、Internet Message Formatで定義された
    いずれかの日付・時刻仕様を生成することがあるため

## Message Abstraction (HTTPメッセージの抽象型) https://www.ietf.org/rfc/rfc9110.html#name-message-abstraction
- HTTPの各メジャーバージョンは、それぞれ独自の構文を用いてメッセージを通信する
  - Message Abstractionはメッセージの特性・共通構造・意味を伝達する能力を一般化したHTTPメッセージの抽象型を定義する
    - この抽象化はHTTPのバージョンに依存しない形で送信者および受信者の要件を定義するために用いられ、
      あるバージョンのメッセージを別のバージョンを介して中継しても、その意味が変わらないことを目的とする
- メッセージの構成要素
  - Control data (制御データ) メッセージを記述し、経路制御するために必要な情報
    - 受信者が即座に知る必要のある事項
  - Headers lookup table (ヘッダ表) 制御データを拡張し、送信者・メッセージ・内容の追加情報を伝える名前:値の組の集合
    - 受信者がコンテンツ受信前に知る必要のある事項
  - Content (コンテンツストリーム) 任意・潜在的にサイズ無制限のストリーム
    - メッセージのセマンティクスを満たすために受信者が必要とする本体
  - Trailers lookup table (トレーラ表) コンテン送信中に得られた情報を伝えるための名前:値の組の集合
    - コンテンツ送信前には不明であった任意のメタデータ
- メッセージの送信順
  - フレーミングおよび制御データ
  - ヘッダテーブルのフィールドを含むヘッダセクション
  - (任意) コンテンツ
  - (任意) トレーラーテーブルのフィールドを含むトレーラーセクション
- メッセージはストリームとして前方から処理されることが想定されている
  - そのストリームの目的や処理の継続性は、読み進める過程で明らかになる
- メッセージは自己記述的であることが意図されている
  - 受信者がメッセージについて知る必要がある情報はすべて、
    送信中に圧縮または省略された部分をデコードまたは再構成した後、メッセージ自体を参照することで判断できる
    - 送信者の現在のアプリケーション状態 = 過去のメッセージによって確立され他状態を理解する必要はない
    - クライアントは対応するレスポンスを解析、解釈、キャッシュする際、リクエストに関する知識を保持する必要がある
      - e.g. HEADメソッドとGETのそれぞれのレスポンスは先頭部分の見た目は同じがだが同じように解析することはできない

### Framing and Completeness
- メッセージフレーミングは、各メッセージの開始と終了を示す
  - 各メッセージを同じ接続上の他のメッセージやノイズと区別するための仕組み
  - HTTPはメジャーバージョンごとに独自のフレーミングメカニズムを定義する
- HTTP/0.9 および初期のHTTP/1.0では接続のクローズを以てレスポンスの終了としていた (暗黙的なフレーミング)
  - HTTP/1.1でも後方互換性のため許可されている
  - 接続が早期に閉じられた場合、不完全なレスポンスを区別できない可能性がある
    - ほとんどの最新の実装では、メッセージデータを長さで区切る形式で明示的なフレーミングを行う
      - HTTP/1.1の`Content-Length`、`Transfer-Encoding: chunked`
      - HTTP/2およびHTTP/3のフレーム境界
- メッセージは、そのフレーミングで示されるすべてのオクテットが利用可能な時点で完了したとみなされる
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- メッセージは、その主な目的を示す制御データで始まる
  - リクエストメッセージの制御データには以下が含まれる:
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データには以下が含まれる:
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前では、制御データはメッセージの1行目として送信される
- HTTP/2およびHTTP/3では、制御データは予約名プレフィックス付きの擬似ヘッダーフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージにはプロトコルバージョンがある
  - 使用されているバージョンに応じて、メッセージ内で明示的に識別される場合もあれば、
    メッセージが受信された接続から推測される場合もある
  - 受信者はバージョン情報を使用し、送信者との以降の通信における制限事項や可能性を判断する
- メッセージが中継者によって転送された場合、プロトコルバージョンはその中継者が使用するバージョンへ更新される
  - `Via`ヘッダーフィールド は、転送されたメッセージ内で上流プロトコル情報を伝達するために使用される
- [SHOULD] クライアントは自身が準拠している中で最も高いバージョン、
  かつサーバが対応していると分かっている最も高いバージョンをリクエストバージョンとして送信するべき
  - [MUST NOT] クライアントは、自身が準拠していないバージョンを送信してはいけない
- [MAY] サーバがHTTP仕様を誤って実装していることが分かっている場合、
  クライアントはより低いリクエストバージョンを送信してもよいが、
  これはクライアントが少なくとも1つの通常のリクエストを試行し、
  レスポンスのステータスコードやヘッダフィールドの情報から
  サーバがより高いリクエストバージョンを適切に処理していないことを確認した後に限る
- [SHOULD] サーバは、サーバ自身が準拠している最高バージョンに等しいレスポンスバージョンを送信すべき
  - ただし、リクエストで受信したバージョン以下であること
  - [MUST NOT] サーバは、自身が準拠していないバージョンを送信してはいけない
  - サーバは、何らかの理由でクライアントのメジャープロトコルバージョンのサービスを拒否したい場合、
    505 HTTP Version Not Supported レスポンスを送信してもよい
- [SHOULD] 受信者は、自身が実装しているメジャーバージョン番号およびそれよりも高いマイナーバージョン番号を持つ
  メッセージを受信した場合そのメッセージを、受信者が準拠しているメジャーバージョン内で
  最も高いマイナーバージョンであるかのように処理する必要がある
  - 受信者は、より高いマイナーバージョンのメッセージが
    まだそのバージョンへの対応を示していない受信者に送信されたとしても、
    同一メジャーバージョン内であれば後方互換性が十分に保たれており、安全に処理できると仮定してよい

### Header Fields
- ヘッダフィールドは、コンテンツの前に送受信されるフィールド
- メッセージのヘッダセクションは、一連のヘッダーフィールド行 (フィールド名 + フィールド値) で構成される
  - 各ヘッダーフィールドは、メッセージのセマンティクスを変更または拡張したり、送信者を記述したり、
    コンテンツを定義したり、追加のコンテキストを提供したりする場合がある

### Content
- HTTPメッセージは多くの場合、メッセージのコンテンツとして、表現の全体または一部を転送する
  - コンテンツはメッセージフレーミングによって定義され、ヘッダセクションの後に送信される
    オクテットのストリームとして送信される
- コンテンツの抽象的定義は、メッセージフレーミングから取り出された後のデータを指す
  - e.g. HTTP/1.1メッセージボディは、チャンク転送コーディングでエンコードされたデータストリーム
    (一連のデータチャンク、長さゼロのチャンク1つ、およびトレーラーセクション) で構成される場合がある。
    しかしそのメッセージのコンテンツに含まれるのは転送符号化をデコードした後のデータストリームのみであり、
    チャンク長、チャンク化のフレーミング構文、トレーラフィールドは含まれない

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

- リクエストにおけるコンテンツの目的は、リクエストメソッドの意味論によって定義される
  - e.g. PUTリクエストのコンテンツにおける表現 ... リクエストが正常に適用された後の対象リソースの望ましい状態
    POSTリクエストのコンテンツにおける表現 ... 対象リソースによって処理される情報を表
- レスポンスにおけるコンテンツの目的は、リクエストメソッド、ステータスコード、
  コンテンツを記述するレスポンスフィールドによって定義される
  - e.g. GETに対する200 OK レスポンスのコンテンツ ... メッセージ送信日における対象リソースの現在の状態
    POSTレスポンスにおける同じステータスコードのコンテンツ ... 処理結果または処理適用後の対象リソースの新しい状態
  - GETに対する206 Partial Content レスポンスのコンテンツは、選択された表現の単一部分、
    または複数の部分を含むmultipartメッセージボディのいずれか
  - エラーステータスコードを持つレスポンスメッセージには通常、
    エラー状態を表す内容 (エラー状態と、それを解決するための推奨手順) が含まれる
  - HEADリクエストへのレスポンスにはコンテンツは含まれない
    - 関連するレスポンスヘッダフィールドは、リクエストメソッドがGETであった場合の値のみを示す
  - CONNECTリクエストへの2xx Successful レスポンスはコンテンツを含める代わりに接続をトンネルモードに切り替える
  - 1xx Informational、204 No Content、304 Not Modified レスポンスにはコンテンツは含まれない
  - その他のレスポンスにはコンテンツが含まれるが、サイズは0になる場合がある

#### Identifying Content
- 完全または部分的な表現がコンテンツとして転送される場合、
  送信者がその特定の表現に対応するリソースの識別子を提供するか、受信者がそれを判別できると望ましい場合が多い
- リクエストメッセージの場合:
  - リクエストに`Content-Location`ヘッダフィールドがある場合:
    - 送信者はそのコンテンツが`Content-Location`フィールド値で識別されるリソースの表現であると主張している。
      ただしこのような主張は、他の手段によって検証されない限り信頼できない。
  - それ以外の場合:
    - コンテンツはHTTPによって識別されないが、より具体的な識別子がコンテンツ自身の中で提供されている可能性がある
- レスポンスメッセージの場合:
  - 一致するものが見つかるまで以下のルールが順に適用される:
    - リクエストメソッドがHEAD、またはレスポンスステータスコードが204 No Content か304 Not Modifiedの場合:
      - レスポンスはコンテンツを含まない
    - リクエストメソッドがGET、かつレスポンスステータスコードが200 OK の場合:
      - レスポンスは対象リソースの表現をコンテンツとして含む
    - リクエストメソッドがGET、かつレスポンスステータスコードが203 Non-Authoritative Information の場合:
      - レスポンスは中継者によって提供された対象リソースの潜在的に変更または拡張された表現をコンテンツとして含む
    - リクエストメソッドがGET、かつレスポンスステータスコードが206 Partial Contentの場合:
      - レスポンスは対象リソースの表現の一部をコンテンツとして含む
    - レスポンスに`Content-Location`ヘッダフィールドがあり、そのフィールド値が対象URIと同じURIへの参照である場合:
      - レスポンスは対象リソースの表現をコンテンツとして含む
    - レスポンスに`Content-Location`ヘッダフィールドがあり、その値が対象URIとは異なるURIへの参照である場合:
      - 送信者はコンテンツが`Content-Location`フィールド値で識別されるリソースの表現であると主張する。
        ただしこのような主張は、他の手段によって検証されない限り信頼できない。
    - それ以外の場合:
      - コンテンツはHTTPによって識別されないが、より具体的な識別子がコンテンツ自身の中で提供されている可能性がある

### Trailer Fields
- トレーラセクション内に配置されたフィールドは、
- トレーラフィールドは、トレーラセクション内に配置されたフィールドのこと
  - トレーラーフィールドは、メッセージの整合性チェック、デジタル署名、配信メトリクス、
    後処理ステータス情報の提供などを行う
- [ought to] トレーラフィールドは、ヘッダセクション内のフィールドとは別に処理および保存するべき
  - ヘッダセクションが完成した時点で既に分かっているメッセージの意味論との矛盾を避けるため
- 特定のヘッダフィールドの有無は、トレーラを受信する前に行われたメッセージ全体のルーティングや処理の選択に
  影響を与える可能性があり、これらの選択は、後からトレーラフィールドが発見されたとしても取り消すことはできない

#### Limitations on Use of Trailers
- トレーラセクションは、使用しているHTTPのバージョンによってサポートされており、
  明示的なフレーミングメカニズムによって有効化されている場合にのみ使用できる
  - e.g. HTTP/1.1のチャンク転送コーディングでは、コンテンツの後にトレーラーセクションを送信できる
- 多くのフィールドはコンテンツの受信前に評価する必要があるため、ヘッダセクションの外で処理することができない
  - メッセージのフレーミング
  - ルーティング
  - 認証
  - リクエスト修飾子
  - レスポンス制御
  - コンテンツ形式を記述するフィールド など
  - コンテンツを受信する前に評価する必要があるため、ヘッダセクションの外で処理することはできません。
  - [MUST NOT] 送信者は対応するヘッダフィールド名の定義によって、そのフィールドがトレーラとして送信されることを
    許可していると分かっている場合を除いて、トレーラーフィールドを生成してはならない
- トレーラフィールドは、あるプロトコルバージョンから別のプロトコルバージョンにメッセージを転送する中継者にとって
  処理が困難な場合がある
  - メッセージ全体を転送中にバッファリングできる場合、中継者によっては、
    転送前にトレーラフィールドをヘッダセクションにマージできる可能性がある
    - ほとんどの場合、トレーラーは単に破棄される
    - [MUST NOT] 受信者が対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラフィールドの値を
      安全にマージする方法を明示的に許可および定義している場合を除き、
      トレーラフィールドをヘッダセクションにマージしてはならない
- `TE`リクエストヘッダフィールドにキーワード`trailers`が含まれる場合、
  クライアントは自身および下流のクライアントのためにトレーラフィールドを受け入れる意思があることを示す
  - 中継者からのリクエストの場合、すべての下流クライアントが転送されたレスポンス内のトレーラフィールドを
    受け入れる意思があることを意味する
  - `trailers`はクライアントがレスポンス内の特定のトレーラフィールドを処理することを意味するわけではなく、
    トレーラセクションがどのクライアントによっても破棄されないことを意味する
- [SHOULD NOT] トレーラフィールドは転送中に破棄される可能性があるため、
  サーバーはユーザエージェントが受信する必要があると思われるトレーラーフィールドを生成すべきではない

#### Processing Trailer Fields
- `Trailer`レスポンスヘッダフィールドは、トレーラセクションで送信される可能性のあるフィールド名を事前に示す
  - これにより、受信者はコンテンツを処理する前に受信の準備をすることができる
  - e.g. フィールド名がコンテンツの受信時に動的なチェックサムを計算し、トレーラフィールド値を受信したら
    すぐにチェックする必要があることを示している場合などに有用
- ヘッダフィールドと同様、同じ名前のトレーラフィールドは受信順に処理され、
  同じ名前のトレーラフィールド行が複数ある場合は複数の値をメンバーのリストとして追加するのと同等の意味を持つ
  - [MUST] メッセージ中に複数回生成される可能性のあるトレーラフィールドは、
    たとえ各メンバ値が受信フィールド行ごとに一回しか処理されなかったとしても、
    リスト型のフィールドとして定義されなければならない
- [MAY] メッセージの末尾で、受信者は受信したトレーラフィールドの集合を、
  ヘッダフィールドと同じような (ヘッダーフィールドとは別の) 名前:値の組のデータ構造として扱ってもよい
  - トレーラでの利用を意図したフィールドに関する追加の処理要件がある場合は、そのフィールド仕様の中で定義できる

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- `Date`ヘッダフィールドは、メッセージが生成された日時を表す
  - [RFC5322] 3.6.1 で定義されている`orig-date`と同じ意味
  - フィールド値はHTTP-date形式
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Date

```
Date = HTTP-date
```

```
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

- [SHOULD] `Date`ヘッダフィールドを生成する送信者は、フィールド値をメッセージ生成日時の可能な限り近似値にするべき
  - 理論上、日付はメッセージコンテンツを生成する直前の時点を表す必要がある
  - 実際には、送信者はメッセージ生成中の任意の時点で日付値を生成できる
- [MUST] クロックを持つオリジンサーバは、すべての2xx、3xx、4xxレスポンスに`Date`を生成しなければならない
  - [MAY] 1xx、5xxレスポンスにも`Date`を生成してもよい
- [MUST NOT] クロックを持たないオリジンサーバーは、`Date`を生成してはならない
- [MUST] クロックを持つ受信者が、`Date`のないレスポンスメッセージを受信した場合、
  その受信時刻を記録し、そのメッセージがキャッシュまたは下流に転送される場合は、
  対応する`Date`をメッセージのヘッダセクションに追加しなければならない
- [MAY] クロックを持つ受信者が、無効な`Date`ヘッダフィールド値を持つレスポンスを受信した場合、
  その値をレスポンスの受信時刻に置き換えてもよい
- [MAY] ユーザエージェントはリクエストにDateヘッダーフィールドを含めてもよい
  - が、サーバーにとって有用な情報を伝えると考えられる場合を除いて、通常は送信しない
  - e.g. HTTPのカスタムアプリケーションでは、ユーザエージェントとサーバーのクロックの違いに基づき
    サーバーがユーザの要求の解釈を調整することが予想される場合、`Date`を送信することがある

#### Trailer
- `Trailer`ヘッダフィールドは、送信者がメッセージ内でトレーラフィールドとして送信することを想定している
  フィールド名のリストを提供する
  - 受信者はこれにより、コンテンツの処理を開始する前に指定されたメタデータの受信に備えることができます
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Trailer

```
Trailer = #field-name
```

- e.g. 送信者がコンテンツをストリーミングしながら署名を計算し、最終的な署名値をトレーラフィールドとして送信する場合
  `Trailer`ヘッダによって署名フィールドの存在を事前に示しておけば、受信者はコンテンツを受信しつつ、
  同時に検証処理を行うことができる
- [SHOULD] メッセージ内に1つ以上のトレーラフィールドを生成する送信者は、
  そのメッセージのヘッダセクションに`Trailer`ヘッダフィールドを生成することによって
  トレーラに含まれる可能性のあるフィールドを示すべき
- 中継者が転送中にトレーラセクションを破棄した場合、
  `Trailer`フィールドは失われたメタデータのヒントとなる可能性がある
  - ただし`Trailer`の送信者が常に指定されたフィールドを送信するという保証はない

## Routing HTTP Messages https://www.ietf.org/rfc/rfc9110.html#name-routing-http-messages
- HTTPリクエストメッセージのルーティングは、対象リソース、クライアントのプロキシ設定、
  受信接続の確立または再利用に基づいて各クライアントが決定する
- 対応するレスポンスのルーティングは同じ接続経路を逆方向にたどってサーバからクライアントへ返送される

### Determining the Target Resource
- HTTPにおいてほとんどのクライアントは汎用Webブラウザと同じリソース識別メカニズムと設定手法を利用している
  - 通信オプションがクライアントの設定にハードコードされていても、それらを総合した結果をURI参照と考えることができる
  - URI参照は絶対形式に解決されると、ターゲットURI (Target URI) となる
  - ターゲットURIは、参照のフラグメント要素を除外する
    - フラグメント識別子がクライアント側処理用に予約されているため ([URI] 3.5)
- ターゲットリソース (Target Resource: クライアントが操作したいリソースそのもの) に対して操作を実行するため、
  クライアントは、受信側がそのリソースを識別できる解析済みターゲットURI (リクエストターゲット) の構成要素を含む
  リクエストメッセージを送信する
  - 歴史的な理由からリクエストターゲットは、メッセージ制御データと`Host`ヘッダフィールドに含めて送信される
    - 例外1) CONNECTの場合、リクエストターゲットはトンネル接続先の`ホスト名:ポート番号`
    - 例外2) OPTIONSの場合、リクエストターゲットは`*`にすることができる
    - [MUST NOT] これらの形式は他のメソッドと組み合わせて使用してはならない
- サーバはクライアントからのリクエストを受信すると、ローカル設定と受信接続の文脈に基づき、
  受信した構成要素からターゲットURIを再構築する
  - 再構築の方法は主要なプロトコルバージョンごとに異なる

### Host and :authority
- リクエストにおける`Host`ヘッダフィールドは、対象URIに含まれるホスト名およびポート情報を提供し、
  オリジンサーバが複数のホスト名に対するリクエストを処理する際に対象のリソースを識別できるようにする
  - HTTP/2 or 3では場合によってリクエスト制御データに含まれる`:authority`擬似ヘッダフィールドが`Host`の役割を担う
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Host
    - リクエストの送信先のサーバのホスト名とポート番号を指定する
- クライアントはリクエストに`Host`ヘッダフィールドもしくは`:authority`擬似ヘッダーフィールドを必ず含める

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

- リクエストにおける`Host`ヘッダフィールドは、ターゲットURIのホストとポート番号の情報を提供する
  - これにより、オリジンサーバは複数のホスト名へのリクエストを処理する際にリソースを区別することができる
  - HTTP/2 [HTTP/2] および HTTP/3 [HTTP/3] では、
    リクエストの制御データに含まれる`:authority`疑似ヘッダフィールドが`Host`ヘッダフィールドを置き換える場合がある

```
Host = uri-host [ ":" port ] ; Section 4
```

- [MUST] ターゲットURIのauthorityの情報はリクエストの処理において非常に重要であるため、
  ユーザエージェントはリクエスト内で`Host`ヘッダフィールドを生成しなければならない
    - ターゲットURIの権限情報を`:authority`疑似ヘッダーフィールドとして送信する場合を除く
  - [SHOULD] `Host`を送信するユーザエージェントは、リクエストのヘッダセクションの最初のフィールドとして
    `Host`を送信すべき

```
(e.g. オリジンサーバの http://www.example.org/pub/WWW/ へのGETリクエストの場合)
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

- ホスト名とポート番号の情報はアプリケーションレベルのルーティングメカニズムとして機能するため、
  共有キャッシュを改ざんしたり、リクエストを意図しないサーバーにリダイレクトしようとするマルウェアの標的となりがち
  - 透過プロキシは、接続先IPアドレスがそのホスト名に対して正当なものであるかを検証しないまま、
    ホスト名・ポート情報を内部サーバへの振り分けや共有キャッシュのキーとして使用すると、特に脆弱になりやすい

### Routing Inbound Requests
- ターゲットURIとそのオリジンが決定されると、クライアントは目的の意味論を実現するため
  ネットワークリクエストが必要かどうか、必要であればリクエストをどこに送信すべきかを決定する

#### To a Cache
- クライアントがキャッシュ [CACHING] を持ち、そのリクエストがキャッシュによって満たされる場合、
  リクエストはまずキャッシュへ送信される

#### To a Proxy
- リクエストがキャッシュによって満たされない場合、典型的なクライアントは自身の設定を確認し、
  リクエストを満たすためにプロキシを使用するかどうかを判断する
  - プロキシの設定は実装に依存するが、多くの場合はURIプレフィックスの一致、authorityの選択的な一致、
    あるいはその両方に基づいて決定される
  - プロキシ自体は通常httpまたはhttps URIで識別される
- httpまたはhttpsプロキシが適用可能な場合、クライアントは当該プロキシへの接続を確立または再利用し、
  ターゲットURIに一致するリクエストターゲットを含むHTTPリクエストメッセージをプロキシ宛に送信する

#### To the Origin
- 適用可能なプロキシがない場合、典型的なクライアントはターゲットURIのスキームに固有のハンドラルーチンを呼び出し、
  特定されたリソースへのアクセスを行う
  - リクエストターゲットがhttpリソースの場合、識別されたオリジンサーバへの接続を確立または再利用し、
    ターゲットURIに一致するリクエストターゲットを含むHTTPリクエストを送信する
  - リクエストターゲットがhttpsリソースの場合、
    識別されたオリジンに対して権威を持つオリジンサーバとのセキュアな接続を確立または再利用し、
    その上でターゲットURIに一致するリクエストターゲットを含むHTTPリクエストを送信する

### Rejecting Misdirected Requests (誤った宛先へのリクエストの拒否)
- サーバはリクエストを受信し、そのターゲットURIを特定できた後、そのリクエストへの対応を決定する
  - リクエストを自身で処理する
  - リクエストを別のサーバに転送するか
  - クライアントを別のリソースにリダイレクトする
  - エラーで応答する
  - 接続を切断する
- この決定は、リクエストまたは接続コンテキストに関するあらゆる情報に左右される
  - 特にサーバがそのターゲットURIへのリクエストを処理するように設定されているかどうか、
    および接続コンテキストがそのリクエストに適切かどうかに左右される
  - リクエストが意図的または偶発的に誤った宛先に送られ、`Host`の情報が接続のホストやポートと異なる可能性がある
    - 接続が信頼できるゲートウェイからのものであれば、このような不一致も想定内としてありえるが、
      そうでない場合はセキュリティフィルタをバイパスしようとしたり、サーバを騙して非公開コンテンツを配信させたり、
      キャッシュをポイズニングしようとしたりしている可能性がある
  - [MUST] 接続元が信頼されたゲートウェイでない限り、オリジンサーバは、
    ターゲットURIのスキーム固有の要件が満たされていない場合はリクエストを拒否しなければならない
    - [MUST] 特にhttpsリソースへのリクエストは、ターゲットURIのオリジンに対して有効な証明書によって
      保護された接続を介して受信されない限り、拒否しなければならない
- レスポンスのステータスコード421 Misdirected Request は、
  リクエストが誤って送信された可能性があり、オリジンサーバーがリクエストを拒否したことを示す

### Response Correlation (レスポンスの対応づけ)
- 1つの接続は複数のリクエスト - レスポンス交換に使用される場合がある
- リクエストとレスポンスの組みを対応付ける仕組みはHTTPのバージョンによって異なる
- すべてのレスポンスは、ステータスコードにかかわらずリクエストの受信後であればいつでも送信できる
  - リクエストがまだ完了していない場合であっても、レスポンスが先に完了することもある
  - クライアントはレスポンスを待つために特定の時間だけ待機することを期待されてはいない
    - クライアントは、合理的な時間内にレスポンスを受信できない場合、そのリクエストを放棄することがある
  - 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に中止を示す指示を受け取らない限り、
    当該リクエストの送信を継続すべき

- 1つのコネクションは、複数のリクエスト / レスポンス交換に使用される場合がある
- リクエストメッセージとレスポンスメッセージの組みを関連付けるメカニズムはバージョンに依存する
  - HTTPのバージョンによって、メッセージの順序付けを暗黙的に行うものもあれば、明示的な識別子を使用するものもある
- (中間レスポンスを含む) すべてのレスポンスはステータスコードに関わらず、
  リクエストがまだ完了していなくても、リクエスト受信後にいつでも送信できる
  - 対応するリクエストが完了する前にレスポンスが完了することもある
  - クライアントはレスポンスを待つために特定の時間待つ必要はない
  - 中継者を含むクライアントは、妥当な時間内にレスポンスを受信できない場合、リクエストを破棄することがある
- [SHOULD] 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に反対の指示を受けない限り、
  そのリクエストの送信を継続すべき

### Message Forwarding
- 中継者はHTTPリクエスト/レスポンスの処理において様々な役割を果たす
  - 性能・可用性向上 (キャッシュ、ロードバランシング)
  - アクセス制御 (認証・認可、フィルタリング、セキュリティゲートウェイ)
- HTTPストリームははpipe-and-filterアーキテクチャに類似した特性を持つため、
  中継者がストリームの双方向に対しても機能を拡張 (あるいは干渉) する場合において、本質的な制限は存在しない
- 中継者は、プロトコル要素 (新しいメソッド、ステータスコード、フィールド名など) を認識できない場合でも、
  メッセージを転送することが期待される (下流の受信者に対する拡張性を維持するため)
- [MUST] トンネルとして動作しない中継者は`Connection`ヘッダフィールドを実装し、
  受信側の接続のみを意図するフィールドを転送対象から除外しなければならない
- [MUST NOT] 中継者は、無限リクエストループから保護されていない限り、メッセージを自身に転送してはならない
- 一般的に中継者は、自身のサーバ名 (エイリアス、ローカルなバリエーション、リテラルIPアドレスを含む) を認識し、
  そのようなリクエストに直接応答する必要があります
- HTTPメッセージは、段階的に処理したり下流に転送したりするために、ストリームとして解析できる
  - 送信者および受信者は、部分的なメッセージが逐次的に配信されることを前提にしてはならない
  - 一部の実装では、ネットワーク効率、セキュリティチェック、またはコンテンツ変換のために、
    メッセージ転送をバッファリングまたは遅延させるため

#### Connection
- `Connection`ヘッダフィールドは、送信者が現在の接続に必要な制御オプションを列挙するためのもの
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Connection
    - `Connection`は、現在のトランザクションが完了したあとも、ネットワーク接続を開いたままにするかどうかを制御する
      - 送信された値が`keep-alive`の場合は接続が維持され、同一のサーバに送る後続のリクエストで再利用される
      -  `Connection`や`Keep-Alive`などの接続固有のヘッダフィールドは、HTTP/2では禁止

```
Connection        = #connection-option
connection-option = token
```

- `connection-option`は大文字・小文字を区別しない
- [MUST] `Connection`以外のフィールドを現在の接続に関する制御情報の提供に使用する場合、
  送信者は対応するフィールド名を`Connection`ヘッダフィールド内に列挙しなければならない
  - HTTPの一部のバージョンでは、このような情報のためのフィールドの使用が禁止されており、
    `Connection`フィールドは許可されない
  - 注意: HTTPの一部のバージョンでは、この種の情報のためにフィールドを使用すること自体が禁止されており、
    `Connection`フィールドも許可されていない
- [MUST] 中継者は、メッセージを転送する前に受信した`Connection`ヘッダフィールドを解析し、
  このフィールド内の各`connection-option`について、
  その`connection-option`と同じ名前のヘッダフィールドまたはトレーラフィールドをメッセージから削除し、
  その後`Connection`ヘッダフィールド自体を削除 (または転送メッセージに対する中継者独自の制御オプションで置き換え)
  なければならない
  - このために、`Connection`は直近の受信者のみに意図されたフィールド (hop-by-hop) と、
    チェーン上のすべての受信者に意図されたフィールド (end-to-end) とを宣言的に区別する手段を提供する
    - これによりメッセージは自己記述的となり、将来の接続固有の拡張であっても、
      古い仲介者によって無条件に転送されてしまうことを恐れずに導入できるようになる
- [SHOULD] 中継者は`connection-option`として指定されているかどうかにかかわらず、
  転送前に削除する必要があることがわかっているフィールドを、
  それらの意味論を適用した後に削除または置換すべき
  - `Proxy-Connection`
  - `Keep-Alive`
  - `TE`
  - `Transfer-Encoding`
  - `Upgrade` など
- [MUST NOT] 送信者は、コンテンツのすべての受信者を対象とするフィールドに対応する`connection option`を
  送信してはならない
  - e.g. `Cache-Control`を`connection-option`として用いることは適切ではない
- 接続オプションは、必ずしもメッセージ内に存在するフィールドに対応するとは限らない
  - 接続固有のフィールドは、接続オプションに関連付けられたパラメータがない場合、不要になる可能性があるため
  - 接続固有のフィールドを、それに対応する接続オプションなしで受信した場合、
    通常、そのフィールドは中継者によって不適切に転送されたことを示し、受信者はそれを無視すべき
- フィールドに対応しない新しい接続オプションを定義する場合、仕様作成者は後々の衝突を避けるため、
  対応するフィールド名を予約しておくべき
  - 予約されたフィールド名はHypertext Transfer Protocol (HTTP) Field Name Registryに登録される

#### Max-Forwards
- `Max-Forwards`ヘッダフィールドは、TRACEおよびOPTIONSリクエストメソッドにおいて
  プロキシによる転送回数の上限数を明示するもの
  - クライアントが、チェーンの途中で失敗またはループしているように見えるリクエストを追跡する場合に有用
  - https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Max-Forwards
    - TRACEおよびOPTIONSメソッドで使用され、リクエストが通過するノード (通常はプロキシ) の数を制限する
    - リクエストが通過する必要があるノードの最大数を示す整数であり、各ノードでこの値が減算されて、
      次のノードに転送される
      - 宛先に到達するか、受信した`Max-Forwards`の値が0になるまで続き、その後、
        リクエストは機密性の高いヘッダを除いて200 レスポンスのボディとして返される
         - これによりクライアントは、リクエストチェーンのもう一方の端で受信されている内容 (`Via`など) を
           テストや診断のために確認できる

```
Max-Forwards = 1*DIGIT
```

- `Max-Forwards`値は、このリクエストメッセージを転送できる残り回数を示す10進整数
- [MUST] `Max-Forwards`ヘッダフィールドを含むTRACE / OPTIONSリクエストを受信した中継者は、
  リクエストを転送する前に、`Max-Forwards`の値を必ず確認・更新する
  - [MUST] 受信した値 = 0: 中継者はリクエストを転送せずに最終受信者としてレスポンスを返す
  - [MUST] 受信した値 > 0: `Max-Forwards` = `[受信した値 - 1, 中継者がサポートするMax-Forwardsの最大値].min`
- [MAY] 受信者は、TRACE / OPTIONS 以外のリクエストメソッドで受信した`Max-Forwards`ヘッダフィールドを無視してもよい

#### Via
- `Via`ヘッダフィールドは、ユーザエージェント - サーバ間の中間プロトコルおよび中間受信者が存在することを示す
  - 電子メールの`Received`ヘッダーフィールド [RFC5322] 3.6.7 に似ている
  - `Via`は、メッセージの転送を追跡し、リクエストループを回避し、リクエスト/レスポンスチェーンにおける
    送信者のプロトコル能力を識別するために使用できる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Via
    - フォワード / リバース両プロキシによって追加され、リクエスト / レスポンス両ヘッダに表示される
      - メッセージ転送の追跡、要求ループの回避、要求/応答チェーンに沿った送信者のプロトコル機能の識別に使用される

```
Via = #( received-protocol RWS received-by [ RWS comment ] )

received-protocol = [ protocol-name "/" ] protocol-version
                  ; 7.8 節を参照
received-by       = pseudonym [ ":" port ]
pseudonym         = token
```

- `Via`フィールド値の各要素は、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中継者は自身がそのメッセージをどのように受信したかの情報を`Via`フィールド値の末尾に追加 するため、
    最終的な`Via`の並び順は、転送経路の順序を表す
- `Via`フィールド値の各メンバは、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中継者は、自身がそのメッセージをどのように受信したかの情報をフィールド値の末尾に追加する
    最終的な`Via`の並び順は、転送経路の順序を表す
- [MUST] プロキシは転送する各メッセージにおいて、以下に説明する適切な`Via`を送信しなければならない
- [MUST] HTTP-to-HTTPゲートウェイは、各受信リクエストメッセージにおいて適切な`Via`を送信しなければならない
- [MAY] 転送されたレスポンスメッセージにおいても`Via`を送信してよい
- 各中継者において、`received-protocol`は、メッセージの上流送信者が使用したプロトコルとプロトコルバージョンを示す
  - したがって`Via`フィールド値は、リクエスト／レスポンスチェーンにおいて通知されているプロトコル能力を記録し、
    それらが下流の受信者からも可視であり続けるようにする
    - これはレスポンスや後続のリクエストにおいて、後方互換性のないどの機能が安全に使用できるかを判断するのに有用
    - 受信プロトコルがHTTPの場合、`protocol-name`は省略される
- `received-by`は通常、その後メッセージを転送した受信側サーバまたはクライアントのホストとポート番号 (オプション)
  - [MAY] 実ホストが機密情報とみなされる場合、送信者はそれを仮名に置き換えてもよい
  - [MAY] ポートが指定されていない場合、受信者は、受信プロトコルのデフォルトポートで受信したと解釈してもよい
- [MAY] 送信者は、`User-Agent`ヘッダフィールドや`Server`ヘッダフィールドと同様、
  各受信者のソフトウェアを識別するためのコメントを生成してもよい
  - [MAY] `Via`ヘッダ内のコメントはオプションであり、受信者はメッセージを転送する前にコメントを削除してもよい

```
1. クライアント -> 内部プロキシfred (HTTP/1.0)
2. 内部プロキシfred -> パブリックプロキシp.example.net (HTTP/1.1)
3. パブリックプロキシp.example.net -> オリジンサーバwww.example.com

の場合

Via: 1.0 fred, 1.1 p.example.net
```

- [SHOULD NOT] ネットワークファイアウォールのポータルとして使用される中継サーバは、明示的に有効にされていない限り
  ファイアウォール領域内のホスト名とポート番号を転送すべきではない
  - [SHOULD] 有効にされていない場合、中継サーバはファイアウォールの背後にあるホストについて、
    `received-by`のホストを、そのホストの適切な仮名に置き換えるべき
- [MAY] 中継サーバは、`Via`ヘッダフィールドリストの各エントリの`received-protocol`値が同一である場合、
  順序付けられた一連のメンバを単一のメンバに結合してもよい

```
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

-> Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

- [SHOULD NOT] 送信者は、リストのメンバすべてが同じ組織の管理下にあり、
  かつホストが既に仮名に置き換えられている場合を除き、複数のメンバを結合すべきではない
- [MUST NOT] 送信者は、異なる`received-protocol`の値を持つメンバを結合してはならない

### Message Transformations (メッセージ変換)
- 一部の中継者には、メッセージとそのコンテンツを変換する機能が備わっている
  - e.g. プロキシはキャッシュ容量を節約したり、低速なリンクのトラフィック量を削減したりするために、
    画像形式を変換することがある。
    しかし、受信コンテンツが元のコンテンツと同一であることを保証するために整合性チェックやデジタル署名が
    使用されているようなコンテンツにおいてこのような変換を行うと、運用上の問題が発生する可能性がある。
- HTTP-to-HTTPプロキシのうち、
  意味論的に重要な形でメッセージを変更するように設計または設定されているもの
  (通常のHTTP処理に必要な変更を超えて、元の送信者にとって重要、または下流の受信者にとって潜在的に重要な方法で
   メッセージを変更するもの)は変換プロキシ (transforming proxy) と呼ばれる
  - 共有アノテーションサーバ
  - マルウェアフィルタ
  - フォーマット変換
  - プライバシーフィルタ など
  - このような変換は、プロキシを選択したクライアントが希望するものとみなされる
- [MAY] プロキシが、完全修飾ドメイン名ではないホスト名を持つターゲットURIを受信した場合、リクエストを転送する際に、
  受信したホスト名に自身のドメイン名を追加してもよいものとする
  - [MUST NOT] ターゲットURIに完全修飾ドメイン名が含まれている場合、プロキシはホスト名を変更してはいけない
- [MUST NOT] プロキシは、転送プロトコルで要求されている場合やその転送プロトコルで要求されている場合を除き、
  受信したターゲットURIを次の受信サーバに転送する際に、
  受信したターゲットURIの「絶対パス」および「クエリ」部分を変更してはいけない
  - e.g. HTTP/1.1経由でオリジンサーバにリクエストを転送するプロキシは、リクエストメソッドに応じて、
    空のパスを`/` ([HTTP/1.1] 3.2.1) または`*` ([HTTP/1.1] 3.2.4) に置き換える
- [MUST NOT] プロキシは、`no-transform`キャッシュ指示子 [CACHING] 5.2.2.6 を含む
  レスポンスメッセージのコンテンツを変換してはならない
  - 転送コーディングの追加または削除 [HTTP/1.1] 7 など、内容を変更しないメッセージ変換の場合は除く
- [MAY] プロキシは、`no-transform`キャッシュ指示子を含まないメッセージのコンテンツを変換してもよい
  - 200 OK レスポンスの内容を変換するプロキシは、レスポンスステータスコードを203 Non-Authoritative Information に
    変更することで、下流の受信者に変換が適用されたことを通知することができる
- [SHOULD NOT] プロキシは、通信チェーンのエンドポイント、リソースの状態、選択された表現 (コンテンツ以外) に関する
  情報を提供するヘッダフィールドを変更すべきではない
  - 当該フィールドの定義によって明示的にそのような変更が許可されている、
    あるいはプライバシーやセキュリティのために変更が必要であると判断される場合を除く

### Upgrade
- `Upgrade`ヘッダフィールドは、同一接続において HTTP/1.1から他のプロトコルへ移行するための
  シンプルなメカニズムを提供することを目的とする
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Upgrade
    - すでに確立されたクライアント-サーバ間のプロトコルを、同じ転送プロトコルを通じて、異なるプロトコルへ
      アップグレードするために使用される
      - e.g. HTTP/1.1 -> HTTP/2、HTTPやHTTPS -> WebSocket


- [MAY] クライアントは、リクエストの`Upgrade`ヘッダフィールドにプロトコル名のリストを送信することで、
  サーバが最終レスポンスを送信する前に、指定されたプロトコルのうち1つ以上のプロトコル (優先順位の高い順) へ
  切り替えるように促す
  - [MAY] サーバは、その接続で現在のプロトコルを引き続き使用する場合、受信した`Upgrade`を無視してよい
    - `Upgrade`は、プロトコルの変更を強制するために使用することはできない

```
Upgrade = #protocol

protocol = protocol-name ["/" protocol-version]
protocol-name = token
protocol-version = token
```

- [SHOULD] プロトコル名は大文字と小文字を区別せずに登録されるが、
  受信者は各`protocol-name`とサポートされているプロトコルを照合する際、大文字と小文字を区別しない比較を行うべき
- [MUST] 101 Switching Protocols レスポンスを送信するサーバは、接続を切り替えられる新しいプロトコルを示すため、
  `Upgrade`ヘッダフィールドを送信しなければならない
- [MUST] 複数のプロトコル層を切り替える場合、送信者はプロトコルを層の昇順で列挙しなければならない
- [MUST NOT] サーバは、対応するリクエストの`Upgrade`でクライアントが示していないプロトコルに切り替えてはならない
- [MAY] サーバは、クライアントが示した優先順位を無視し、リクエストの性質やサーバーの現在の負荷など、
  他の要因に基づいて新しいプロトコルを選択することもできる
- [MUST] 426 Upgrade Required レスポンスを送信するサーバは、受け入れ可能なプロトコルを優先順位の降順で示す
  `Upgrade`ヘッダフィールドを送信しなければならない
- [MAY] サーバは、将来のリクエストに適切である場合、リストされたプロトコルへの優先順位の降順でのアップグレードを
  サポートしていることを通知するため、その他のレスポンスで`Upgrade`ヘッダフィールドを送信してもよい

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
```

- プロトコル変更後のアプリケーション層の通信の機能と性質は、選択された新しいプロトコルに完全に依存する
  - ただし101 Switching Protocols レスポンスを送信した直後のサーバは、新しいプロトコルで同等のリクエストを
    受信したかのように、元のリクエストへの応答を継続することが期待される
    (= プロトコル変更後もサーバは未処理のリクエストを処理する必要があり、
     リクエストを繰り返すことなく処理することが期待される)
    - e.g. GETリクエストで`Upgrade`を受信し、サーバがプロトコルの切り替えを決定した場合、
      サーバーはまずHTTP/1.1の101 Switching Protocols メッセージを返送し、
      その後すぐに対象リソースに対するGETレスポンスと同等の新しいプロトコルのレスポンスを送信する。
      これにより、追加のラウンドトリップによる遅延コストなしに、HTTPと同じ意味論を持つプロトコルへの接続の
      アップグレードが可能になる
- [MUST NOT] サーバは、受信したメッセージの意味論が新しいプロトコルで処理できない限り、
  プロトコルを切り替えてはならない
- OPTIONSリクエストはどのプロトコルでも処理できる

```
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

...以降、WebSocket プロトコルに切り替わり、 GET /hello に対する WebSocket 的な応答が続く...
```

- [MUST] `Upgrade`の送信者は、中継者に対してこのフィールドを転送しないよう知らせるため、
  `Connection`ヘッダフィールドに`Upgrade`接続オプションを送信しなければならない
  - [MUST] HTTP/1.0リクエストで`Upgrade`ヘッダフィールドを受信したサーバは、
    その`Upgrade`フィールドを無視しなければならない
- クライアントは、リクエストメッセージを完全に送信するまで、接続上でアップグレードされたプロトコルの使用を
  開始できない (= クライアントはメッセージの途中で送信プロトコルを変更できない)
  - [MUST] サーバが`100-continue`expectationを含む`Upgrade`ヘッダフィールドと`Expect`ヘッダフィールドの両方を
    受信した場合、サーバは101 Switching Protocols レスポンスを送信する前に
    100 Continueレスポンスを送信しなければならない
- `Upgrade`ヘッダフィールドは、既存の接続上でのプロトコル切り替えにのみ適用される
  - 基盤となるトランスポートプロトコルを切り替えるために使用することも、
  - 既存の通信を別の接続に切り替えるために使用することもできない
    - これらの目的では3xx Redirection レスポンスを使用する方が適切
- 本仕様は、HTTPバージョン規則および将来の更新で定義されるHypertext Transfer Protocolファミリーで使用される
  プロトコル名`HTTP`のみを定義している

## Representation Data and Metadata https://www.ietf.org/rfc/rfc9110.html#name-representation-data-and-met
### Representation Data

- HTTPメッセージに関連付けられる表現データ (representation data) は
  メッセージのコンテンツとして含まれるか、メッセージの意味論 + ターゲットURIによって参照される
- 表現データは、表現メタデータヘッダフィールドによって定義された形式とエンコーディングによって決定される
- 表現データのデータ型は`Content-Type`および`Content-Encoding`ヘッダフィールドによって決定される
  - これらは2層構造で順序付けられたエンコーディングモデルを定義する

```
representation-data := Content-Encoding( Content-Type( data ) )

- data                                     ... 元の表現内容 (Content-Typeが直接定義する対象)
- Content-Type( data )                     ... dataをあるメディア型としてシリアライズしたもの (バイト列)
- Content-Encoding( Content-Type( data ) ) ... Content-Type( data ) をエンコーディングしたもの (HTTPメッセージ本文)
```

```
(このメッセージの本文はJSON型として解釈されるバイト列をgzip圧縮したもの)

Content-Type: application/json
Content-Encoding: gzip
```

### Representation Metadata (表現メタデータ)
- 表現ヘッダフィールド (representation header fields) は表現に関するメタデータを提供する
- メッセージにコンテンツが含まれる場合、表現ヘッダフィールドはそのデータをどのように解釈すべきかを記述する
  - `Content-Type`
  - `Content-Encoding`
  - `Content-Language`
  - `Content-Length`
  - `Content-Location` など
- HEADリクエストに対するレスポンスにおいて、表現ヘッダフィールドは、
  同じリクエストがGETであった場合にコンテンツ内に含まれていたであろう表現データを記述する

### Content-Type
- `Content-Type`ヘッダフィールドは、関連付けられた表現のメディアタイプを示す
  - メディアタイプは、メッセージのコンテンツに含まれる表現か、またはメッセージの意味論上で選択された表現のいずれか
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Type
    - コンテンツへのエンコードが適用される前の、リソースの元のメディア種別を示す
    - レスポンスにおいては、クライアントに返されたコンテンツの実際の種類を伝える
    - `Content-Encoding`とは異なり、`Content-Encoding`は受信者がもとの形にデコードする方法を得るのに役立つ
- 指定されたメディアタイプは、`Content-Encoding`で指定されたコンテンツコーディングがデコードされた後、
  受信メッセージの意味論の範囲内で、データ形式と受信者によるデータの処理方法の両方を定義する

```
Content-Type = media-type
```

```
Content-Type: text/html; charset=ISO-8859-4
```

- [SHOULD] コンテンツを含むメッセージを生成する送信者は、含まれる表現の意図されたメディアタイプが
  送信者にとって不明でない限り、そのメッセージに`Content-Type`ヘッダフィールドを生成する必要がある
- [MAY] `Content-Type`ヘッダフィールドが存在しない場合、受信者はメディアタイプが
  `application/octet-stream` [RFC2046] であると想定するか、データを調べてそのタイプを判別することができる
- 実用上リソースオーナーは、特定の表現に対して正しい`Content-Type`を提供するようオリジンサーバを適切に
  設定していない場合もある
  - 一部のユーザエージェントはコンテンツを検査し、場合によっては受信したタイプを上書きする場合がある
    - MIME sniffing ... データについて誤った結論を導き出すリスクがあり、ユーザがセキュリティリスクにさらされる
      可能性がある。さらに、異なるメディアタイプはデータの処理方法のみが異なる共通のデータ形式を共有することが多く
      データの検査だけでは区別できない。スニッフィングを実装する場合、実装者はユーザがそれを無効化する手段を
      提供することが推奨される
- `Content-Type`はシングルトンフィールドとして定義されていますが、誤って複数回生成され、
   結果としてリストのように見える結合フィールド値が生成されてしまうことがある
  - 受信者は、リストの構文的に有効な最後のメンバーを使用してこのエラーを処理しようとすることがよくある
    - そのため、実装によってエラー処理の動作が異なる場合、相互運用性やセキュリティ上の問題が発生する可能性がある

#### Media Type
- HTTPは、`Content-Type`ヘッダフィールドおよび`Accept`ヘッダフィールドにおいて、
  メディアタイプ [RFC2046] を使用することで、オープンで拡張可能なデータの型指定と型ネゴシエーションを提供する
  - メディアタイプは、データ形式と様々な処理モデル (メッセージのコンテキストに応じたデータの処理方法) を定義する

```
media-type = type "/" subtype parameters
type       = token
subtype    = token
```

- [MAY] `type/subtype`の後には、`;`で区切られたパラメータを`名前=値`の形式で指定できる
  - パラメータの有無は、メディアタイプレジストリにおける定義次第によって、
    メディアタイプの処理にとって重要となる場合がある
    - パラメータ値が大文字・小文字を区別するかどうかは、パラメータ名の意味論に依存する

```
UTF-8文字エンコーディング方式でエンコードされたHTMLテキストデータを記述する場合、
以下のメディアタイプは同等だが、一貫性の観点から最初のメディアタイプが推奨される

text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html;charset="utf-8"
text/html;charset=UTF-8
```

- メディアタイプは、[BCP13] で定義された手順に従ってIANAに登録する必要がある

#### Charset
- HTTPは、テキスト表現の文字エンコーディング方式 [RFC6365] を示したり、ネゴシエーションのためにcharset名を使用する
  - 本文書で定義されるフィールドでは、charset名は`Content-Type`のパラメータ内、
    または`Accept-Encoding`のプレーントークンとして利用される
  - charset名は大文字と小文字を区別せずに照合される
- charset名は、[RFC2978] で定義されている手順に従い、IANAのCharacter Setsレジストリに登録する必要がある

#### Multipart Types
- multipartは一つのメッセージボディ内に一つ以上の表現をカプセル化するためのmedia-type
  - MIMEには複数のmultipartが定義されている

```
multipart/form-data
multipart/byteranges
multipart/mixed
```

- すべてのmultipartは共通の構文とboundaryパラメータを含む

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123
```

- multipartのボディは単なるバイト列ではなく、MIMEによって定義された厳密なプロトコル構文を持つ構造体

- MIMEは、複数のmultipart型 (1つのメッセージボディ内に1つ以上の表現を内包するもの) を提供する
  - すべてのmultipart型は、[RFC2046] 5.1.1 で定義されている共通の構文を共有し、
    メディアタイプ値の一部としてboundaryパラメータを含む
  - [MUST] メッセージボディ自体がプロトコル要素であるため、送信者はボディパート間の改行を表すためには
    CRLFのみを利用する
- HTTPのメッセージフレーミングでは、メッセージボディ長の指示子としてmultipartのboundaryを使用しないが、
  コンテンツを生成または処理する実装では使用される場合がある
  - e.g. `multipart/form-data`型は、リクエストでフォームデータを伝送するためによく使用される ([RFC7578])
  - e.g. `multipart/byteranges`型は、一部の206 Partial Contentレスポンスで使用するために本仕様で定義されている

### Content-Encoding
- `Content-Encoding`ヘッダフィールドは、
  メディアタイプに内在するものを除いて、表現に対してどのコンテンツコーディングが適用されているか、
  そして`Content-Type`で参照されているメディアタイプのデータを得るために、どの復号機構を適用する必要があるかを示す
  - `Content-Encoding`は主に、基礎となるメディアタイプの同一性を失うことなく
    その表現のデータを圧縮するために用いられる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Encoding
    - 表現 (メッセージのコンテンツ) に適用されているエンコード方式とその順番を保持するための表現ヘッダ
    - 受信者は、`Content-Encoding`によって元のコンテンツの形式を取得するために、
      その表現をデコードする方法を知ることができる
    - コンテンツのエンコード方式は主に、元のメディアタイプに関する情報を失うことなく
      メッセージデータを圧縮するために使用される
    - 元のメディア/コンテンツの形式は`Content-Type`で指定し、
      `Content-Encoding`はデータの表現 = 「コード化形式」に適用される

```
Content-Encoding = #content-coding
```

```
Content-Encoding: gzip
```

- [MUST] 表現に1つ以上のエンコーディングが適用されている場合、それらのエンコーディングを適用した送信者は、
  適用された順序でコンテンツコーディングを列挙する`Content-Encoding`ヘッダーフィールドを生成しなければならない
  - [SHOULD NOT] `identity`というコーディングは`Accept-Encoding`における特別な役割のために予約されているため、
    含めるべきではない
- エンコーディングのパラメータに関する追加情報は、本仕様外で定義される他のヘッダフィールドによって提供されうる
- `Transfer-Encoding` [HTTP/1.1] 6.1 とは異なり、`Content-Encoding`に列挙されるコーディングは表現そのものの特性
  - 表現はコーディングされた形式によって定義されている
  - 特に指定がない限り、表現に関する他のすべてのメタデータもコーディングされた形式について述べている
  - 通常表現は、レンダリングやそれに類する利用の直前にのみデコードされる
- メディアタイプに固有のコーディング (e.g. 常に圧縮されるデータ形式など) が含まれている場合、
  そのコーディングがコンテンツコーディングのいずれかと同じアルゴリズムであっても、
  `Content-Encoding`に再度記述されることはない
  - そのようなコンテンツコーディングが列挙されるのは、何らかの奇妙な理由によって
    それが表現を形成するために2度目に適用された場合のみ
  - 同様にオリジンサーバは、コーディングが`Content-Type`の一部として定義されているか
    `Content-Encoding`の一部として定義されているかのみが異なる複数の表現として
    同じデータを公開することを選択する場合がある
    - これは、一部のユーザエージェントが各レスポンスの処理において異なる動作をするため
- [MAY] リクエストメッセージ内の表現に受け入れ不可能なコンテンツコーディングが含まれている場合、
  オリジンサーバは415 Unsupported Media Typeを返してもよい

#### Content Codings
- コンテンツコーディング値は、表現に適用された、または適用可能なエンコーディング変換を示す
  - gzip
  - compress
  - deflate など
- コンテンツコーディングは主に、基盤となるメディアタイプの同一性や情報を失わずに
  表現を圧縮したり、変換したりするために用いられる
  - 多くの場合、表現は符号化された形式で保存され、直接送信され、最終受信者によってのみデコードされる

```
content-coding = token
```

- すべてのコンテンツコーディングは大文字と小文字を区別しない
- すべてのコンテンツコーディングはHTTP Content Coding Registryに登録されるべき
- コンテンツコーディング値は、`Accept-Encoding`と`Content-Encoding`ヘッダフィールドで使用される
- Gzip Coding
  - 32ビットの巡回冗長検査 (CRC) を備えたLZ77圧縮方式 (gzipファイル圧縮プログラムによって生成される)
- Compress Coding
  - Lempel-Ziv-Welch (LZW) 圧縮方式 (compressよって生成される)
- Deflate Coding
  - deflate圧縮データストリームを含むzlibデータ形式、Lempel-Ziv (LZ77) 圧縮アルゴリズムとハフマン符号化の組み合わせ

### Content-Language
- `Content-Language`ヘッダフィールドは、その表現が意図している対象読者の自然言語を記述する
  - 必ずしも表現内で実際に使用されている言語と一致するとは限らない
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Language
    - ユーザが自分の好みの言語に応じて区別できるよう、オーディエンス向けの言語を記述するエンティティヘッダ

```
Content-Language = #language-tag
```

- `Content-Language`の主な目的は、ユーザが自身の好みの言語に基づいて表現を識別・区別できるようにすること

```
コンテンツがデンマーク語を読める読者のみを対象としている場合

Content-Language: da
```

- `Content-Language`の指定がない場合、デフォルトでは、コンテンツはすべての言語の読者を対象としているとみなされる
  - これは、送信者がコンテンツが特定の自然言語に特化しているとは考えていないか、
    送信者がどの言語を対象としているかを把握していないことを意味する場合がある
- 複数の読者を対象としたコンテンツには、複数の言語を記載することができる
  - 複数の言語が表現に含まれているからといっても、必ずしも複数の言語の読者を対象としているわけではない

```
(同一内容を複数言語で同時提供しているケース)

Content-Language: ja, en
```

- `Content-Language`はあらゆるメディアタイプに適用でき、テキスト文書に限定されない

#### Language Tags
- [RFC5646] で定義されているLanguage Tagsは、人間が他の人間に情報を伝達するために
  話す、書く、その他の方法で伝える自然言語を識別し、コンピュータ言語は明示的に除外される
- HTTPは、`Accept-Language`ヘッダフィールドと`Content-Language`ヘッダフィールド内でLanguage Tagsを使用する
  - `Content-Language`は`language-tag`構文を使用する
    - `Accept-Language`はより広い`language-range`構文を使用する

```
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

- Language Tagsは、大文字と小文字を区別しない1つ以上のサブタグのシーケンス
  - 各サブタグはハイフン文字 (`-`、`%x2D`) で区切られる
  - ほとんどの場合、Language Tagsは、関連する言語の広範なファミリを識別する主要な言語サブタグで構成される
    - そのうえで、オプションでその言語の範囲を絞り込んだり、詳細化したりする一連のサブタグが続く
  - Language Tags内には空白文字は使用できない

```
fr、en-US、es-419、az-Arab、x-pig-latin、man-Nkoo-GN
```

### Content-Length
- `Content-Length`ヘッダフィールドは、関連付けられた表現のデータ長を、10進の非負整数のオクテット数で示す
  - 表現をコンテンツとして転送する場合において、`Content-Length`はフレームを区切るために使用できるよう、
    具体的に同封されているデータ量を指す
  - それ以外の場合、`Content-Length`は選択された表現の現在の長さを示す
  - 受信者はこの長さを使用して、転送時間を推定したり、以前保存した表現と比較したりすることができる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Length
    - 受信者に送信されるエンティティ本文の長さをバイト単位で示すエンティティヘッダ

```
Content-Length = 1*DIGIT
```

```
Content-Length: 3495
```

- [SHOULD] ユーザエージェントは、リクエストメソッドが同封コンテンツに意味を定義しており、
  かつ`Transfer-Encoding`を送信しない場合、`Content-Length`を送信すべき
  - e.g. POSTリクエストでコンテンツが空 = 値が0の場合でも`Content-Length`を送信する
  - [SHOULD NOT] リクエストメッセージにコンテンツが含まれず、かつリクエストメソッドの意味論が
    そのようなデータを想定できない場合、ユーザエージェントは`Content-Length`を送信すべきではない
- [MAY] サーバは、HEADリクエストへのレスポンスにおいて`Content-Length`を送信してもよい
  - ただしそのフィールド値が、同じリクエストがGETメソッドを使用していた場合にレスポンスのコンテンツとして送信される
    オクテット数の10進数と等しくない限り、サーバはそのレスポンスにおいて`Content-Length`を送信してはいけない
- [MAY] サーバは、条件付きGETリクエストに対する304 Not Modified レスポンスにおいて`Content-Length`を送信してもよい
  - ただしそのフィールド値が、同じリクエストに対する200 OK レスポンスのコンテンツとして送信される
    オクテット数の10進数と等しくない限り、サーバはそのレスポンスにおいて`Content-Length`を送信してはいけない
- [MUST NOT] サーバは、ステータスコードが1xx Informational または204 No Content のレスポンスに対して
  `Content-Length`を送信してはならない
- [MUST NOT] サーバは、CONNECTリクエストに対する2xx Successful レスポンスにも、`Content-Length`を送信してはならない
- [SHOULD] 上記で定義したケースを除きいて`Transfer-Encoding`がない場合、オリジンサーバは、
  完全なヘッダセクションを送信する前にコンテンツサイズがわかっている場合は`Content-Length`を送信すべき
  - これにより下流の受信者は転送の進行状況を測定し、受信メッセージの完了を確認し、
    追加のリクエストのために接続を再利用できる
- `Content-Length`フィールドの値がは0以上であれば有効
  - [MUST NOT] コンテンツの長さには事前に定義された制限がないため、受信者は潜在的に大きな小数値を想定し、
    整数変換のオーバーフローや整数変換による精度の低下による解析エラーを防止しなければならない
- HTTP/1.1では`Content-Length`がメッセージの区切りとして使用される
  - 直接の接続がHTTP/1.1を使用していない場合でも、そのフィールド値は下流の受信者によるメッセージの解析方法に
    影響を与える可能性がある
  - メッセージが下流の中継者によって転送される場合、受信したメッセージのフレーミングと一致しない
    `Content-Length`フィールド値は、リクエストのスマグリングやレスポンスの分割によるセキュリティ違反を
    引き起こす可能性がある
- [MUST NOT] 送信者は、正しくないことが判明している`Content-Length`フィールド値を持つメッセージを転送してはならない
- [MUST NOT] 送信者は上記のABNFと一致しない`Content-Length`フィールド値を持つメッセージを転送してはならない
  - [MAY] 例外として、コンマ区切りのリストとして繰り返される同じ10進数値で構成される`Content-Length`フィールド値の
    受信者は、メッセージを無効として拒否するか、その無効なフィールド値を1つの10進数値のインスタンスに
    置き換えることができる (e.g. `Content-Length: 42, 42`)
    - 上流のメッセージプロセッサによって重複が生成または結合されたことを示している可能性が高いため

### Content-Location
- `Content-Location`ヘッダフィールドはメッセージのコンテンツに含まれる表現に
  対応するリソースの識別子として使用できるURIを示す
  - このメッセージの生成された時点でこのURIに対してGETリクエストを実行すると、それに対する200 OKレスポンスには
    このメッセージのコンテンツとして含まれているものと同じ表現が含まれる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Location
    - 返されるデータの代替場所を示す
    - 主な用途は、コンテンツネゴシエーションの結果として送信されたリソースのURLを示すこと

```
Content-Location = absolute-URI / partial-URI
```

- `Content-Location`フィールド値は絶対URIまたは部分URI
  - 部分URIの場合、参照されるURIはターゲットURIを基準とした相対URI
- `Content-Location`フィールド値は、ターゲットURIの代替ではなく表現メタデータであり、
  [RFC2557] 4 でMIMEボディパーツ用に定義されている同名のヘッダフィールドと同じ構文と意味論を持つ
- [MAY] 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` == 対象URIの場合:
  - 受信者は、そのコンテンツをメッセージ発信日で示される時点におけるリソースの現在の表現と見なしてもよい
  - GET/HEADリクエストへのレスポンスの場合:
    - サーバから`Content-Location`が提供されない場合のデフォルトの意味論と同じ
  - PUT/POSTリクエストへのレスポンスの場合:
    - サーバのレスポンスにそのリソースの新しい表現が含まれていることを意味し、
      単に処理結果を報告するだけの表現表現とは区別される
    - これによって作成系アプリケーションは、後続のGETリクエストを行わずにローカルコピーを更新できる
- [MAY] 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` != 対象URIの場合:
  - オリジンサーバは、そのURIが含まれている表現に対応する別のリソースの識別子であると主張している
    - このような主張は、両方の識別子が同じリソース所有者を共有している場合にのみ信頼できる
    - リソース所有者は、HTTP経由ではプログラム的に判別できない
  - GET/HEADリクエストへのレスポンスの場合:
    - ターゲットURIがコンテンツネゴシエーションの対象となるリソースを参照しており、
      `Content-Location`フィールド値が選択された表現のより具体的な識別子であることを示す
  -  PUT/POSTリクエストへの201レスポンスの場合:
    - `Content-Location`フィールド値が`Location`フィールドの値と同一である場合、
      このコンテンツは新しく作成されたリソースの現在の表現であることを示す
  - それ以外の場合:
    - `Content-Location`は、このコンテンツが要求された操作のステータスを報告する表現であり、
      同じレポートが指定されたURIで利用可能であることを示す
      - e.g. POSTリクエストによる購入トランザクションでは、200 OK レスポンスのコンテンツとして
        レシート文書が含まれる場合がある。`Content-Location`フィールド値は、将来同じレシートのコピーを
        取得するための識別子を提供する
- リクエストメッセージで`Content-Location`を送信するユーザエージェントは、
  その値が、同封されている表現のコンテンツをユーザエージェントが元々取得した場所を指していることを示す
- [MUST] リクエストメッセージで`Content-Location`フィールドを受信したオリジンサーバは、その情報を表現の一部として
  そのまま保存されるメタデータではなく、一時的なリクエストコンテキストとして扱わなければならない
  - [MAY] オリジンサーバは、そのコンテキストをリクエスト処理のガイドとして使用したり、
    ソースリンクやバージョン管理メタデータ内など、他の用途のために保存したりすることができる
    - [MUST NOT] ただしオリジンサーバは、そのようなコンテキスト情報を使用してリクエストの意味論を変更してはならない
- 例えばクライアントがネゴシエートされたリソースに対してPUTリクエストを送信し、
  オリジンサーバーがそのPUTをリダイレクトなしで受け入れた場合、
  そのリソースの新しい状態は、そのPUTで提供された1つの表現と一致すると期待される
  - `Content-Location`はネゴシエートされた表現の1つだけを更新するための逆方向のコンテンツ選択識別子として
    使用することはできない
    - ユーザエージェントが後者の意味論を必要としていた場合、`Content-Location`のURIに直接PUTしていたはず

### Validator Fields (検証子フィールド)
- 検証子フィールドは事前条件 (precondition) で使用できるvalidatorを定義する
  - `Last-Modified`、`ETag`ヘッダフィールドなど
  - 条件付きリクエスト、同時更新の衝突防止、キャッシュ検証 などに使用される
- GET / HEAD などのリクエストに対するレスポンスでは、サーバが処理の際に選択した表現を記述する
- 状態変更を伴うリクエストに対して成功を示すレスポンスでは、サーバの処理結果として新たに有効となった表現を記述する

- 前提条件 (precondition) 内で条件付きリクエストを作成するために使用できるリソースメタデータのことを検証子と呼ぶ
  - 検証子フィールドは、選択された表現の現在の検証子を示す
- 安全なリクエストへのレスポンスにおいて、
  検証子フィールドはレスポンスを処理する際にオリジンサーバが選択した表現を記述する
  - メソッドやステータスコードの意味論によっては、あるレスポンスで選択された表現と
    レスポンスのコンテンツとして実際に含まれている表現とが必ずしも一致しないことがある
- 状態変更リクエストへの成功したレスポンスにおいて、
  検証子フィールドはリクエストの処理の結果として、以前に選択された表現を置き換えた新しい表現を記述する
  - e.g. 201 Created レスポンスの`ETag`フィールドは、新しく作成されたリソースの表現のエンティティタグを伝達する
    - これによってこのエンティティタグは後続の条件付きリクエストにて検証子として使用でき、
      lost update問題を防ぐことができる
- 本仕様ではリソースの状態を観察し、前提条件をテストするために一般的に用いられる
  2つの形式のメタデータ (変更日 / 不透明なエンティティタグ) を定義する
  - リソースの状態を反映する追加のメタデータは、Web Distributed Authoring and Versioning [WEBDAV] などの
    HTTPの様々な拡張によって定義されているものの、本仕様の範囲外

#### Weak versus Strong
- キャッシュエントリは有効期限に関わらず任意の期間存続する可能性があり、
  そのためキャッシュは過去に取得した検証子を使用してエントリの検証を試みる場合がある
- 検証子には、強い (strong) 検証子と弱い (weak) 検証子の2種類がある
  - 強い検証子:
    - 比較には最適であり、効率的に生成するのが非常に困難
    - GETに対する200 OK レスポンスのコンテンツとして確認できる表現データに変更が発生するたび値が変化する
      - 表現データそのものの変更以外の理由変更された場合にも値が変化し得る
        - 例えば表現メタデータの意味的に重要な部分 ... `Content-Type`など
        - オリジンサーバにとっては、リモートキャッシュやオーサリングツールに保持されている
          保存済みレスポンスを無効化する必要がある場合にのみ値を変更することが利益にかなう
    - 強い検証子は、特定のリソースに関連付けられたすべての表現のすべてのバージョンにおいて、時間の経過とともに一意
      - 異なるリソースの表現間で一意であるとは限らない
        - 同じ強力な検証子が複数のリソースの表現に同時に使用されている場合があり、
          それらの表現が同等であることを意味するわけではない
    - 実運用ではさまざまな強い検証子が使用されている
      - 最良のものは厳密なリビジョン管理に基づくものであり、表現に変更が加えられるたびに、
        GETによりアクセス可能になる前に、常に一意なノード名とリビジョン識別子が割り当てられる
      - 検証リクエストを受信するたびにダイジェストを再計算する必要がなく、
        レスポンスヘッダフィールドが送信される前にデータが利用可能な場合は
        衝突耐性のあるハッシュ関数を表現データに適用するだけで十分
        - リソースがメタデータのみが異なる複数の表現を持つ場合、
          オリジンサーバはそれらの表現を区別するために検証子に追加情報を組み込む必要がある
  - 弱い検証子:
    - 生成が容易であり、比較には有用性が低い
    - 表現データが変更されても変化しない可能性がある
      - 値の計算方法 (e.g. クロックの分解能) の制限や、リソースのあらゆる表現の一意性を保証できないこと、
        リソース所有者が一意のデータシーケンスではなく、自ら定義した等価性集合によって表現をまとめたいという
        意図などに起因する
- HTTPはすべてのリソースに同じ強度の検証子を適用することを強制するのではなく、
  使用されている検証子の種類を公開し、弱い検証子を前提条件に使用できるケースに制限を設けている
- [SHOULD] オリジンサーバは、以前の表現が現在の表現の代替として受け入れられない
  (= キャッシュに対して古いレスポンスを無効化させたい場合) と判断した場合は、弱いエンティティタグを変更すべき
  - ある検証子が、あるリソースの2つ以上の表現によって同時に共有されている場合、
    それらの表現が同一の表現データを持たない限り、その検証子は弱い検証子となる
    - e.g. オリジンサーバーが、gzipコンテンツコーディングが適用された表現に対し、
      コンテンツコーディングが適用されていない表現に対するものと同じ検証子を送信する場合、その検証子は弱い検証子
    - 表現メタデータのみが異なる (e.g. 同一データに対して異なるメディアタイプが提供されるなど) 2つの同時表現は、
      同じ強い検証子を共有する可能性がある↲
- 強い検証子は、キャッシュ検証、部分的なコンテンツ範囲、およびlost update問題の回避など、
  あらゆる条件付きリクエストに使用できる
- 弱い検証子は、キャッシュエントリの検証やWebトラバーサルを最近の変更に限定する場合など、
  クライアントが以前に取得した表現データとの完全な一致を必要としない場合にのみ使用できる

| 使用場面              | Strong | Weak |
| - | - | - |
| キャッシュ検証        | ○      | ○    |
| If-None-Match         | ○      | ○    |
| If-Match              | ○      | ×    |
| 範囲 / 部分コンテント | ○      | ×    |
| 更新の取りこぼし防止  | ○      | ×    |
| 最近更新されたか      | ○      | ○    |

#### Last-Modified
- `Last-Modified`レスポンスヘッダフィールドは、
  選択された表現が「最後に変更された」とオリジンサーバが判断した日時を示すタイムスタンプを提供する
  - この変更は、リクエスト処理の終了時に決定される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Last-Modified
    - リソースが最後に変更されたとオリジンサーバが判断している日時
    - 受信または保存されたリソースが同じものであるか判断する検証材料として使用される
    - `ETag`ヘッダよりも精度は低く、その代替手段となる
    - `If-Modified-Since`や`If-Unmodified-Since`ヘッダを含む条件付きリクエストによって使用される

```
Last-Modified = HTTP-date
```

```
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

- (Generation)
  - [SHOULD] オリジンサーバは、最終更新日時が合理的かつ一貫して決定可能な選択された表現について
    `Last-Modified`を送信すべき
    - `Last-Modified`は条件付きリクエストやキャッシュの新鮮度評価において利用され、不要な転送を大幅に削減し、
      サービスの可用性とスケーラビリティを大きく向上させることができる
  - 表現は通常、リソースインターフェースの背後にある多くの要素の集合であり、
    最終更新日時は通常、それらの要素のいずれかが変更された最新の日時となる
    - 特定のリソースに対してこの値をどのように決定するかは、実装の詳細であり、本仕様の範囲外
  - [SHOULD] オリジンサーバは、レスポンスの`Date`フィールド値を生成する時刻に可能な限り近い時刻で、
    表現の`Last-Modified`値を取得すべき
    - これにより受信者は、レスポンスの生成時刻に近い時刻に表現が変更された場合に、表現の更新日時を正確に評価できる
  - [MUST NOT] クロックを備えたオリジンサーバは、サーバのメッセージ生成時刻よりも後の日時を
    `Last-Modified`として生成してはならない
    - [MUST] 実装固有のメタデータから導出した最終更新時刻値がオリジンサーバのクロックによると将来の時刻になる場合、
      オリジンサーバはその値をメッセージ生成日付に置き換えなければならない
        - 将来の更新日時がキャッシュ検証に悪影響を与えるのを防ぐため
  - [MUST NOT] クロックを持たないオリジンサーバは、他の (おそらくクロックを持つ) システムによって
    リソースに日付値が割り当てられた場合を除き、レスポンスに`Last-Modified`を生成してはならない
- (Comparison)
  - リクエストにおいて`Last-Modified`が検証子として使用される場合、以下の規則を用いて
    それが強い検証子であると推論できる場合を除き、暗黙的に弱い検証子となる:
    - オリジンサーバが、当該検証子と当該表現の現在の検証子を比較している、
      かつそのオリジンサーバが、提示された検証子がカバーする秒間に、
      その表現が2回変更されていないことを信頼性高く把握している場合
    - クライアントが提示された検証子を`If-Modified-Since`、`If-Unmodified-Since`、`If-Range`のいずれかで
      使用しようとしており、これはクライアントが関連する表現のキャッシュエントリを持っているためであり、
      かつそのキャッシュエントリに`Last-Modified`値 + 1~秒後の`Date`値が含まれており、
      さらに両者が同一の時計によって生成されたと信じる合理的な理由がある、
      または`Last-Modified`と`Date`の差が十分に大きく、時計同期の問題が起こりにくいと考えられる場合
    - 検証子が中間キャッシュによって、そのキャッシュエントリに保存されている当該表現の検証子と比較されており、
      かつそのキャッシュエントリに含まれる`Date`値が`Last-Modified`値 + 1~秒後であり、
      さらに両者が同一の時計によって生成されたと信じる合理的な理由がある、
      または`Last-Modified`と`Date`の差が十分に大きく、時計同期の問題が起こりにくいと考えられる場合
    - これらの比較方法は、オリジンサーバから同じ秒間に2つの異なるレスポンスが送信され、
      両方の`Last-Modified`が同じである場合、少なくとも一方のレスポンスの`Date`値は`Last-Modified`と一致する
      という事実に基づく

#### ETag
- `ETag`レスポンスヘッダフィールドは、選択された表現の現在のエンティティタグを示す
  - このタグは、リクエスト処理の完了時に決定される
  - エンティティタグは、同一リソースの複数の表現を区別するための不透明な検証子であり、
    これらの複数の表現が、時間経過によるリソースの状態変化、コンテンツネゴシエーションの結果、
    複数の表現が同時に有効になる場合、あるいはその両方による場合であっても区別される
    - エンティティタグは不透明な引用符で囲まれた文字列で構成され、必要に応じて弱さを示す接頭辞が付与される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/ETag
    - リソースの特定バージョンの識別子
    - これによりキャッシュの効率が向上し、帯域幅を節約できる
    - さらにリソースの同時更新による上書きを防止するのにも役立つ
    - 指定されたURLのリソースが変更された場合、新しい`ETag`値を生成する必要がある
      - これらを比較することで、リソースの2つの表現が同じかどうかを素早く判断できる

```
ETag       = entity-tag

entity-tag = [ weak ] opaque-tag
weak       = %s"W/"
opaque-tag = DQUOTE *etagc DQUOTE
etagc      = %x21 / %x23-7E / obs-text
           ; 二重引用符を除く VCHAR と obs-text
```

- `opaque-tag`は以前、引用符で囲まれた文字列として定義されていた ([RFC2616] 3.11)
  - そのため、一部の受信者はバックスラッシュのエスケープ解除を行う可能性があった
  - したがって、サーバはエンティティタグ内でバックスラッシュ文字を避けるべき
- エンティティタグは更新日時を保存するのが不便な場合や、HTTP日付値の1秒単位の精度では不十分な場合や、
  更新日時が一貫して維持されていない場合などに更新日時よりも検証の信頼性が高くなりえる

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

- エンティティタグは弱い検証子または強い検証子のいずれかにすることができ、デフォルトは強い検証子
- [MUST] オリジンサーバが表現に対してエンティティタグを提供しており、
  生成されたエンティティタグが強い検証子のすべての特性を満たさない場合、
  オリジンサーバはエンティティタグの不透明値に`W/` (大文字と小文字を区別) をプレフィックスとして付加し、
  そのエンティティタグを弱いものとしてマークしなければならない
- [MAY] 送信者は、ETagフィールドをトレーラセクションで送信してもよい
  - トレーラは無視されることが多いため、コンテンツの送信中にエンティティタグが生成される場合を除き、
    `ETag`フィールドはヘッダフィールドとして送信することが望ましい

- (Generation)
  - エンティティタグの背後にある原則:
    - サービス作成者のみがリソースの実装を十分に理解しており、
      そのリソースに対して最も正確かつ効率的な検証メカニズムを選択できること
    - そのようなメカニズムは単純なオクテット列にマッピングして容易に比較できること
    - 値は不透明であるため、クライアントは各エンティティタグの構成を意識する必要はない
  - [SHOULD] オリジンサーバは、変更の検出が合理的かつ一貫して決定できる選択された表現に対して`ETag`を送信すべき
    - エンティティタグは条件付きリクエストやキャッシュの鮮度の評価 [CACHING] に利用されることで
      不要な転送を大幅に削減し、サービスの可用性、スケーラビリティ、信頼性を大幅に向上できる
- (Comparison)
  - エンティティタグの比較関数には、比較コンテキストで弱い検証子の使用が許可されているかどうかによって、2種類ある
    - 強い比較 (Strong comparison):
      - 2つのエンティティタグが両方とも弱い検証子ではなく、かつ両者の`opaque-tag`が文字単位で一致する場合、
        2つのエンティティタグは等価
    - 弱い比較 (Weak comparison):
      - どちらかまたは両方のエンティティタグがweakとしてタグ付けされているかどうかに関わりなく、
        両者の`opaque-tag`が文字単位で一致している場合、
        2つのエンティティタグは等価

| ETag 1  | ETag 2  | Strong Comparison | Weak Comparison |
| - | - | - | - |
| `W/"1"` | `W/"1"` | no match          | match           |
| `W/"1"` | `W/"2"` | no match          | no match        |
| `W/"1"` | `"1"`   | no match          | match           |
| `"1"`   | `"1"`   | match             | match           |

## Methods https://www.ietf.org/rfc/rfc9110.html#name-methods
- リクエストメソッドトークンはリクエスト意味論の主要な情報源であり、
  クライアントがこのリクエストを行った目的と、クライアントが成功の結果として何を期待するかを示す
- リクエストメソッドの意味論はリクエスト内に存在する一部のヘッダフィールドの意味論によって、
  メソッドと矛盾しない限りさらに特殊化されることがある
  - e.g. クライアントは条件付きリクエストヘッダフィールドを送信することにより、
    対象リソースの現在の状態に基づき、要求された操作を実行する
- HTTPは、分散オブジェクトシステムへのインターフェースとして使用できるように設計されている
  - リクエストメソッドは、リモートメソッド呼び出しを特定のオブジェクトに送信するのとほぼ同じ方法で、
    対象リソースに適用する操作を呼び出す

```
method = token
```

- メソッドトークンは大文字と小文字が区別される
  - メソッド名が大文字と小文字を区別するオブジェクトベースシステムへのゲートウェイとして使用される可能性があるため
  - 慣例により、標準化されたメソッドはすべて大文字のUS-ASCII文字で定義される
- 分散オブジェクトとは異なり、HTTPの標準化されたリクエストメソッドはリソース固有ではない
  - 統一されたインターフェースがネットワークベースのシステム [REST] における可視性と再利用性を向上させるため
  - 標準化されたメソッドは一度定義されると、どのリソースに適用されても同じ意味論を持つ必要があるが、
    各リソースはそれらの意味論が実装されているか、または許可されているかを独自に決定する

| メソッド名 | 意味                                                       |
| -          | -                                                          |
| GET        | 対象のリソースの現在の表現を取得する                       |
| HEAD       | GETと同じ。レスポンスの本文は取得しない                    |
| POST       | リクエスト本文を用いてリソース固有の処理を実行する         |
| PUT        | 対象リソースの現在の表現をリクエスト本文で置き換える       |
| DELETE     | 対象リソースの現在の表現を削除する                         |
| CONNECT    | 対象リソースで識別されるサーバへのトンネルを確立する       |
| OPTIONS    | 対象リソースに対する通信オプションを取得する               |
| TRACE      | 対象リソースまでの経路に沿ってループバックテストを実行する |

- [MUST] すべての汎用サーバは、GETおよびHEAD メソッドをサポートしなければならない
  - [OPTIONAL] その他のメソッドはすべて任意
- 対象リソースで許可されるメソッドのセットは、`Allow`ヘッダフィールドに列挙できる
  - ただし、許可されるメソッドのセットは動的に変更される可能性がある
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Allow
    - あるリソースが対応しているメソッドの一覧を示す
- オリジンサーバは:
  - [SHOULD] 認識できない / 実装されていないリクエストメソッドを受信した場合、
    501 Not Implemented ステータスコードを返すことが推奨される
  - [SHOULD] 認識および実装されてはいるが、対象リソースに対しては許可されていないリクエストメソッドを受信した場合、
    405 Method Not Allowed ステータスコードを返すことが推奨される
- 本仕様の範囲外で、HTTPで使用される追加のメソッドも規定されている
  - そのようなすべてのメソッドは、Hypertext Transfer Protocol (HTTP) Method Registry」に登録されるべきである。

### Common Method Properties
#### Safe Methods
- リクエストメソッドのうち、定義された意味論が本質的に読み取り専用であるもの (= クライアントが安全なメソッドを
  ターゲットリソースに適用した結果として、オリジンサーバの状態変化を要求せず、期待ないもの) は
  安全なメソッドとみなされる
  - 安全なメソッドの適切な使用は、オリジンサーバに損害、資産の損失、異常な負荷をもたらすことを想定していない
  - GET、HEAD、OPTIONS、TRACE
- 安全なメソッドの定義は、実装が潜在的に有害な動作、完全に読み取り専用ではない動作、
  安全なメソッドの呼び出し時に副作用を引き起こす動作を含むことを妨げるものではないが、
  クライアントはその追加の動作を要求しておらず、その動作によって発生した副作用の責任を負わない
  - e.g. ほとんどのサーバはメソッドに関係なく、レスポンスの完了時にアクセスログファイルにリクエスト情報を追加する
    これは、ログストレージがいっぱいになってサーバがダウンする可能性がある場合でも安全と見なされる
    - 同様に、Web上の広告を選択することで開始される安全なリクエストは多くの場合、
      広告アカウントに課金するという副作用をもたらす
- 安全なメソッドと安全でないメソッドを区別する目的は、自動検索プロセス (spiders) や
  キャッシュパフォーマンス最適化 (pre-fetching) が、悪影響を及ぼすことなく動作できるようにすること
  - これにより、ユーザエージェントは、信頼できない可能性のあるコンテンツを処理する際に、
    安全でないメソッドの自動使用に適切な制約を適用できる
- [SHOULD] ユーザエージェントは、ユーザに潜在的な操作を提示する際、安全なメソッドと安全でないメソッドを区別すべき
  - これにより、ユーザは安全でない操作がリクエストされる前に、その操作を認識できる
- ターゲットURI内のパラメータが特定の操作を選択する効果を持つようにリソースが構築されている場合、
  その操作がリクエストメソッドと意味論的に整合していることを保証するのはリソース所有者の責任
  - e.g. Web ベースのコンテンツ編集ソフトウェアでは
    `page?do=delete`のようにクエリパラメータ内で操作を指定することが一般的
    - [MUST] そのようなリソースの目的が非安全な操作を実行することである場合、リソース所有者は、
      安全なリクエストメソッドでアクセスされたときには、その操作を無効化または禁止しなければならない
      - これを怠ると、リンク保守、プリフェッチ、検索インデックス作成などの目的で自動処理が
        すべてのURI参照に対してGETを実行した際、望ましくない副作用が発生する

#### Idempotent Methods
- リクエストメソッドのうち、そのメソッドを用いた複数の同一リクエストがサーバに及ぼす意図された影響が、
  単一のリクエストによる影響と同じであるものは冪等なメソッドとみなされる
  - GET、HEAD、OPTIONS、TRACE、PUT、DELETE
- 安全の定義と同様、冪等性はユーザがリクエストしたものにのみ適用される
- サーバは、各リクエストを個別にログに記録したり、リビジョン管理履歴を保持したり、
  冪等リクエストごとにその他の冪等ではない副作用を実装したりすることができる
- 冪等メソッドは、クライアントがサーバのレスポンスを読み取る前に通信障害が発生した場合、
  リクエストを自動的に再実行できるという点で区別される
  - e.g. クライアントがPUTリクエストを送信し、レスポンスを受信する前に基盤となる接続が閉じられた場合、
    クライアントは新しい接続を確立して冪等リクエストを再試行できる
    - たとえ元のリクエストが成功したとしても、リクエストを繰り返すことで意図した効果は同じになる
      - ただし、レスポンスは異なる可能性がある
- [SHOULD NOT] クライアントは、非冪等メソッドによるリクエストを自動的に再試行すべきではない
  - そのリクエスト意味論がメソッドに関係なく実際には冪等であると知る手段がある場合、
    または元のリクエストが決して適用されなかったことを検出する手段がある場合を除く
  - e.g. ユーザエージェントは、リクエストがそのリソースに対して安全であるとわかっている場合、
    POSTリクエストを自動的に繰り返すことができる
    - 同様に、バージョン管理リポジトリで動作するように特別に設計されたユーザエージェントは、
      接続失敗後に対象リソースのリビジョンを確認し、部分的に適用された変更を元に戻したり修正したりしてから、
      失敗したリクエストを自動的に再試行することにより、部分的な失敗状態から回復できる可能性がある
    - 一部のクライアントはよりリスクの高いアプローチを取り、自動再試行が可能なタイミングを推測しようとする
      - e.g. アイドル状態の持続接続が使用されていた場合、レスポンスの一部でも受信される前に基盤となる接続が
        閉じられた場合、クライアントはPOSTリクエストを自動的に再試行する可能性がある
- [MUST NOT] プロキシは非冪等リクエストを自動的に再試行してはならない
- [SHOULD NOT] クライアントは失敗した自動再試行を自動的に再試行すべきではない

#### Methods and Caching
- キャッシュがレスポンスを保存して使用するためには、関連付けられたメソッドが明示的にキャッシュを許可し、
  かつそのレスポンスが後続のリクエストを満たすために使用できる条件を詳細に定義している必要がある
  - これらの条件を満たさないメソッド定義はキャッシュできない [CACHING]
- 本仕様ではGET、HEAD、POSTのキャッシュ意味論を定義するが、キャッシュ実装の大部分はGETとHEADのみをサポートしている

### Method Definitions
#### GET
- GETメソッドは、ターゲットリソースの現在選択されている表現の転送を要求する
  - 成功した応答は、対象URI [URI] 1.2.2 によって識別される「同一性」の質を反映する
    - HTTPを介して識別可能な情報を取得するということは通常、
      その情報を200 OK レスポンスで提供できる識別子に対してGETリクエストを送信するということ
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/GET
    - 特定のリソースの表現をリクエストする
    - データを本体に含めるべきではない
- GETは情報取得の主要なメカニズムであり、ほぼすべてのパフォーマンス最適化の焦点となる
  - 重要なリソースごとにURIを生成するアプリケーションは、これらの最適化の恩恵を受けると同時に、
    他のアプリケーションによる再利用を可能にし、Webのさらなる拡張を促進するネットワーク効果を生み出す
- 実用上、リソース識別子はリモートファイルシステムのパス名、表現はそのようなファイルの内容のコピーであるように
  実装されていることが多いが、実際にはそのような制限はない
- リソースに対するHTTPのインターフェースは、コンテンツオブジェクトのツリー、様々なデータベースレコードに対する
  プログラム的なビュー、他の情報システムへのゲートウェイとして実装されていることがある
  - URIをマッピングするメカニズムがファイルシステムに結び付けられている場合も、
    オリジンサーバはファイルを直接転送するのではなく、
    リクエストを入力としてファイルを実行し、出力を表現として送信するように構成されることがある
    - いずれにせよ、各リソース識別子がどのような実装に対応しているか、およびその実装がどのようにして
      対象リソースの現在の表現を選択・送信しているかを知る必要があるのは、オリジンサーバのみである
- クライアントは、リクエストに`Range`ヘッダーフィールドを送信することにより、
  GETの意味論を「範囲リクエスト」に変更し、選択された表現の一部のみの転送を要求することができる
- リクエストメッセージのフレーミングは使用されるメソッドに依存しないが、
  GETリクエストで受信されるコンテンツには一般的に定義された意味論はなく、
  リクエストの意味やターゲットを変更することはできない
  - GETリクエストで受信されるコンテンツは、リクエストスマグリング攻撃の可能性 ([HTTP/1.1] 11.2) があるため
    一部の実装ではリクエストを拒否して接続を閉じる原因となり得る
  - [SHOULD NOT] クライアントはそのようなリクエストが目的を持ち、適切にサポートされることを事前に示した
    オリジンサーバに対する直接的なGETリクエストでない限り、GETリクエストにコンテンツを含めるべきではない
  - [SHOULD NOT] オリジンサーバは、コンテンツの受信に関してプライベートな合意に依存すべきではない
    - HTTP通信の参加者がリクエストチェーン上の中継サーバを認識していないことが多いため
- GETリクエストへのレスポンスはキャッシュ可能
  - [MAY] キャッシュは、`Cache-Control`ヘッダフィールドで別途指定されていない限り、
    後続のGET / HEADリクエストを満たすためにレスポンスを使用できる [CACHING] 5.2
- GETを用いたフォームのクエリフィールドなど、ユーザ提供情報からターゲットURIを構築するメカニズムを用いて
  情報取得を行う場合、URI内で開示することが適切ではない潜在的に機密性の高いデータが提供される可能性がある
  - 場合によってそのような情報が公開されないようにデータをフィルタリングまたは変換することができる
  - レスポンスをキャッシュするメリットがない場合などは、GETではなくPOSTメソッドを使用することにより、
    そのような情報をターゲットURIの一部ではなくリクエストコンテンツとして送信することができる

#### HEAD
- [MUST] HEADメソッドはサーバがレスポンスに内容 (ボディ) を送信してはならない点以外はGETと同じ
  - HEADメソッドは、選択された表現に関するメタデータを取得するために用いられるが、その表現データは転送しない
  - これは多くの場合、ハイパーテキストリンクのテストや最近の更新の有無を確認する目的で用いられる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/HEAD
    - リソースのメタデータをヘッダ (GETメソッドが使用された場合にサーバが送信するであろうもの) の形で要求する
- [SHOULD] サーバは、HEADリクエストへのレスポンスとして、リクエストメソッドがGETだった場合と
  同じヘッダフィールドを送信すべき
  - [MAY] サーバは、コンテンツの生成時にのみ値が決定されるヘッダフィールドを省略してもよい
    - e.g. 一部のサーバは、GETへの動的レスポンスを最小限のデータが生成されるまでバッファリングすることで、
      小さなレスポンスをより効率的に区切ったり、コンテンツの選択に関する決定を後で行うようにしている。
      このようなGETレスポンスには、HEADレスポンスでは生成されない`Content-Length`フィールドや`Vary`フィールドなどが
      含まれる場合がある。
      - HEADは通常効率性を重視してリクエストされるため、これらの軽微な不整合は、
        HEADリクエストでコンテンツを生成して破棄するよりも望ましい
- リクエストメッセージのフレーミングは使用されるメソッドに依存しないが、
  HEADリクエストで受信されるコンテンツには一般的に定義された意味論はなく、
  リクエストの意味やターゲットを変更することはできない
  - HEADリクエストで受信されるコンテンツは、リクエストスマグリング攻撃の可能性 ([HTTP/1.1] 11.2) があるため
    一部の実装ではリクエストを拒否して接続を閉じる原因となり得る
  - [SHOULD NOT] クライアントはそのようなリクエストが目的を持ち、適切にサポートされることを事前に示した
    オリジンサーバに対する直接的なHEADリクエストでない限り、HEADリクエストにコンテンツを含めるべきではない
  - [SHOULD NOT] オリジンサーバは、コンテンツの受信に関してプライベートな合意に依存すべきではない
    - HTTP通信の参加者がリクエストチェーン上の中継サーバを認識していないことが多いため
- HEADリクエストへのレスポンスはキャッシュ可能
  - [MAY] キャッシュは、`Cache-Control`ヘッダフィールドで別途指定されていない限り、
    後続のHEADリクエストを満たすためにレスポンスを使用できる [CACHING] 5.2
    - HEADレスポンスは、以前にキャッシュされたGETレスポンスにも影響を与える可能性がある [CACHING] 4.3.5

#### POST
- POSTメソッドは、リクエストに含まれる表現を、対象リソース固有の意味論に従って処理するよう要求する
  - HTMLフォームに入力されたフィールドなどのデータのまとまりをデータ処理プロセスに提供する
  - 掲示板、ニュースグループ、メーリングリスト、ブログ、あるいはそれに類する記事群にメッセージを投稿する
  - オリジンサーバによってまだ識別されていない新しいリソースを作成する
  - 既存のリソース表現にデータを追加する など
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/POST
    - サーバにデータを送信する
    - リクエストの本体の型は`Content-Type`ヘッダで示される
    - 冪等ではない
- オリジンサーバはPOSTリクエストの処理結果に応じ、適切なステータスコードを選択することでレスポンスの意味論を示す
  - POSTへのレスポンスとして、この仕様で定義されているステータスコードのほぼすべてが受信される可能性がある
    - 例外: 206 Partial Content、304 Not Modified、416 Range Not Satisfiable
- [SHOULD] POSTリクエストの処理に成功した結果としてオリジンサーバ上に1つ以上のリソースが作成された場合、
  オリジンサーバは作成された主リソースの識別子を提供する`Location`ヘッダフィールドと、
  新しいリソースを参照しながらリクエストの状態を記述する表現を含む201 Createdレスポンスを送信すべき
- POSTリクエストに対するレスポンスは、明示的な鮮度情報 ([CACHING] 4.2.1) と
  POSTのターゲットURIと同じ値を持つ`Content-Location`ヘッダフィールドが含まれている場合にのみキャッシュ可能
  - キャッシュされたPOSTレスポンスは後続のGETリクエストまたはHEADリクエストを満たすために再利用できる
  -POSTは潜在的に安全ではないため、キャッシュされたPOSTレスポンスでPOSTリクエストを満たすことはできない [CACHING] 4
- [MAY] POSTの処理結果が既存リソースの表現と等価になる場合、
  オリジンサーバは`Location`フィールドに既存リソースの識別子を指定した303 See Other レスポンスを送信することで
  ユーザエージェントをそのリソースにリダイレクトしてもよい
  - メリット) ユーザエージェントにリソース識別子を提供し、共有キャッシュに適した方法で表現を転送できる
  - デメリット) ユーザエージェントが既にその表現をキャッシュしていない場合、追加のリクエストが発生する

#### PUT
- PUTメソッドは対象リソースの状態を、リクエストメッセージの内容に含まれる表現によって定義された状態へ
  作成または置換することを要求する
  - 特定の表現に対するPUTが成功した場合、同じ対象リソースに対してGETすると
    同等の表現が200 OKレスポンスで送信されることが示唆される
    - ただし対象リソースは他のユーザエージェントによって並行して処理される可能性があり、
      後続のGETを受信する前にオリジンサーバによって動的処理される可能性があるため、
      このような状態変化が観測可能であるという保証はない
      - レスポンスの成功はオリジンサーバによる処理時にユーザエージェントの意図が達成されたことのみを意味する
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/PUT
    - 新しいリソースを作成するか、指定したリソースの表現をリクエストのコンテンツで置き換える
    - 冪等である
- [MUST] 対象リソースに現在の表現が存在せず、PUTによって表現が正常に作成された場合、
  オリジンサーバはユーザエージェントに201 Created レスポンスを送信して通知しなければならない
- [MUST] 対象リソースに現在の表現が存在し、その表現が包含された表現の状態に従って正常に変更された場合、
  オリジンサーバはリクエストの正常完了を示すために200 OK または204 No Content レスポンスを送信しなければならない
- [SHOULD] オリジンサーバは、PUT表現が対象リソースに対して設定された制約と一致していることを確認する必要がある
  - e.g. オリジンサーバがURIに基づいてリソースの表現メタデータを決定する場合、オリジンサーバは
    成功したPUTリクエストで受信したコンテンツがそのメタデータと一致していることを確認する必要がある
    - [SHOULD] PUT表現が対象リソースと一致しない場合、オリジンサーバは
      表現を変換するかリソース設定を変更することによって両者を一致させるか、
      表現が不適切である理由を説明するのに十分な情報を含む適切なエラーメッセージで応答する必要がある
      - 後者の場合は409 Conflict か415 Unsupported Media Type (Content-Type 値の制約に固有) ステータスコードが推奨
- e.g. ターゲットリソースの`Content-Type`が常に`text/html`に設定されており、
  PUTされる表現の`Content-Type`が`image/jpeg`である場合、オリジンサーバは次のいずれかを行う必要がある
  - ターゲットリソースを新しいメディアタイプに合わせて再構成する
  - PUT表現をリソースのフォーマットと整合するフォーマットに変換してから、新しいリソース状態として保存する
  - ターゲットリソースが`text/html`に制限されていることを示す415 Unsupported Media Type を返してリクエストを拒否
    - このレスポンスには新しい表現に適した別のリソースへのリンクが含まれている可能性がある
- HTTPはユーザエージェントのリクエストの意図とオリジンサーバのレスポンスの意味論によって表現できる範囲を超えて、
  PUTメソッドがオリジンサーバの状態にどのような影響を与えるかを正確に定義していない
  - HTTP経由で提供されるインターフェースを超えて、リソースがどのようなものであるかも定義していない
  - リソースの状態がどのように保存されるか、リソースの状態の変化に応じてそのような保存がどのように変化するか、
    オリジンサーバがリソースの状態を表現に変換する方法も定義していない
  - 一般的に、リソースインターフェースの背後にある実装の詳細は、サーバによって意図的に隠蔽されている
    - これはヘッダフィールドとトレーラフィールドの保存方法にも当てはまる
      - `Content-Type`などの一般的なヘッダフィールドは通常保存され、後続のGETリクエストで返されるが、
        ヘッダフィールドとトレーラフィールドの処理はリクエストを受信したリソースに固有であるため、
        オリジンサーバは、PUT リクエストで受信した認識できないヘッダフィールドとトレーラフィールドを無視するべき
        (リソース状態の一部として保存しないべき)
- [MUST NOT] オリジンサーバは、リクエストの表現データがコンテンツにいかなる変換も適用されずに保存され
  (= リソースの新しい表現データがPUTリクエストで受信したコンテンツと同一であり) 、
  検証子フィールドの値が新しい表現を反映している場合を除き、
  PUTへの成功レスポンスに`ETag`や`Last-Modified`フィールドなどの検証子フィールドを送信してはならない
  - これによりユーザエージェントは、送信した (メモリに保持している) 表現がPUTの結果であることを認識でき、
    オリジンサーバーから再度取得する必要がなくなる
  - レスポンスで受信した新しい検証子は将来の条件付きリクエストで使用でき、誤って上書きされることを防ぐことができる
- POSTメソッドとPUTメソッドの根本的な違いは、含まれる表現の意図の違いによる
  - POSTリクエストにおける対象リソースは、含まれる表現をリソース自身の意味論に従って処理することを意図している
  - PUTリクエストにおける対象リソースは、含まれる表現をリソースの状態を置き換えるものとして定義している
    - したがってPUTの意図は冪等であり、中継サーバにも可視的
    - ただし、正確な効果はオリジンサーバーのみが認識する
- PUTリクエストを適切に解釈するには、ユーザエージェントがどのターゲットリソースが要求されているかを
  認識していることが前提となる
  - [SHOULD] 状態変更リクエストを受信した後、クライアントに代わって適切なURIを選択するサービスは、
    PUTメソッドではなくPOSTメソッドを使用して実装する必要がある
  - [MUST] オリジンサーバが要求されたPUTによる状態変更をターゲットリソースに適用せず、
    別のリソースに適用したい場合 (リソースが別のURIに移動された場合など) 、
    オリジンサーバーは適切な3xx Redirectレスポンスを送信しなければならない
  - [MAY] ユーザエージェントは、リクエストをリダイレクトするかどうかを独自に判断できる
- ターゲットリソースに適用されたPUTリクエストは、他のリソースに副作用をもたらす可能性がある
  - e.g. 「現在のバージョン」を識別するURIがあり、個々のバージョンを識別する別URI群が存在する場合、
    「現在のバージョン」へのPUTは、新しいバージョンリソースを生成しつつ対象リソースを変更し、
    関連リソース間のリンクを追加するなど
- 一部のオリジンサーバーは、部分的なPUTを実行するためのリクエスト修飾子として
  `Content-Range`ヘッダフィールドの使用をサポートしている
- PUTメソッドへのレスポンスはキャッシュできない
  - 成功したPUTがキャッシュを通過し、そのキャッシュがターゲットURIのレスポンスを保持している場合、
    それらは無効化される ([CACHING] 4.4)

#### DELETE
- DELETEメソッドは、オリジンサーバに対し、ターゲットリソースとその現在の機能との関連付けを削除するよう要求する
  - 以前に関連付けられていた情報の削除を期待するのではなく、オリジンサーバのURIマッピングに対する削除操作を表す
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/DELETE
    - 指定されたリソースを削除するようサーバに依頼する
- ターゲットリソースが1つ以上の現在の表現を持つ場合、
  オリジンサーバによってそれらが破棄されるかされないか、また関連付けられたストレージが再利用されるかされないかは、
  リソースの性質とオリジンサーバによる実装に完全に依存する
  - 同様に、データベース接続やゲートウェイ接続など、リソースの他の実装要素もDELETEの結果として
    非アクティブ化またはアーカイブ化される必要がある場合がある
    - 一般的にオリジンサーバは、削除を実行するための規定のメカニズムを持つリソースに対してのみ
      DELETEを許可するものと想定される
- DELETEメソッドを許可するリソースは比較的少数であり、
  主な用途はユーザーがその効果について何らかの指示を与えられるリモートオーサリング環境である
  - e.g. PUTリクエストを使用して以前に作成されたリソースや、
    POSTリクエストに対する201 Created レスポンスの後の`Location`ヘッダフィールドで識別されたリソースは、
    対応するDELETEリクエストによってそれらの操作を取り消すことができる
    - 同様に、リモート操作にHTTPを使用するリビジョン管理クライアントなど、
      オーサリング機能を実装するカスタムユーザーエージェント実装では、
      サーバのURI空間がバージョンリポジトリに対応するように作成されているという前提に基づいて
      DELETEメソッドを使用する場合がある
- [SHOULD] DELETEメソッドが正常に適用された場合、オリジンサーバは以下のステータスコードを送信するべき:
  - 操作が成功する可能性が高いものの、まだ実行されていない場合: 202 Accepted
  - 操作が実行され、それ以上の情報が提供される必要がない場合: 204 No Content
  - 操作が実行され、レスポンスメッセージにステータスを示す表現が含まれている場合: 200 OK
- リクエストメッセージのフレーミングは使用されるメソッドに依存しないが、
  DELETEリクエストで受信されるコンテンツには一般的に定義された意味論はなく、
  リクエストの意味やターゲットを変更することはできない
  - DELETEリクエストで受信されるコンテンツは、リクエストスマグリング攻撃の可能性 ([HTTP/1.1] 11.2) があるため
    一部の実装ではリクエストを拒否して接続を閉じる原因となり得る
    - [SHOULD NOT] 事前にそのようなリクエストが目的を持ち十分にサポートされることを
      オリジンサーバが示している場合を除き、DELETEリクエストにコンテンツを生成すべきではない
    - [SHOULD NOT] オリジンサーバは、コンテンツの受信に関してプライベートな合意に依存すべきではない
      - HTTP通信の参加者がリクエストチェーン上の中継サーバを認識していないことが多いため
- DELETEメソッドへのレスポンスはキャッシュできない
  - 成功したDELETEがキャッシュを通過し、そのキャッシュがターゲットURIのレスポンスを保持している場合、
    それらは無効化される ([CACHING] 4.4)

#### CONNECT
- CONNECTメソッドは受信者に対し、リクエストターゲットで識別される宛先オリジンサーバへのトンネルを確立するよう
  要求する
  - トンネルの確立に成功した場合はそれ以降、トンネルが閉じられるまで双方向のデータを透過的に転送する
  - トンネルは一般的に1つ以上のプロキシを経由するend-to-endの仮想接続を作成するために使用され、
    TLS ([TLS13]) によって保護される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/CONNECT
    - プロキシに対して、宛先サーバーへのHTTPトンネルの確立をリクエストする
- CONNECTメソッドは、このメソッドに固有の特別な形式のリクエストターゲットを使用する
  - `トンネルの宛先となるホスト名:ポート番号`
  - デフォルトのポート番号は存在しない
  - [MUST] クライアントはポート番号が省略された権限コンポーネントを含むURI参照に基づくCONNECTリクエストであっても、
    ポート番号を送信しなければならない

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com
```

- [MUST] サーバは空または無効なポート番号をターゲットとするCONNECTリクエストを拒否しなければならない
  - 通常は400 Bad Request ステータスコードで応答する
- CONNECTはHTTP 接続のリクエスト／レスポンスの性質を変更するため、
  特定のHTTPのバージョンにおいてはその意味論をプロトコルのワイヤ形式へマッピングする方法が異なる場合がある
- CONNECTはプロキシへのリクエストとして使用されることを目的とする
  - 受信者は、リクエストターゲットで識別されたサーバへ直接接続するか、
    別のプロキシを使用するように設定されている場合はCONNECTリクエストを次の上流プロキシに転送することで、
    トンネルを確立することができる
  - [MAY] オリジンサーバはCONNECTを受け入れる場合もある
    - ほとんどのオリジンサーバはCONNECTを実装していない
- CONNECTに対する2xxレスポンスは、送信者およびすべての上流プロキシが、
  レスポンスヘッダセクションの直後から即座にトンネルモードへ切り替えることを示す
  - ヘッダセクション以降に受信されるデータは、リクエストターゲットで識別されたサーバからのもの
  - 成功以外のレスポンスは、トンネルがまだ形成されていないことを示す
- トンネルのいずれか一方が接続を閉じたことを中継者が検出した時点でトンネルは閉じられる
  - [MUST] 中継者は、閉じられた側から届いていた未送信データを可能な限り反対側へ送信してから両方の接続を閉じ、
    未配送のまま残っているデータを破棄しなければならない
- トンネルを作成する権限を確立するために、プロキシ認証が使用される場合がる

```
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

- 任意のサーバへのトンネルを確立することには、特に宛先がWebトラフィック用ではない既知のTCPポート
  または予約済みのTCPポートである場合重大なリスクを伴う
  - e.g. `example.com:25`へのCONNECTは、プロキシがSMTPトラフィック用の予約済みポートに接続することを示唆する
    - 許可された場合、プロキシがスパムメールを中継してしまう可能性がある
  - [SHOULD] CONNECTをサポートするプロキシは、その使用を既知のポートの集合や
    安全なリクエストターゲットの設定可能なリストに制限することが推奨される
- [MUST NOT] サーバはCONNECTに対する2xx Successfulレスポンスにおいて、
  `Transfer-Encoding`や`Content-Length`を送信してはならない
  - [MUST] クライアントはCONNECTに対する2xx Successfulレスポンスで受信した
    `Transfer-Encoding`や`Content-Length`をを無視しなければならない
- CONNECTリクエストメッセージにはコンテンツは存在しない
- CONNECTリクエストのヘッダセクション以降に送信されるデータの解釈は、使用されているHTTPのバージョンに依存する
- CONNECTメソッドに対するレスポンスはキャッシュ不可

#### OPTIONS
- OPTIONSメソッドは、オリジンサーバまたは中継サーバにおいて、
  ターゲットリソースに対して利用可能な通信オプションに関する情報を要求する
  - このメソッドにより、クライアントはリソースへの操作を暗示することなく、
    リソースに関連付けられたオプションや要件、あるいはサーバーの能力を特定できる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/OPTIONS
    - 指定されたURLまたはサーバの許可されている通信オプションをリクエストする
- リクエスト対象が`*`の場合、特定のリソースではなくサーバー全体に適用される
  - サーバの通信オプションは通常リソースに依存するため、`*`リクエストは`ping`や`no-op`タイプのメソッドとしてのみ
    有用であり、クライアントがサーバーの能力をテストすること以外には何も行わない
    - e.g. プロキシのHTTP/1.1への準拠をテストするために使用する
- リクエスト対象が`*`でない場合、対象リソースとの通信時に利用可能なオプションに適用される
- [SHOULD] OPTIONSに対して2xx レスポンスを生成するサーバは、サーバが実装しており、
  対象リソースに適用されるオプション機能を示すヘッダフィールド (e.g. `Allow`) を送信すべきである
  - 本仕様で定義されていない潜在的な拡張機能も含む
- レスポンスのコンテンツには、通信オプションを機械可読形式または人間が読める形式で記述することもできる
  - このような表現の標準形式は本仕様では定義されていないが、HTTPの将来の拡張によって定義される可能性がある
- クライアントはOPTIONSリクエストに`Max-Forwards`ヘッダフィールドを送信できる
  - リクエストチェーン内の特定の受信者を対象とするため
  - [MUST NOT] プロキシはリクエストが`Max-Forwards`フィールドと共に受信されない限り、
    リクエストを転送する際に`Max-Forwards`ヘッダフィールドを生成してはならない
- [MUST] コンテンツを含むOPTIONSリクエストを生成するクライアントは、
  表現メディアタイプを記述する有効な`Content-Type`ヘッダフィールドを送信しなければならない
  - 本仕様では、このようなコンテンツの使用法は定義されていない
- OPTIONSメソッドへのレスポンスはキャッシュできない

#### TRACE
- TRACEメソッドは、リクエストメッセージを対象として、
  リモート側でアプリケーションレベルのループバックを行うよう要求する
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods/TRACE
    - 対象とするリソースへのパスに沿ってメッセージのループバック検査を実行する
- [SHOULD] リクエストの最終受信者は、受信したメッセージを、200 OK レスポンスのコンテンツとしてクライアントに返す
  - その実現方法の一つが`message/http`形式 ([HTTP/1.1] 10.1)
  - 最終受信者とは、オリジンサーバかリクエスト内の`Max-Forwards`の値が0になった最初のサーバのいずれか
- [MUST NOT] クライアントは、レスポンスによって開示される可能性のある機密データを含むフィールドを
  TRACEリクエスト内に生成してはならない
  - e.g. ユーザエージェントが保存されているユーザ認証情報やCookie [COOKIE] など
  - [SHOULD] リクエストの最終受信者は、レスポンスのコンテンツを生成する際に、
    機密データを含む可能性のあるリクエストフィールドを除外する必要がある
- TRACEを使用すると、クライアントはリクエストチェーンの反対側で何が受信されているかを確認し、
  そのデータをテストや診断情報に利用できる
  - `Via`ヘッダフィールドの値は、リクエストチェーンの経路を示す痕跡として機能する
  - `Max-Forwards`ヘッダフィールドで、クライアントはリクエストチェーンの長さを制限できる
    - これは無限ループでメッセージを転送するプロキシチェーンをテストする際に役立つ
- [MUST NOT] クライアントはTRACE リクエストでコンテンツを送信してはならない
- TRACEメソッドへのレスポンスはキャッシュできない

## Message Context https://www.ietf.org/rfc/rfc9110.html#name-message-context
### Request Context Fields
リクエストの文脈に関する追加情報を提供するヘッダフィールド群
(ユーザ、ユーザエージェント、ならびにリクエストの背後にあるリソースに関する情報など)

- `Expect`
- `From`
- `Referer`
- `TE`
- `User-Agent`

#### Expect
- `Expect`リクエストヘッダフィールドは、このリクエストを適切に処理するために
  サーバが期待される特定の動作 (expectation) を示す
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Expect
    - クエストを正しく扱うためにサーバーが実行する必要があると期待されていることを示す
    - 仕様書で定義されている期待は`Expect: 100-continue`だけ
      - ヘッダに含まれている情報で、直ちに成功とする条件を満たしているのであれば100
      - 期待に沿うことができなければ417 Expectation Failed、それ以外であれば他の4xx

```
Expect =      #expectation
expectation = token [ "=" ( token / quoted-string ) parameters ]
```

- `Expect`フィールド値は大文字と小文字を区別しない
- この仕様で定義されているexpectationは`100-continue`のみ
- [MAY] `100-continue`以外の要素を含む`Expect`フィールド値を受信したサーバは、
  expectationを満たせなかったことを示すため、417 Expectation Failed ステータスコードを返してもよい
- `100-continue`は、クライアントがこのリクエストで (おそらく大きな) コンテンツを送信しようとしており、
  メソッド、ターゲットURI、ヘッダフィールドだけでは
  ただちに成功、リダイレクト、エラーレスポンスを返すことができない場合は
  100 Continue 中間レスポンスを返すことを希望していることを相手に通知する
  - これにより、クライアントは実際にコンテンツを送信する前に、
    コンテンツを送信する価値があるという指示を待つことができる
    - これにより、データが膨大な場合や、クライアントがエラーが発生する可能性が高いと予測する場合の効率が向上する
      - 以前に検証された認証情報を使用せずに、状態を変更するメソッドを初めて送信する場合など

```
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

このようなリクエストでは、
クライアントがパイプに不要なデータ転送を開始する前に、
オリジンサーバは401 Unauthorized や405 Method Not Allowed などのエラーメッセージを即座に返す
```

- クライアントへの要件:
  - [MUST NOT] コンテンツを含まないリクエストで`100-continue`のexpectationを生成してはならない
  - [MUST] リクエストコンテンツを送信する前に100 Continue レスポンスを待つ場合、
    `100-continue`のexpectationを含む`Expect`ヘッダフィールドを送信しなければならない
  - `100-continue`のexpectationを送信する場合、特定の時間を待機する必要はない
    - [MAY] このような場合は、レスポンスをまだ受信していなくてもコンテンツの送信を続行してもよい
    - [SHOULD NOT] 100 Continue レスポンスはHTTP/1.0中継サーバを経由して送信できないため、
      このような場合はコンテンツの送信前に無期限に待機すべきではない
    - [SHOULD] `100-continue`expectationを含むリクエストへのレスポンスとして
      417 Expectation Failed ステータスコードを受信した場合は、
      そのexpectationを除いて同じリクエストを再送すべき
      - これは417を返したレスポンスチェーンがexpectation非対応であることを示しているに過ぎないため
        - e.g. HTTP/1.0 サーバを経由しているなど
- サーバへの要件:
  - [MUST] HTTP/1.0リクエストで`100-continue`expectationを受信した場合、そのexpectationを無視しなければならない
  - [MAY] 対応するリクエストのコンテンツの一部またはすべてを既に受信している場合、
    またはフレーミングによってコンテンツが存在しないことが示される場合、
    100 Continue レスポンスの送信を省略してもよい
  - [MUST] 100 Continue レスポンスを送信する場合、リクエストコンテンツを受信し処理した後、
    接続が途中で切断されない限り、最終的に最終ステータスコードを送信しなければならない
  - [SHOULD] リクエストコンテンツ全体を読み取る前に最終ステータスコードで応答する場合、
    接続を閉じるか リクエストコンテンツの読み取りを継続するかを示すべき
  - [MUST] HTTP/1.1~でメソッド、ターゲットURI、完全なヘッダセクションを含み、
    `100-continue`expectationとコンテンツが続くことを示すリクエストを受信したオリジンサーバは:
    - メソッド、ターゲットURI、ヘッダフィールドのみを調べることでステータスを判断できる場合は
      最終ステータスコードを含むレスポンスを即座に送信する
    - そうでなければ即時の100 Continue レスポンス (リクエストコンテンツの送信をクライアントへ促すため)
  - [MUST NOT] オリジンサーバは、100 Continue レスポンスを送信する前にコンテンツを待ってはならない
- プロキシへの要件
  - [MUST] HTTP/1.1~でメソッド、ターゲットURI、完全なヘッダセクションを含み、
    `100-continue`expectationとコンテンツが続くことを示すリクエストを受信したプロキシは:
    - メソッド、ターゲットURI、ヘッダーフィールドのみを調べることでステータスを判断できる場合は
      最終ステータスコードを含むレスポンスを即座に送信する
    - それ以外の場合は、対応するリクエストラインおよびヘッダセクションを次の上流サーバへ転送する
  - [MAY] (設定または過去のやり取りから) 次の受信サーバがHTTP/1.0のみをサポートしていると判断した場合、
    クライアントに対してコンテンツの送信を開始するよう促すため、即時に100 Continue レスポンスを生成してもよい

#### From
- `From`リクエストヘッダフィールドは、
  リクエストを送信するユーザエージェントを制御している人間のユーザのインターネット電子メールアドレスを含む
  - このアドレスは[RFC5322] 3.4 の`mailbox`の定義に従い、機械が使用できるものでなければならない
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/From
    - リクエスト元のuser agentを制御する人のユーザのEメールアドレスが含まれる
    - ロボティックユーザエージェント (クローラなど) を使用している場合は、`From`ヘッダを送信する必要がある

```
From    = mailbox
mailbox = <mailbox, see [RFC5322], Section 3.4>
```

```
From: spider-admin@example.org
```

- 非ロボット型ユーザーエージェントが`From`ヘッダフィールドを送信することはほとんどない
  - [SHOULD NOT] ユーザのプライバシー保護やサイトのセキュリティポリシーに抵触する可能性があるため、
    ユーザーが明示的に設定しない限り、ユーザエージェントは`From`ヘッダフィールドを送信すべきではない
- [SHOULD] ロボット型ユーザエージェントは、サーバ上で問題が発生した場合に、ロボットの実行責任者に連絡が取れるよう、
  有効な`From`ヘッダフィールドを送信すべき
  - e.g. ロボットが過剰なリクエスト、不要なリクエスト、無効なリクエストを送信している場合など
- [SHOULD NOT] サーバは`From`ヘッダフィールドをアクセス制御や認証に使用すべきではない
  - その値はリクエストを受信または監視するすべてのユーザに表示されることが想定されており、
    プライバシーを期待せずにログファイルやエラーレポート内に記録されることが多いため

#### Referer
- `Referer`リクエストヘッダフィールドは、ユーザエージェントがターゲットURIを取得した
  元 (参照元) のリソースを示すためのURI参照を指定する
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Referer
    - 現在リクエストされているページへのリンク先を持った直前のウェブページのアドレス
- [MUST NOT] ユーザエージェントは、`Referer`フィールド値に
  URI参照 [URI] のフラグメント要素およびユーザ情報要素を含めてはならない

```
Referer = absolute-URI / partial-URI
```

- `Referer`フィールド値は絶対URIまたは部分URIのいずれか
  - 部分URIの場合、参照されるURIはターゲットURI ([URI] 5) 基準とした相対URIとして解釈される
- `Referer`ヘッダフィールドは、サーバが簡易的な分析、ログ記録、キャッシュ最適化などのために
  他のリソースへのバックリンクを生成したり、古くなったリンクやタイプミスされたリンクを保守のために発見するのに有用
  - 一部のサーバでは、他のサイトからのリンクを拒否したり、CSRFを制限したりするために`Referer`を使用するが、
    すべてのリクエストに`Referer`が含まれているわけではない

```
Referer: http://www.example.org/hypertext/Overview.html
```

- [MUST] 参照元のURIを持たないソースからターゲットURIを得た場合 (e.g. ユーザのキーボード入力、ブックマークエントリ)
  ユーザエージェントは`Referer`ヘッダフィールドを除外するか、値として`"about:blank"`を送信しなければならない
- [MAY] `Referer`ヘッダフィールド値として参照元リソースの完全なURIを含む必要はない
  - [MAY] ユーザエージェントは、参照元のオリジン以外の部分を切り詰めてもよい
- `Referer`は、リクエストのリクエストコンテキストやユーザの閲覧履歴に関する情報を漏えいさせる可能性がある
  - 参照元リソースの識別子が個人情報や機密扱いとされるリソースを明示する場合など
  - 多くの汎用ユーザエージェントは、参照元リソースがローカルのfileやdata URIである場合、`Referer`を送信しない
  - [SHOULD NOT] 参照元リソースがセキュアプロトコルでアクセスされ、
    リクエストの送信先と参照元リソースが異なるオリジンである場合ユーザエージェントは`Referer`を送信すべきではない
    - 参照元リソースが明示的に`Referer`ヘッダーフィールドの送信を許可している場合を除く
  - [MUST NOT] 参照元リソースがセキュアなプロトコルでアクセスされた場合、
    ユーザーエージェントはセキュアでないHTTPリクエストで`Referer`を送信してはならない
- 一部の中継者は送信リクエストから無差別に`Referer`を削除することがある
  - これによってCSRF攻撃に対する保護を阻害するという副作用が発生することがある
  - 中継者やユーザエージェント拡張機能において`Referer`における情報漏洩を制限したい場合は、
    内部ドメイン名を仮名に置き換えたり、クエリやパスコンポーネントを切り詰めるなどの限定的な変更にとどめるべき
  - [SHOULD NOT] `Referer`の値がターゲットURIと同じスキームとホストを共有している場合、
    中継者は`Referer`ヘッダフィールドを変更または削除すべきではない

#### TE
- `TE`リクエストヘッダフィールドは、転送コーディングとトレーラセクションに関するクライアントの能力を記述する
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/TE
    - ユーザエージェントが受け入れる転送エンコーディング方式を指定する (別名`Accept-Transfer-Encoding`)
- リクエストで`trailers`メンバを含む`TE`ヘッダフィールドが送信された場合、
  クライアントがトレーラを受け取っても破棄しない意図を示す
  - ただし処理をするとは言っていない
- HTTP/1.1においては、クライアントがレスポンスで受け入れ可能な転送コーディングをサーバに通知する用途で用いられる
  - 転送コーディングを使用するのはHTTP/1.1のみ [HTTP/1.1] 7
- `TE`フィールド値はメンバのリストであり、`trailers`を除く各メンバは、
  転送コーディング名のトークンと、その転送コーディングに対するクライアントの相対的な優先度を示すオプションの重み、
  転送コーディングに対する任意のパラメータで構成される

```
TE                 = #t-codings
t-codings          = "trailers" / ( transfer-coding [ weight ] )
transfer-coding    = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

- [MUST] `TE`の送信者は、中継者にこのフィールドを転送しないよう通知する必要がある
  - そのため、`Connection`ヘッダフィールド内に`TE`接続オプションを必ず送信しなければならない

#### User-Agent
- `User-Agent`リクエストヘッダフィールドは、リクエストを発信したユーザエージェントに関する情報を含む
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のユーザエージェントの制限を回避したりそれに合わせてレスポンスを調整するため
  - ブラウザやOSの利用状況に関する分析のため などの目的でサーバによって利用される
  - [SHOULD] ユーザエージェントは設定で無効化されていない限り、各リクエストに`User-Agent`を送信することが推奨される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/User-Agent
    - 受信者がアプリケーション、OS、ベンダー、リクエストしているユーザエージェントのバージョン等を
      識別できるようにする特性文字列

```
User-Agent = product *( RWS ( product / comment ) )
```

- `User-Agent`フィールド値は1つ以上の`product`識別子と、それぞれに続く0個以上のコメントで構成される
  - それらを合わせてユーザエージェントのソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例的に、`product`識別子は、ユーザエージェントを特定する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
product         = token ["/" product-version]
product-version = token
```

- [SHOULD] 送信者は生成する`product`識別子、製品を識別するために必要な最小限の情報に限定すべき
  - [MUST NOT] 送信者は`product`識別子内に広告やその他の不要な情報を生成してはならない
  - [SHOULD NOT] 送信者は`product-version`にバージョン識別子ではない情報を含めるべきではない

```
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

- [SHOULD NOT] ユーザエージェントは、不必要に詳細な情報を含む`User-Agent`ヘッダーフィールドを生成すべきでない
  - [SHOULD] 第三者によるサブプロダクトの追加も制限すべき
    - 過度に長く詳細な`User-Agent`値はリクエストの遅延を増大させ、ユーザが望まない形で識別されるリスクを高める
  - 同様に、実装は他の実装との互換性を宣言する目的で他の実装の`product`トークンを使用しないよう推奨される
    - このフィールドの目的を損なうため
    - ユーザエージェントが別のユーザエージェントを装う場合、
      受信者はそのユーザーがその識別されたユーザーエージェント向けに調整されたレスポンスを
      意図的に望んでいると見なすことができる
      - それが実際に使用されているユーザーエージェントにとって最適に動作しない場合であっても同様

### Response Context Fields
レスポンスの文脈に関する追加情報を提供するヘッダフィールド群
(サーバ、対象リソース情報、ならびに関連リソースに関する情報など)

- `Allow`
- `Location`
- `Retry-After`
- `Server`

#### Allow
- `Allow`レスポンスヘッダフィールドは、対象リソースがサポートしていると宣言されているメソッドの集合を指定する
  - リソースに関連付けられた有効なリクエストメソッドを受信者に通知するために使用される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Allow
    - あるリソースが対応しているメソッドの一覧を示す

```
Allow = #method
```

```
Allow: GET, HEAD, PUT
```

- 実際に許可されるメソッドの集合は、各リクエストの時点においてオリジンサーバによって定義される
- [MUST] オリジンサーバは405 Method Not Allowed レスポンスにおいて`Allow`ヘッダフィールドを生成しなければならない
  - [MAY] それ以外のレスポンスで`Allow`を生成してもよい
- `Allow`フィールド値が空である場合、そのリソースがいかなるメソッドも許可していないことを示す
  - 設定によりリソースが一時的に無効化されている場合など
- [MUST NOT] プロキシは`Allow`ヘッダフィールドを変更してはならない
  - プロキシは示されているすべてのメソッドを理解する必要はなく、
    一般的なメッセージ処理規則に従ってそれらを取り扱うことができればよい

#### Location
- `Location`レスポンスヘッダフィールドは一部のレスポンスにおいて、
  レスポンスに関連する特定のリソースを参照するために使用される
  - リクエストメソッドとステータスコードの意味論の組み合わせによってその関連の意味が定義される
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Location
    - リダイレクト先のURLを示す
    - 3xx Redirection または201 Created を返すときのみ意味を成す
      - リダイレクトの場合、 HTTPメソッドは元のメソッドとリダイレクトの種類によって、
        `Location`で示されたページにアクセスする新しいリクエストを生成するために使用される
    - `Content-Location`ヘッダはコンテンツネゴシエーションが行われたときに、
      リソースへアクセスできる直接的なURLを指し、
    - `Location`はレスポンスに関連付けられ、
      `Content-Location` (コンテンツネゴシエーションの結果、リソースへアクセスできる直接的なURLを指す) は
      返されるエンティティに関連付けられる

```
Location = URI-reference
```

- フィールド値は1つのURI参照から構成される
  - 相対参照 ([URI] 4.2) の形式の場合、最終的な値はターゲットURI ([URI] 5) に対して解決することで算出される
- 201 Created レスポンスにおける`Location`値は、そのリクエストによって作成されたプライマリリソースを指す
- 3xx Redirection レスポンスにおける`Location`値は、リクエストをリダイレクトするための優先ターゲットリソースを指す
  - 3xx Redirection レスポンスで指定された`Location`値にフラグメント要素が存在しない場合、
    ユーザエージェントはその値がターゲットURIを生成するために用いられたURI参照のフラグメント要素を継承するとして
    リダイレクトを処理しなければならない (元の参照にフラグメントが含まれていればそれを引き継ぐ)
    - `Location`値にフラグメント識別子を含めるのが適切でない状況も存在する
      - e.g. 201 Created レスポンスにおける`Location`は、作成されたリソースに固有のURIを提供することになっている
- 注: 一部の受信者は有効なURI参照ではない`Location`ヘッダフィールドから値の復元を試みることがある
  - 本仕様ではそれを義務付けたり定義していないが、堅牢性の観点から許容している
  - 実装間での相互運用性はない
- 注: `Content-Location`は`Location`とは異なり、同封されている表現に対応する最も具体的なリソースを指す
  - レスポンスには`Location`と`Content-Location`の両方が含まれる場合がある

#### Retry-After
- `Retry-After`レスポンスヘッダフィールドはユーザーエージェントが後続のリクエストを送るまでに待機するべき時間を示す
  - 503 Service Unavailable レスポンスとともに送信される場合は、
    クライアントがそのサービスを利用できないと予想される時間を示す
  - 3xx Redirection レスポンスとともに送信される場合は、
    リダイレクトされたリクエストを発行するまでに、ユーザエージェントが最低限待つべき時間を示す
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Retry-After
    - ユーザーエージェントがフォローアップリクエストを行う前にどれくらい待つべきかを示す
      - 503 Service Unavailable: サービスが利用できないと予想される時間
      - 429 Too Many Requests: 新しいリクエストを行うまで待機する時間
      - 301 Moved Permanently + リダイレクト:
        - リダイレクトされたリクエストを発行する前にユーザエージェントが待機するように要求される最小時間

```
Retry-After   = HTTP-date / delay-seconds ... delay-secondsの値は非負の10進整数。秒単位の時間を表す。
delay-seconds = 1*DIGIT
```

- `Retry-After`フィールド値は、HTTP-date、またはレスポンス受信後に待機すべき秒数のいずれか

```
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120

...待機時間として2分が選択される
```

#### Server
- `Server`レスポンスヘッダフィールドはオリジンサーバがリクエストを処理するために使用するソフトウェアの情報を示す
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のサーバ実装の制限を回避したりそれに合わせてリクエストを調整するため
  - サーバやOSの利用状況に関する分析のため などの目的でクライアントによって利用される
- [MAY] オリジンサーバはレスポンスに`Server`ヘッダフィールドを生成してもよい
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Server
    - リクエストを処理したオリジンサーバ、すなわちレスポンスを生成したサーバで使用されたソフトウェアを説明する

```
Server = product *( RWS ( product / comment ) )
```

- `Server`ヘッダフィールド値は1つ以上の`product`識別子から構成され、それぞれに0個以上のコメントが続く
  - それらを合わせてオリジンサーバソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例として`product`識別子は、オリジンサーバソフトウェアを識別する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
Server: CERN/3.0 libwww/2.17
```

- オリジンサーバは不必要に詳細で粒度の細かい情報を含む`Server`ヘッダフィールドを生成すべきではなく、
  第三者によるサブプロダクトの追加も制限すべき
- 過度に長く詳細な`Server`フィールド値はレスポンス遅延を増大させるだけでなく、内部実装の詳細を露呈し、
  既知のセキュリティホールを攻撃者が見つけて悪用することを容易にしてしまう可能性がある

## HTTP Authentication https://www.ietf.org/rfc/rfc9110.html#name-http-authentication
### Authentication Scheme
- HTTPは拡張可能なチャレンジ・レスポンス型認証スキームの集合をアクセス制御/認証のためのフレームワークとして提供する
- 認証スキームの識別には、大文字・小文字を区別しないトークンが使用される

```
auth-scheme = token
```

### Authentication Parameters
- HTTPの認証方式では、認証スキーム名 (auth-scheme) の後ろに、認証を成立させるために必要な必要な追加情報が続く
- 追加情報の表現形式:
  - カンマ区切りのパラメータ列 `name=value`
  - token68
    - 空白を含まない66個の連続した文字列
    - RFC 4648に準拠するエンコードを想定
    - base64、base64url、base32、base16の各エンコーディングを格納できる
    - パディングのために末尾に任意個の`=`を追加可能

```
token68        = 1*( ALPHA / DIGIT /
                    "-" / "." / "_" / "~" / "+" / "/" ) *"="
```

- 認証パラメータ (`auth-param`) は`名前=値`の組であり、 各パラメータ名は1つのチャレンジにつき1回だけ出現しなければならない
  - 名前トークンは大文字・小文字を区別せずに比較される
  - パラメータ値はtokenまたはquoted-stringのいずれかで表現できる
    - 認証スキームの定義は、送信者・受信者の双方において、token / quoted-string両方の表記を受け入れる必要がある
    - 後方互換性のため、認証スキームの定義は送信者側の形式をどちらかに制限してもよい

```
auth-param     = token BWS "=" BWS ( token / quoted-string )
```

### Challenge and Response
- 401 Unauthorized レスポンスは、オリジンサーバからユーザエージェントの認可を要求 (チャレンジ) する際に使用される
  - 401は要求されたリソースに適用できるチャレンジを含む`WWW-Authenticate`ヘッダフィールドを含む
- 407 Proxy Authentication Required レスポンスは、プロキシがクライアントの認可を要求するために使用される
  - 407は要求されたリソースに対してプロキシに適用可能なチャレンジを含む`Proxy-Authenticate`ヘッダフィールドを含む

```
challenge = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- オリジンサーバに対して自身を認証したい
- ユーザエージェントはオリジンサーバに対して自身を認証したい場合、
  リクエストに`Authorization`ヘッダフィールドを含めることによって認証情報を送信できる
- ユーザエージェントはプロキシに対して自身を認証したい場合、
  リクエストに Proxy-Authorization ヘッダーフィールドを含めることで認証情報を送信できる

### Credentials
- `Authorization`フィールド / `Proxy-Authorization`フィールドは過去または直前にレスポンスを受け取った
  認証チャレンジに基づくクライアント資格情報 (credentials) を送るためのもの
- ユーザエージェントは自身が理解できるものの中で最も安全だと判断した認証スキームを選択するべき
- ヘッダフィールド値として資格情報を送信することは、接続の機密性に関して重大なセキュリティ上の考慮事項を伴う

```
credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- オリジンサーバは保護されたリソースへの不正なリクエストを受信した場合、
  要求されたリソースに適用可能な1つ以上のチャレンジを含む`WWW-Authenticate`ヘッダフィールドを伴って
  401 Unauthorized レスポンスを送信することが推奨される
  - 資格情報が省略されている、無効な資格情報が含まれている、資格情報が不完全である など
  - プロキシが同様の不正なリクエストを受信した場合、
    当該プロキシが適用可能な1つ以上のチャレンジを含む`Proxy-Authenticate`ヘッダフィールドを伴って
    407 Proxy Authentication Required レスポンスを生成することが 推奨される
- サーバは受信した資格情報がアクセス権限として不十分である場合、403 Forbidden レスポンスを送信することが望ましい
- HTTPはアクセス認証をこの仕様で定義するチャレンジ・レスポンスの枠組みに限定しない
  - トランスポート層での認証、メッセージのカプセル化、追加のヘッダフィールドによって認証情報を指定するなど、
    他の仕組みを用いることもできる
  - ユーザ認証のための独自メカニズムは、認証に関連するトークンの受け渡しに
    `Set-Cookie`および`Cookie`ヘッダフィールドを使用する

### Establishing a Protection Space (Realm)
- `realm`パラメータは認証が適用される保護の範囲を示すための識別子
- **保護空間（protection space）**は、サーバのオリジン (スキーム + ホスト + ポート) + realm値によって定義される
  - realmによって同一サーバ内を複数の保護空間に分割でき、それぞれが独自の認証スキームと認可データベースを持てる
  - realm値は文字列
    - 通常はオリジンサーバによって割り当てられる
    - 認証スキーム固有の追加的な意味を持つことがある
    - 同一の認証スキームであっても異なるrealmを持つ複数のチャレンジがレスポンスに含まれる場合がある
- 保護空間は、資格情報 (credentials) を自動的に適用できる範囲を決定する
- あるリクエストがすでに認可されている場合、ユーザエージェントは、認証スキーム、パラメータ、ユーザ設定によって
  定められた一定期間、その保護空間内の他のすべてのリクエストに同じ資格情報を再利用してもよい
- 保護空間の範囲 (資格情報が自動適用され得るリクエストの範囲) は、追加情報がない限り
  クライアントにとって必ずしも既知ではない
  - 認証スキームは、保護空間の範囲を記述するパラメータを定義することがある
  - 認証スキームによって明示的に許可されない限り、そのサーバのスコープ外に保護空間が広がることない
- サーバはrealm値としてquoted-string構文のみを生成しなければならない
- クライアントはtokenとquoted-string の両方の構文をサポートする必要がある場合がある (歴史的経緯)

### Authenticating Users to Origin Servers
#### WWW-Authenticate
- `WWW-Authenticate`レスポンスヘッダフィールドは、対象リソースに適用可能な認証スキームおよびそのパラメータを示す

```
WWW-Authenticate = #challenge
```

- 401 Unauthorized レスポンスを生成するサーバは、
  1つ以上のチャレンジを含む`WWW-Authenticate`ヘッダーフィールドを送信しなければならない
- サーバは資格情報を提示することでレスポンスが変わり得ることを示すため、
  他のレスポンスメッセージにおいても`WWW-Authenticate`ヘッダフィールドを生成してよい
- レスポンスを転送するプロキシは、そのレスポンス内の`WWW-Authenticate`ヘッダフィールドを変更してはならない
- ユーザエージェントは、このフィールド値の解析に特に注意を払うことが勧告される
  - フィールド値には複数のチャレンジが含まれる可能性がある
  - 各チャレンジはカンマ区切りの認証パラメータのリストを含み得る
  - このヘッダフィールド自体が複数回出現することもある

```
同一フィールド行に複数のメンバを含むWWW-Authenticateフィールド値を送信すると、相互運用性が損なわれる可能性がある

WWW-Authenticate: Basic realm="simple",             -- Basicスキームのチャンレンジ
                  Newauth realm="apps",             -- Newauth realmスキームのチャレンジ
                  type=1, title="Login to \"apps\"" -- 追加のパラメータ
```

#### Authorization
- `Authorization`リクエストヘッダフィールドは、ユーザエージェントがオリジンサーバに対して自身を認証するもの
- 通常は401 Unauthorized レスポンスを受信した後に送信される
- フィールド値は要求されているリソースのrealmに対するユーザエージェントの認証情報を含む資格情報から構成される

```
Authorization = credentials
```

- リクエストが認証され、realmが指定されている場合、同じ資格情報はそのrealm内の他のすべてのリクエストに対して
  有効であると推定される (認証スキーム自体が別途要件を課していない場合)
- リクエストを転送するプロキシは、そのリクエスト内の`Authorization`ヘッダフィールドを変更してはならない

#### Authentication-Info
- `Authentication-Info`レスポンスフィールドヘッダはクライアントの認証情報が受理された後にサーバが返す追加情報を示す
  - サーバ認証情報を含むサーバからの最終確認メッセージなどが含まれることがある
- フィールド値は`auth-param`構文を用いたパラメータ (名前=値の組) のリスト
  - 個々のパラメータは`Authentication-Info`を使用する各認証スキーム自身によって定義される

```
Authentication-Info = #auth-param
```

- `Authentication-Info`はリクエストメソッドやステータスコードに依存せず、任意のHTTPレスポンスで使用できる
  - その意味論は対応するリクエストの`Authorization`ヘッダフィールドによって示される認証スキームによって定義される
- レスポンスを転送するプロキシは、`Authorization`値をいかなる形でも変更してはならない
- 認証スキームが明示的に許可している場合はトレーラフィールドとしても送信することができる

### Authenticating Clients to Proxies
#### Proxy-Authenticate
- `Proxy-Authenticate`はプロキシがクライアントに対して認証を要求するためのレスポンスヘッダフィールド
  - このリクエストに対してプロキシが適用可能な認証スキーム / パラメータを示す1つ以上のチャレンジから構成される
  - プロキシは自身が生成する407 Proxy Authentication Required レスポンスごとに、
    1つ以上の`Proxy-Authenticate`ヘッダフィールドを送信しなければならない

```
Proxy-Authenticate = #challenge
```

- `WWW-Authenticate`と異なり、`Proxy-Authenticate`はレスポンスチェーン上の次の外向きクライアントにのみ適用される
  - 通常は特定のプロキシを選択したクライアントだけがそのプロキシに対する認証に必要な資格情報を保持しているため
- `Proxy-Authenticate`にも`WWW-Authenticate`と同じ解析上の注意点が適用される

#### Proxy-Authorization
- `Proxy-Authorization`リクエストヘッダフィールドは、クライアントがプロキシに対して資格情報を送るためのもの
  - 認証を要求するプロキシに対してクライアントが自身を識別するために使用する
- フィールド値は要求されているリソースのプロキシとrealmに対する、クライアントの認証情報を含む資格情報から構成される

```
Proxy-Authorization = credentials
```

- `Authorization`とは異なり、`Proxy-Authorization`は
  `Proxy-Authenticate`ヘッダフィールドによって認証を要求した次の内向きプロキシにのみ適用される
- 複数のプロキシがチェーンとして使用されている場合、
  `Proxy-Authorization`は資格情報の受信を期待している最初の内向きプロキシによって消費される
- プロキシは、複数のプロキシが協調して特定のリクエストを認証する仕組みである場合に限り、
  クライアントリクエストから受け取った資格情報を次のプロキシへ中継してもよい

#### Proxy-Authentication-Info
- `Proxy-Authentication-Info`レスポンスヘッダフィールドは、プロキシ認証上`Authentication-Info`と同等の役割を持つ
  - その意味論は対応するリクエストの`Proxy-Authorization`ヘッダフィールドによって示される
    認証スキームによって定義される

```
Proxy-Authentication-Info = #auth-param
```

- `Authentication-Info`と異なり、`Proxy-Authentication-Info`は
  レスポンスチェーン上の次の外向きクライアントにのみ適用される
  - 通常は特定のプロキシを選択したクライアントだけがそのプロキシ認証に必要な資格情報を保持しているため
- 認証スキームが明示的に許可している場合はトレーラフィールドとしても送信することができる

## Content Negotiation https://www.ietf.org/rfc/rfc9110.html#name-content-negotiation
- レスポンスがボディを返す際、オリジンサーバはしばしばその情報を表現する複数の形式、言語、エンコーディングを持つ
  - ユーザやユーザエージェントもまた、それぞれに利用可能な能力が異なる
 - そのため、HTTP には コンテンツネゴシエーションのための仕組みが用意されている
- プロトコル上可視化されるコンテンツネゴシエーションのパターン定義:
  - "proactive" negotiation ("server-driven" negotiation)
    - ユーザエージェントが明示した嗜好 (preferences) に基づいて、サーバが表現を選択する方式
  - "reactive" negotiation
    - サーバが複数の表現の一覧を提示し、その中からユーザエージェントが表現を選択する方式
  - "request content" negotiation ("agent-driven" negotiation)
    - サーバが過去のレスポンスで示した嗜好に基づき、ユーザエージェントが将来のリクエストで表現を選択する方式
  - その他のコンテンツネゴシエーションパターン
    - 条件付きコンテンツ ("conditional content")
      - 表現が複数の部分から構成され、ユーザエージェントのパラメータに基づいて選択的に描画される方式
    - アクティブコンテンツ ("active content")
      - 表現自体にスクリプトが含まれ、ユーザエージェントの特性に応じて追加のリクエストを行う方式
    - 透過的コンテンツネゴシエーション ("Transparent Content Negotiation")
      - 中継者がコンテンツ選択を行う方式
- パターンは相互に排他的ではなく、それぞれ適用可能性や実用性の面で異なるトレードオフを持つ
- HTTP自体はリソースの意味論を理解しない
- オリジンサーバが時間の経過やコンテンツネゴシエーションの様々な軸にわたり、
  どの程度一貫してレスポンスを返すか、時間を通じて観測されるリソース表現の同一性 (sameness) がどう保たれるかは、
  レスポンスを選択または生成する主体やアルゴリズムに完全に依存する

### Proactive Negotiation
- ユーザエージェントが自身のコンテンツネゴシエーションの嗜好をリクエスト内に記述して送信することにより、
  サーバが自らのアルゴリズムに準じて好ましい表現を選択する
- サーバはレスポンスとして利用可能な表現と、リクエストで提供された情報を比較する
  - リクエスト内にはネゴシエーション用リクエストヘッダフィールド、クライアントのネットワークアドレス、
    `User-Agent`フィールドの一部などが含まれる
- サーバ側で完結できるため、サーバが初回レスポンスでユーザエージェントにとって最適な表現を返すことができれば
  追加リクエストが不要
  - サーバの推測精度向上のため、ユーザエージェントは自身の嗜好を記述するリクエストヘッダフィールドを送信してよい
- Proactive Negotiationに対するレスポンスには`Vary`ヘッダフィールドが含まれることが多い
  - その表現がどのリクエスト要素に依存して選択されたかを明示するため
- ユーザエージェントがレスポンスボディについてProactive Negotiationを行うため
  `Accept`、`Accept-Charset`、`Accept-Encoding`、`Accept-Language`リクエストヘッダフィールドが利用される
  - これらは対象リソースの表現、エラー・処理状態の表現、プロトコル内に現れる付随テキスト文字列に適用される

#### Proactive Negotiationの欠点
- 特定のユーザにとっての最適 (ユーザエージェントの特性、レスポンスの利用目的) をサーバ側で判断することが不可能
- ユーザエージェントがすべてのリクエストで自身の能力を記述することは非効率、かつ潜在的なプライバシーリスクもある
- オリジンサーバの実装やリクエストに対するレスポンス生成アルゴリズムが複雑になる
- 共有キャッシュにおけるレスポンスの再利用性を低下させる
- ユーザエージェントの嗜好が常に尊重されるわけではない
  - オリジンサーバが対象リソースに対してProactive Negotiationを実装していない場合
  - オリジンサーバが406 Not Acceptable を返すよりも嗜好に一致しないレスポンスを返す方が適切だと判断した場合

### Reactive Negotiation
- ステータスコードの種類にかかわらず、最初のレスポンスを受け取った後にユーザエージェントがコンテンツの選択を行う
  - サーバは代表的な表現を一つ返したり、代替表現への参照の一覧を返したりする
- ユーザエージェントが最初のレスポンス内容に満足しない場合、
  代替リソースの一つまたは複数に対してGETリクエストを行い、別の表現を取得できる
  - 代替表現の選択方法として、ユーザエージェントが自動的に行なったり、ユーザが手動操作で選択したりすることがある
- サーバは代替表現の一覧以外には初期表現を送信しないことにより、ユーザエージェントによるReactive Negotiationを
  優先する意図を示すことができる
  - 300 Multiple Choices や406 Not Acceptable ステータスコードを伴うレスポンスでは、
    利用可能な表現に関する情報が代替案として提示され、ユーザまたはユーザエージェントが選択できる
- レスポンス表現が型・言語・エンコーディングなどの次元で変化し得る場合、
  オリジンサーバがリクエストからユーザエージェントの能力を判断できない場合、
  公開キャッシュを利用してサーバ負荷を分散しネットワーク使用量を削減するような場合に有利

#### Reactive Negotiationの欠点
- 代替案の一覧をユーザエージェントに送信する必要があり、それをヘッダ部で送る場合にはユーザ体感の遅延が増大する
- 別の表現を取得するために2回目のリクエストが必要になる

### Request Content Negotiation
- サーバのレスポンス内でコンテントネゴシエーションに関する嗜好を送信する
  - そのリソースに対する将来のリクエストにおいて、適切なコンテントの選択に影響を与えることを意図しているため
  - e.g `Accept`や`Accept-Encoding`ヘッダフィールドをレスポンスに含めることにより、
    そのリソースに対する将来のリクエストにおいて、推奨されるメディアタイプやコンテントコーディングを示す

### Content Negotiation Field Features
#### Absence
- リクエストがコンテントネゴシエーション用のヘッダフィールドを含まない場合、送信者は嗜好を持たないことを意味する
- リクエストはコンテントネゴシエーション用のヘッダーフィールドが含むが、
  その条件に基づいて受け入れ可能と見なせる表現が一つも存在しない場合、オリジンサーバは次のいずれかを選択できる:
  - ヘッダフィールドを尊重して、406 Not Acceptable レスポンスを送信する
  - ヘッダフィールドを無視して、そのリクエストに関しては当該ヘッダフィールドによる
    コンテントネゴシエーションの対象ではないものとしてレスポンスを生成する
    - クライアントがその表現を実際に利用できることが保証されるわけではない。

#### Quality Values
- コンテントネゴシエーション用ヘッダーフィールドは、共通のパラメータとして`q` (大文字小文字を区別しない) を用いる
  - `q`は対応するコンテント種別に対する嗜好の相対的な重みを指定する (quality value、qvalue)
  - 重みは0-1の範囲の実数に正規化される
    - 0.001が最も低く、1が最も高い
    - 0は受け入れ不可
    - 指定されていない場合、デフォルトの重みは1
    - 小数点以下3桁を超えて生成してはならない

```
weight = OWS ";" OWS "q=" qvalue
qvalue = ( "0" [ "." 0*3DIGIT ] )
       / ( "1" [ "." 0*3("0") ] )
```

#### Wildcard Values
- コンテントネゴシエーション用ヘッダフィールドの多くは、未指定の値を選択するワイルドカード値`*`を定義している
  - ワイルドカードが存在しない場合、フィールド内で明示的に記載されていない値は受け入れ不可と見なされる
  - `Vary`においてワイルドカード値は、変化が無制限であることを意味する。

### Content Negotiation Fields
#### Accept
- `Accept`リクエストヘッダフィールドは、レスポンスのメディアタイプに関する嗜好を示す
  - サーバは提案のうちの一つを選択し、それを使用してクライアントに`Content-Type`レスポンスヘッダで選択を伝える
- サーバがレスポンス内で`Accept`を送信する場合、同一リソースへの後続リクエストにおいて
  好ましいコンテントタイプを提供する

```
Accept = #( media-range [ weight ] )

media-range = ( "*/*"
                / ( type "/" "*" )
                / ( type "/" subtype )
              ) parameters
```

- `*`はメディアタイプの範囲をまとめる
  - e.g. `*/*` = すべてのメディアタイプ、`type/*` = そのtypeに属するすべてのsubtype
- `media-range`にはその範囲に適用されるメディアタイプパラメータを含める
  - 各`media-range`には任意でメディアタイプパラメータと、相対的な重みを示す任意の`q`パラメータを付与できる
  - 重みを使用する送信者は、すべての`media-range`パラメータの後ろに`q`を送るべき
    - 受信者はパラメータの順序に関わらず、`q`パラメータを重みとして処理すべき
  - 複数の`media-range`がある場合、最も具体的なものが優先される

```
Accept: audio/*; q=0.2, audio/basic

1. audio/basic (q = 1)
2. audio/* (q = 0.2)
```

```
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c

1. text/html, text/x-c (q = 1)
2. text/x-dvi (q = 0.8)
3. text/plain (q = 0.5)
```

```
Accept: text/*, text/plain, text/plain;format=flowed, */*

1. text/plain;format=flowed
2. text/plain
3. text/*
4. */*
```

#### Accept-Charset
- `Accept-Charset`リクエストヘッダフィールドは、テキスト形式のレスポンスボディにおける文字集合に関する嗜好を示す

```
Accept-Charset = #( ( token / "*" ) [ weight ] )
```

- 文字集合名は Section 8.3.2 で定義されている。
- ユーザエージェントは、各文字集合に`q`を指定することで相対的な優先度を示してもよい

```
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

- `*`はフィールド内で他に明示されていないすべての文字集合に一致する
- `Accept-Charset`は非推奨
  - UTF-8がほぼ普遍的に使用されるようになったため
  - 一般的なユーザエージェントの多くは、特別に設定されていない限り`Accept-Charset`を送信しない

#### Accept-Encoding
- `Accept-Encoding`リクエストヘッダフィールドは、レスポンスとして受け入れ可能なコンテントコーディングを示す
- サーバがレスポンス内で`Accept-Encoding`を送信する場合は、同一リソースに対する後続リクエストにおいて
  好ましいコンテントコーディングに関する情報を提供する
  - `identity`トークンは、エンコードを行わないことが望ましい場合を示すために使用される

```
Accept-Encoding  = #( codings [ weight ] )
codings          = content-coding / "identity" / "*"
```

- `codings`値に品質値 (weight) を指定できる
- `*`はフィールド内で明示されていない任意の利用可能なコンテントコーディングに一致する

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

- サーバはある表現に対するコンテントコーディングが受け入れ可能かどうかを、以下の規則で判定する:

```
1. リクエストにAccept-Encodingヘッダフィールドが存在しない場合、
   すべてのコンテントコーディングが受け入れ可能
2. 表現にコンテントコーディングが付与されていない場合、
   Accept-Encodingによって明示的に identity;q=0 または *;q=0 が示されていない限り、デフォルトで受け入れ可能
3. 表現のコンテントコーディングがAccept-Encodingに列挙されている場合
   q値が0でない限り受け入れ可能 (q=0は「受け入れ不可」を意味する)
4. コーディングが同一目的を達成する代替手段として扱われる場合、
   0でないq値の中で最も高いものが優先される
```

- `Accept-Encoding`ヘッダフィールドが存在し、かつフィールド値が空である場合、
  ユーザエージェントはレスポンスにいかなるコンテントコーディングも望んでいないことを意味する
- リクエストに空でない`Accept-Encoding`ヘッダフィールドが存在し、
  利用可能な表現がいずれも受け入れ可能なコンテントコーディングを持たない場合、
  オリジンサーバは、`identity`コーディングが受け入れ不可とされていない限り、
  コーディングなしのレスポンスを送るべき
- レスポンスに含まれている`Accept-Encoding`ヘッダーフィールドは
  そのリクエストにおいて、リソースが受け入れることを許容していたコンテントコーディングを示す
    - 評価方法はリクエストの場合と同じ
- `Accept-Encoding`の持つ情報は当該リクエストに固有であり、同一サーバ上の他のリソースでは異なる場合があり、
  時間経過やリクエストの他の要素に依存して変化し得る
- サーバが未対応のコンテントコーディングを理由にリクエストを失敗させる場合、
  415 Unsupported Media Type  ステータスで応答し、そのレスポンスに`Accept-Encoding`を含めるべき
  - これにより、クライアントはコンテントコーディングに起因する問題とメディアタイプに起因する問題を区別できる
  - コンテントコーディングと無関係な理由で415を返す場合、サーバは`Accept-Encoding`を含めてはならない
- `Accept-Encoding`の最も一般的な使用例:
  - クライアントが楽観的にコンテントコーディングを使用した結果、415 Unsupported Media Type が返される
  - 将来のやり取りを最適化する目的で、コンテントコーディングがサポートされていることをクライアントに示す利用
  - リクエスト内容が圧縮を正当化するほど大きかったにもかかわらずクライアントが圧縮を行わなかった場合、
    リソースは2xxレスポンスに`Accept-Encoding`を含めることがある

#### Accept-Language
- `Accept-Language`リクエストヘッダフィールドは、レスポンスにおける自然言語の嗜好を示す

```
Accept-Language = #( language-range [ weight ] )
language-range  = <language-range, see [RFC4647], Section 2.1>
```

- `language-range`値に品質値 (weight) を指定でき、当該言語範囲に対するユーザの相対的な嗜好度を表す

```
Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

- 受信者は言語タグの記載順を優先度の降順として解釈することがあるが、その挙動に依存することはできない
- 多くのユーザエージェントは品質値をすべて異なる値として明示的に設定しつつ、品質の高い順に列挙する
- 言語のマッチングについては複数の方式が定義されている ([RFC4647] Section 3)
  - 実装は要件に応じて最適な方式を選択できる
- `Accept-Language`にユーザ言語嗜好を送信することにより、ユーザのプライバシー期待に反する可能性がある
- 可読性・理解可能性はユーザ個人に大きく依存するため、
  ユーザエージェントは言語嗜好をユーザ自身が制御できる手段（を提供する必要がある
  - 制御手段を提供しないユーザエージェントは`Accept-Language`ヘッダフィールドを送信してはならない

#### Vary
- `Vary`レスポンスヘッダフィールドは、メソッドや対象URI以外で
  どのリクエスト要素がレスポンスボディの選択に影響した可能性があるかを示す

```
Vary = #( "*" / field-name )
```

- `Vary`値は、ワイルドカード`*`またはselecting header fieldsと呼ばれるリクエストヘッダフィールド名の一覧
  - メンバとして`*`を含むリストは、リクエストメッセージ構文の外的要素 (クライアントのネットワークアドレスなど) を
    含め、他の要因がレスポンス表現の選択に関与した可能性があることを示す
- プロキシは`Vary`に`*`を生成してはならない

```
Vary: accept-encoding, accept-language

(オリジンサーバがこのレスポンスボディを選択する際、
 リクエストのAccept-EncodingおよびAccept-Languageヘッダーフィールドを考慮した可能性があることを示す)
```

- `Vary`の用途:
  - キャッシュ受信者への通知
    - 列挙されたヘッダフィールドの値が元のリクエストと同一でない場合、
      このレスポンスを後続リクエストの応答として使用してはならないことを示す ([CACHING] Section 4.1)
    - オリジンサーバはキャッシュ可能なレスポンスを後続リクエストで選択的に再利用させたい場合、
      `Vary`を生成すべき (`Accept-Language`などのselecting header fieldsに基づいてレスポンスボディを調整した場合)
    - `Vary`がキャッシュ性能に与える影響の方が大きいとオリジンサーバが判断する場合、`Vary`を省略してもよい
  - ユーザエージェントへの通知
    - このレスポンスがコンテントネゴシエーションの結果であり、列挙されたヘッダフィールドに異なる値を指定した場合、
      別の表現が返され得ることを示す (Proactive Negotiation)
- `Authorization`フィールド名を`Vary`に含める必要はない
- レスポンスボディがネットワーク地域に依存して選択され、オリジンサーバが地域を越えた再利用を許可したい場合は
  その差異を`Vary`に含める必要はない

## Conditional Requests https://www.ietf.org/rfc/rfc9110.html#name-conditional-requests
- 条件付きリクエスト (conditional request) とは、ターゲットリソースに対してリクエストメソッドを適用する前に、
  評価される前提条件を示すリクエストヘッダフィールドを1つ以上含むHTTPリクエストのこと
- 条件付きGETリクエストは、HTTP キャッシュを更新するための最も効率的な仕組み
- 条件付きリクエストは、PUTやDELETEのような状態変更を伴うメソッドにも適用できる
  - 並行して動作しているクライアントの作業を別のクライアントが誤って上書きするlost update問題を防ぐために利用される

### Preconditions
- サーバはリクエストを実行するかどうかを判断する際、
  現在のターゲットリソースが、クライアントが最後に知っている状態から変わっていない場合にのみ実行したい
- 前提条件は、当該リクエストを実行してよいかどうかをサーバが判断するための条件
- 前提条件 (precondition) は、通常対象リソース全体の状態 (現在の値の集合)
  または以前に取得した表現で観測された状態 (その集合内の1つの値) に対して定義される
- リソースが複数の現在表現を持っていても、同一リクエストは安定的に同一表現に対応付けられることを前提とする
- 前提条件はターゲットリソースの過去の表現から得られた検証子集合 (`ETag`や`Last-Modified` など ) と
  選択された表現に対する現在の検証子状態を比較して評価される
- 他の仕様で拡張フィールドとして定義される前提条件は、
  すべての受信者、ターゲットリソース全般の状態、リソース群に対して条件を課す場合がある
- 前提条件は以下の場合にのみ拡張可能
  - 未知であっても安全に無視できる場合 (e.g. `If-Modified-Since`)
  - 特定のユースケースで配備が前提とできる場合
  - ターゲットリソースの別の性質によって実装が示される場合

#### If-Match
- `If-Match`リクエストヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースがクライアントの知っているままの状態であれば実行してよい」
    - フィールド値が`*`の場合に、オリジンサーバがターゲットリソースの現在表現を1以上保持している
    - フィールド値に列挙されたETagのいずれかと一致する現在表現を保持している
- オリジンサーバは`If-Match`におけるETagの比較において、強い比較 (strong comparison) 関数を使用しなければならない
  - クライアントはその前提条件を、表現データに何らかの変更があった場合にメソッド適用を防ぐ目的で用いているため

```
If-Match = "*" / #entity-tag
```

```
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
```

- `If-Match`は複数のユーザエージェントが同一リソースに対して並行して操作する可能性がある場合、
  意図しない上書きを防ぐため、POST・PUT・DELETEなどの状態変更メソッドとともに使用されることが最も多い
  - 一般には表現の選択や変更を伴う任意のメソッドにおいて、
    選択された表現の現在のETagが`If-Match`の値に含まれていない場合にリクエストを中止する目的で使用できる
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Match`が含まれている場合、
  メソッドを実行する前に、`If-Match`条件を評価しなければならない。
  - フィールド値が`*`の場合: ターゲットリソースに現在表現が存在すればtrue
  - フィールド値がETagのリストの場合: いずれかのタグが選択された表現のETagと一致すればtrue
  - それ以外の場合: false
- オリジンサーバは`If-Match`条件がfalseと評価された場合、要求されたメソッドを実行してはならない
  - 代わりに412 Precondition Failed ステータスコードで条件付きリクエストの失敗を示してもよい
  - リクエストが状態変更操作であり、かつその変更がすでに選択された表現に適用済みであるように見える場合には
    2xxステータスコードで応答してもよい
    - 変更リクエストがすでに適用済みと判断できる場合に成功レスポンスを返すことは効率的であるが、
      協調しない複数のユーザエージェントがよく似た更新を行う場合リスクがある
- クライアントはGETリクエストに`If-Match`を送信し、
  選択された表現が一致しない場合に412 Precondition Failed を受け取りたい意思を示すことができる
  - 新しい表現を望む場合には`If-Range`の方が適している
- キャッシュや中継者は`If-Match`を無視してもよい
- `*`と他の値を同一リスト内に含む`If-Match`ヘッダフィールドは構文的に無効であり、生成してはならない

#### If-None-Match
- `If-None-Match`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースがクライアントの指定したETagと同じ状態ではなければ実行してよい」
    - フィールド値が`*`の場合、受信側のキャッシュ/オリジンサーバがターゲットリソースの現在表現を保持していないこと
    - 選択された表現のETagがフィールド値に列挙されたいずれのETagとも一致しないこと
- `If-None-Match`におけるETagの比較において、受信者は弱い比較 (weak comparison) 関数を使用しなければならない
  - 表現データに変更があった場合でも、弱いETagがキャッシュ検証に使用され得るため

```
If-None-Match = "*" / #entity-tag
```

```
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
```

- `If-None-Match`は主に条件付きGETリクエストで使用され
  - 最小限の通信オーバーヘッドでキャッシュ済み情報を更新するため
- クライアントがETagを持つ1つ以上の保存済みレスポンスを更新したい場合、
  GETリクエストにおいて、それらのエンティティタグを列挙した`If-None-Match`ヘッダフィールドを生成するべき
  - このときサーバは、保存済みレスポンスのいずれかが選択された表現と一致する場合304 Not Modified を返すことができる
- `If-None-Match`は、値として`*`を用いることにより、unsafeなリクエストメソッド (e.g. PUT) が
  クライアントの想定に反して既存の表現を変更してしまうことを防ぐ目的にも使用できる
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-None-Match`が含まれている場合、
  メソッドを実行する前に、`If-None-Match`条件を評価しなければならない
  - フィールド値が`*`の場合: ターゲットリソースに現在表現が存在すればfalse
  - フィールド値がETagのリストの場合: 列挙されたいずれかのタグが、選択された表現のETagと一致すればfalse
  - それ以外の場合: 条件はtrue
- オリジンサーバは、`If-None-Match`条件がfalseと評価された場合、要求されたメソッドを実行してはならない
  - 代わりに以下のいずれかで応答しなければならない:
    - リクエストメソッドがGETまたはHEADの場合: 304 Not Modified
    - それ以外のメソッドの場合: 412 Precondition Failed
- `If-None-Match`を受信した場合のキャッシュの取り扱いに関する要件は、[CACHING] Section 4.3.2 で定義されている
- `*`と他の値を同一リスト内に含む`If-None-Match`ヘッダフィールドは構文的に無効であり、生成してはならない

#### If-Modified-Since
- `If-Modified-Since`ヘッダフィールドは、GETまたはHEADリクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースが指定した日時より新しく変更されていたら実行してよい」
    - 選択された表現の最終更新日時が、フィールド値で指定された日時より新しい場合
  - 表現データが変更されていない場合は、その転送が回避される

```
If-Modified-Since = HTTP-date
```

```
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

- サーバは以下の場合、`If-Modified-Since`を無視しなければならない
  - リクエストに`If-None-Match`が含まれている場合
    - `If-None-Match`の条件は`If-Modified-Since`よりも正確な代替と見なされる
    - 両者を併用するのは`If-None-Match`を実装していない古い中継者との相互運用のために限られる
    - フィールド値が有効なHTTP-dateでない場合
    - フィールド値に複数の値が含まれている場合
    - リクエストメソッドがGET/HEAD以外の場合
    - リソースに最終更新日時が存在しない場合
- 受信者は`If-Modified-Since`の日時をオリジンサーバの時計に基づいて解釈しなければならない
- `If-Modified-Since`の主な用途:
  - ETagを持たないキャッシュ表現を効率よく更新すること
    - キャッシュは通常、保存済みメッセージの`Last-Modified`ヘッダフィールド値を使って`If-Modified-Since`を生成する
      - この方法は時計の同期が不十分な場合や、オリジンサーバが完全一致のタイムスタンプのみを尊重する実装において
        相互運用性が高い
      - ただし`Last-Modified`がない場合などには、`Date`や、メッセージ受信時刻を基に生成されることもある
  - 最近変更されたリソースに限定してWebを巡回すること
    - ユーザエージェントは自らの時計や過去のレスポンスで受け取った`Date`ヘッダフィールドを基に
      `If-Modified-Since`を生成する
      - オリジンサーバが選択表現の`Last-Modified`による完全一致のみを採用している場合、
        指定した期間内に変更されたものだけを取得する支援はできない。
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Modified-Since`が含まれ、
  かつ`If-None-Match`が含まれていない場合、メソッド実行前に条件を評価することが望ましい
  - 選択された表現の最終更新日時がフィールド値の日時以前の場合: false
  - それ以外の場合: true
- 条件がfalseと評価された場合、オリジンサーバは要求されたメソッドを実行せず304 Not Modified レスポンスを生成すべき
  - その際、既存キャッシュの識別や更新に有用なメタデータのみを含める
- `If-Modified-Since`を受信した場合のキャッシュの扱いに関する要件は[CACHING] Section 4.3.2 に定義されている

#### If-Unmodified-Since
- `If-Unmodified-Since`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースが指定した日時より新しく変更されていないなら実行してよい」
    - 選択された表現の最終更新日時がフィールド値で指定された日時以前であること
  - 表現のETagを保持していないユーザエージェントに対する`If-Match`と同等の目的を果たす

```
If-Unmodified-Since = HTTP-date
```

```
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

- サーバは以下の場合、`If-Unmodified-Since`を無視しなければならない:
  - リクエストに`If-Match`が含まれている場合
    - `If-Match`の条件の方がより正確な代替と見なされる
    - 両者を併用するのは`If-Match`を実装していない古い中継者との相互運用のために限られる
  - フィールド値が有効なHTTP-dateでない場合
  - リソースに最終更新日時が存在しない場合
- 受信者は、`If-Unmodified-Since`の日時をオリジンサーバの時計に基づいて解釈しなければならない
- `If-Unmodified-Since`は主に状態変更メソッド (e.g. POST、PUT、DELETE) とともに使用される
  - ETagを提供しないリソースに対して複数のユーザエージェントが並行して操作する際の意図しない上書きを防ぐため
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Unmodified-Since`が含まれ、
  かつ`If-Match`が含まれていない場合、メソッド実行前に条件を評価しなければならない
  - 選択された表現の最終更新日時がフィールド値の日時以前の場合: true
  - それ以外の場合: false
- 条件がfalseと評価された場合、オリジンサーバは要求されたメソッドを実行してはならない
  - 代わりに412 Precondition Failed ステータスで条件付きリクエストの失敗を示してもよい
  - リクエストが状態変更操作であり、その変更がすでに選択された表現に適用済みであるように見える場合には、
    2xxステータスで応答してもよい
    - 変更要求がすでに適用済みと判断できる場合に成功応答を返すことは多くの場合効率的だが、
      協調しない複数のユーザエージェントが非常によく似た更新を行う場合にはリスクがある
      そのような場合オリジンサーバはunsafeメソッドに対する前提条件失敗時には常に412を返す方が望ましい
- クライアントはGETリクエストに`If-Unmodified-Since`を送信し、
  選択された表現が変更されていた場合に412を受け取りたい意思を示すこともできる
  - 新しい表現を受け取りたい場合は`If-Range`の方が適している
- キャッシュや中継者は`If-Unmodified-Since`を無視してもよい

#### If-Range
- `If-Range`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバはそのリソースの表現に変更があれば`Range`で要求した部分を返し、なければ表現全体を返してほしい」
    - サーバに対し、検証子が一致しなかった場合に`Range`ヘッダフィールドを無視するよう指示する
    - その結果として412 Precondition Failed を返す代わりに、選択された新しい表現全体を転送させる
- `If-Range`の目的:
  - クライアントが表現の部分的なコピーを保持しており、最新の完全な表現を取得したい場合、
    `Range`ヘッダフィールドと条件付きGET (`If-Unmodified-Since`と`If-Match`のいずれかまたは両方) を併用できる
  - この時、表現が変更されており前提条件が満たされない場合、クライアントは現在の表現全体を取得するために
    リクエストを再送する必要がある
  - `If-Range`はこの「2回目のリクエスト」をショートカットするための仕組み

```
If-Range = entity-tag / HTTP-date

(有効な`entity-tag`と有効な`HTTP-date`は、先頭3文字が`"`かどうかで区別できる)
```

- `If-Range`の制約:
  - クライアントは`Range`ヘッダフィールドを含まないリクエストに`If-Range`を生成してはならない
  - サーバは`Range`を含まないリクエストで受信した`If-Range`を無視しなければならない
  - オリジンサーバは`Range`リクエストをサポートしないリソースに対する`If-Range`を無視しなければならない
- 検証子に関する制約:
  - クライアントは、弱いETagを含む`If-Range`を生成してはならない
  - クライアントは、対応する表現のETagを持っていない場合に限り、HTTP-dateを含む`If-Range`を生成してよい
    - その日時は強い検証子でなければならない (Section 8.8.2.2)
- サーバが`Range`リクエストで`If-Range `を受信した場合、メソッド実行前に条件を評価しなければならない:
  - HTTP-dateを含む`If-Range`の評価方法:
    - 指定されたHTTP-dateが強い検証子でない場合: false
    - 指定されたHTTP-dateが、選択された表現の`Last-Modified`フィールド値と完全一致する場合: true
    - それ以外の場合: false
  - `entity-tag`を含む`If-Range`の評価方法:
    - 指定された`entity-tag`が、強い比較関数 (Section 8.8.3.2) を用いて選択された表現のETag値と完全一致する場合: true
    - それ以外の場合: false
- `If-Range`条件がfalseと評価された場合、受信者は`Range`ヘッダーフィールドを無視しなければならない
  - 条件がtrueである場合、受信者は`Range`ヘッダーフィールドを要求どおり処理すべきである
- `If-Range`の比較は常に完全一致で行われる (HTTP-date の場合も同様)
  - この点で、指定日時以前 `<=` を判定する`If-Unmodified-Since`とは異なる

### Evaluation of Preconditions
#### When to Evaluate
- 条件付きリクエストの前提条件について、受信者 (キャッシュまたはオリジンサーバ) は
  通常のリクエスト検査を正常に完了した後~リクエスト内容を処理する直前、
  またはリクエストメソッドに関連付けられた動作を実行する直前に、受信した前提条件を評価しなければならない
  - 前提条件を含まない同一リクエストに対し、リクエスト内容を処理する前に返されるレスポンスが
    2xxまたは412 Precondition Failed 以外になる場合は受信したすべての前提条件を無視しなければならない
    - リダイレクトや重要な処理を行う前に検出できる失敗は、前提条件の評価よりも優先される
- 対象リソースのオリジンサーバではなく、そのリソースのリクエストに対してキャッシュとしても動作できないサーバは、
  本仕様で定義される条件付きリクエストヘッダフィールドを評価してはならない
  - そのようなサーバはリクエストを転送する場合、それらのヘッダフィールドを転送しなければならない
    - 生成元クライアントが、現在の表現を提供できるサーバによって評価されることを意図しているため
- CONNECT、OPTIONS、TRACE のように表現の選択や変更を伴わないリクエストメソッドで受信した場合、
  サーバは本仕様で定義される条件付きリクエストヘッダーフィールドを無視しなければならない
- プロトコル拡張は、前提条件が評価される条件やその評価結果の扱いを変更し得る
- 条件付きリクエストヘッダフィールドは、HEADメソッドでも使用可能として定義されているが、
  条件付きHEADを送る実用的な意味はほとんどない

#### Precedence of Preconditions
- 1つのリクエストに複数の条件付きリクエストヘッダフィールドが含まれる場合は優先順で評価する
  - lost update防止のための前提条件はキャッシュ検証よりも厳密な要件を持つ
  - キャッシュ検証済みのレスポンスは、部分レスポンスよりも効率的である
  - ETagは日時ベースの検証子よりも正確であると想定されている
- 受信者 (キャッシュまたはオリジンサーバ) は、本仕様で定義される前提条件を、以下の順序で評価しなければならない

1. 受信者がオリジンサーバで、`If-Match`が存在する場合
    - `If-Match`を評価する
      - trueの場合: 3に進む
      - falseの場合: 原則として412 Precondition Failed を返す
        - 状態変更リクエストがすでに成功していると判断できる場合は例外
2. 受信者がオリジンサーバで、`If-Match`が存在せず、`If-Unmodified-Since`が存在する場合
    - `If-Unmodified-Since`を評価する
      - trueの場合: 3 に進む
      - falseの場合: 原則として 412 Precondition Failed を返す
         - 状態変更リクエストがすでに成功していると判断できる場合は例外とする
3. `If-None-Match`が存在する場合
    - `If-None-Match`を評価する
      - trueの場合: 手順5 に進む
      - falseかつGET / HEAD の場合: 304 Not Modified を返す
      - falseかつその他のメソッドの場合: 412 Precondition Failed を返す
4. メソッドがGET/HEADで、`If-None-Match`が存在せず、`If-Modified-Since`が存在する場合
    - `If-Modified-Since`を評価する
      - trueの場合: 5に進む
      - falseの場合: 304 Not Modified を返す
5. メソッドがGETで、`Range`と`If-Range`の両方が存在する場合
    - `If-Range`を評価する
      - trueかつ`Range`が選択された表現に適用可能な場合: 206 Partial Content を返す
      - それ以外の場合: `Range` ヘッダーフィールドを無視して200 OK を返す
6. 上記いずれにも該当しない場合
    - 要求されたメソッドを実行しその成功または失敗に応じたレスポンスを返す

- HTTPに対する拡張仕様で新たな条件付きリクエストヘッダフィールドを定義する場合は、
  RFCで定義されている前提条件や実際に使われ得る他の条件付きフィールドとの評価順序を明確に定義すべき

## Range Requests
- 範囲リクエストはすでに取得済みの一部データを再利用して残りを取得する、
  あるいは大きな表現の一部分だけを取得するための仕組み
- 範囲リクエストの前提:
  - クライアントはリクエストのキャンセルや接続の切断によって、データ転送が途中で中断される状況にしばしば遭遇する
    - クライアントが表現の一部だけを保存している場合、その後のリクエストで表現全体を再転送するのではなく、
      残りの部分だけを取得できることが望ましい
    - 同様にローカルストレージが限られているデバイスでは、大きな表現の一部のみを要求できることが有益な場合がある
- 範囲リクエストはHTTPの任意機能であり、これを実装していない受信者であっても通常のGETリクエストとして応答できる
- 部分レスポンスは完全なレスポンスと混同されないよう、専用のステータスコードによって示される
  - 範囲機能を実装していないキャッシュが、部分レスポンスを誤って完全なレスポンスとして扱ってしまうことを防ぐため

### Range Units (範囲単位)
- 表現データは、そのコンテントコーディングやメディアタイプに固有のアドレス指定可能な構造単位が存在する場合、
  部分範囲 (range unit) へ分割できる
  - e.g. データの先頭または末尾からのオフセットを基準としたバイト範囲を分割部分として識別できる
- range unitの用途:
  - `Accept-Ranges`レスポンスヘッダフィールド: 範囲リクエストをサポートしていることを広告する
  - `Range`リクエストヘッダフィールド: 要求する表現の部分範囲を指定する
  - `Content-Range`レスポンスヘッダフィールド: 転送されている表現のどの部分であるかを記述する

```
range-unit = token
```

- すべての範囲単位名は大文字・小文字を区別しない
- 範囲単位はHTTP Range Unit Registryに登録されることが推奨される
- 範囲単位は拡張可能であることが意図されている

#### Range Specifiers (範囲指定子)
- 範囲は範囲単位 (データ構造の区切り方) と範囲指定子 (どの範囲を要求するか) の集合を組み合わせて表現される
- 範囲単位名は、その指定子に対してどの種類の`range-spec`が適用可能かを決定する
  - 各範囲単位は`int-range`、`suffix-range`、`other-range`をいつ許可するかを定義することが期待されている
- 範囲リクエストは単一の範囲または同一表現内の複数レンジの集合を指定できる

```
ranges-specifier = range-unit "=" range-set (range-unitに対して無効または未定義のrange-specを含む場合は無効)
range-set        = 1#range-spec
range-spec       = int-range
                 / suffix-range
                 / other-range
```

```
(int-range: 2つの非負整数、または 1つの非負整数から表現データの末尾までを表す範囲)

int-range  = first-pos "-" [ last-pos ]
first-pos = 1*DIGIT
last-pos  = 1*DIGIT (last-posがfirst-pos より小さい場合、そのint-rangeは無効)
```

```
(suffix-range: 指定された非負整数の最大長 (範囲単位数) を持つ、表現データの末尾部分を表す)

suffix-range  = "-" suffix-length
suffix-length = 1*DIGIT
```

```
(other-range: ほぼ無制限にアプリケーション固有、または将来のレンジ単位が追加のレンジ指定子を定義できる)

other-range = 1*( %x21-2B / %x2D-7E )
            ; カンマを除く 1*(VCHAR)
```

```
Range: bytes=0-499
Range: bytes=0-499,500-999
```

#### Byte Ranges
- バイト範囲単位は、表現データをバイト列として部分取得するための範囲単位を表現するために用いられる
- 各バイトレンジは、表現データの先頭からのオフセット`int-range`
  または末尾からのオフセット`suffix-range`として表現される
  - `int-range`における`first-pos`は、範囲内の最初のバイトのオフセットを示し、
    `last-pos`は最後のバイトのオフセットを示し、指定されるバイト位置は両端を含む
  - バイトオフセットは0から開始する
- バイトレンジでは`other-range`指定子は使用されない
- 表現データにコンテントコーディングが適用されている場合、
  各バイト範囲はデコード後のバイト列ではなくエンコード後のバイト列に対して計算される
- クライアントは表現のサイズを知らなくても要求するバイト数を制限できる
- `last-pos`が省略されている場合または現在の表現長以上の値である場合、そのバイト範囲は表現の残り全体を意味する
- クライアントは`suffix-range`を用いて、選択された表現の末尾Nバイトを指定できる
  - 表現が指定の`suffix-length`より短い場合は表現全体が用いられる
- GETリクエストにおいて有効なバイトの`range-spec`は、次のいずれかの場合に満たしうる:
  - 選択された表現の現在の長さよりも`first-pos`小さい`int-range`
  - `suffix-length`が0でない`suffix-range`
  - 選択された表現の長さが0の場合GETリクエストで満たしうる`range-spec`は`suffix-length`が0でない`suffix-range`のみ
- バイト範囲構文では`first-pos`、`last-pos`、`suffix-length`は10進数のオクテット数として表現される
- コンテンツ長に事前の上限は定義されていないため、受信者は非常に大きな10進数を想定する必要がある

### Range
- GETリクエストにおける`Range`リクエストヘッダフィールドは、選択された表現データの全体のうち、
  1つ以上の部分範囲を転送するよう要求する

```
Range = ranges-specifier
```

- サーバは`Range`ヘッダフィールドを無視してもよい
  - オリジンサーバおよび中間キャッシュは、可能な限りバイト範囲をサポートすることが望ましい
    - 部分的に失敗した転送からの効率的な回復や、大きな表現の部分取得を可能にするためである
  - サーバは、未認識あるいは範囲処理が定義されていないリクエストメソッドの`Range`を必ず無視しなければならない
    - RFCで範囲処理が定義されているのはGETのみ
  - オリジンサーバは、理解できない範囲単位を含む`Range`を必ず無視しなければならない
  - プロキシは、理解できない範囲単位を含む`Range`を破棄してもよい
  - 範囲リクエストをサポートするサーバは、以下の場合に`Range`を無視または拒否してもよい:
    - 無効な`ranges-specifier`を含む場合
    - 2つを超える重複範囲を含む場合
    - 多数の小さな範囲が昇順で列挙されていない場合
    - ... これらは、壊れたクライアントや意図的なDoS攻撃の兆候である
- クライアントは、同じデータをカバーする単一範囲より処理・転送効率が低くなる複数範囲を要求するべきではない
- 範囲リクエストをサポートするサーバは、選択された表現にコンテンツがない場合、`Range`を無視してよい
- 複数範囲を要求するクライアントは特別な理由がない限り、昇順で列挙するべき
  - 例外: 大きな表現を内部カタログに基づいて処理するユーザエージェントが、後半部分を先に必要とする場合 など
- `Range`は前提条件の評価後に評価され、かつ`Range`がない場合の結果が200 OK となる場合にのみ適用される
  - 条件付き`GET`が304 Not Modified になる場合、`Range`は無視される
  - `If-Range`ヘッダフィールドは、`Range`を適用するための前提条件として使用できる
- 以下の条件がすべて満たされる場合、サーバは206 Partial Content レスポンスを送るべき:
  - すべての前提条件がtrueである
  - サーバが対象リソースに対して`Range`をサポートしている
  - 受信した`Range`フィールド値が、対象リソースでサポートされる範囲単位を含む有効な`ranges-specifier`
  - 当該`ranges-specifier`が、選択された表現に対して満たしうる
  - ... この場合、レスポンスボディは要求された`range-spec`に対応する1つ以上の部分表現を含む
    - ただし、それは要求されたすべての範囲を必ず送信することを意味しない
    - 場合によっては最初に一部の範囲のみを送信し、残りが必要であればクライアントが後続リクエストで
      再要求することを期待する方が、可能または効率的なこともある
- 以下の条件がすべて満たされる場合、サーバは416 Range Not Satisfiable 応答を送るべき:
  - すべての前提条件がtrueである
  - サーバが対象リソースに対して`Range`をサポートしている
  - 受信した`Range`フィールド値が有効な`ranges-specifier`
  - 範囲単位が対象リソースでサポートされていない、または`ranges-specifier`が選択された表現に対して満たし得ない

### Accept-Ranges
- `Accept-Ranges`レスポンスヘッダフィールドは、
  上流サーバが対象リソースに対して範囲リクエストをサポートしているかどうかを示す
- `Accept-Ranges`は性能向上や不要なネットワーク転送の削減を目的とした助言として機能する

```
Accept-Ranges     = acceptable-ranges
acceptable-ranges = 1#range-unit
```

```
Accept-Ranges: bytes

(その対象リソースに対してバイト範囲リクエストが利用可能であることを示し、
 同一のリクエストパスに対する将来の部分リクエストでレンジの利用をクライアントに促す)
```

- クライアントは`Accept-Ranges`を受信していなくても範囲リクエストを生成してよい
  - `Accept-Ranges`を受信しても、将来の範囲リクエストが必ず部分レスポンスを返すとは限らない
    - コンテンツが変更される可能性、サーバが特定の時点や条件下でのみ範囲リクエストをサポートする可能性、
      次のリクエストが別の中継者によって処理される可能性があるため
- 対象リソースに対していかなる種類の範囲リクエストもサポートしないサーバは、
  `Accept-Ranges: none`のように送信することにより、同一のリクエストパスで範囲リクエストを試みないよう
  クライアントに助言することができる
- `Accept-Ranges`フィールドはトレーラセクションとして送信してもよいヘッダフィールドとして送信する方が望ましい
  - コンテンツ途中で失敗した大容量転送を再開する際に特に有用な情報であるため

### Content-Range
- `Content-Range`レスポンスヘッダフィールドは、当該レスポンスメッセージが元の表現のどの範囲に当たるかを示す
- `Content-Range`の目的:
  - 単一範囲の206 Partial Content レスポンスにおいて、メッセージボディとして返している表現の部分範囲を示す
  - multipart/206 レスポンスの各ボディパートにおいて、そのパートに含まれる範囲を示す
  - 416 Range Not Satisfiable レスポンスにおいて、選択された表現に関する情報を提供する

```
Content-Range       = range-unit SP
                      ( range-resp / unsatisfied-range )

range-resp          = incl-range "/" ( complete-length / "*" )
incl-range          = first-pos "-" last-pos
unsatisfied-range   = "*/" complete-length

complete-length     = 1*DIGIT
```

- 206 Partial Content レスポンスに含まれる`Content-Range`の範囲単位が、受信者にとって理解できないものであった場合、
  受信者は 保存済みの表現と再結合を試みてはならない。プロキシの場合は下流へ転送するべき
- クライアントとオリジンサーバ間の私的な合意に基づき、
  部分PUTのためのリクエスト修飾子として`Content-Range`が送信されることもある
- サーバは`Content-Range`が定義されていないメソッドのリクエストで受信した`Content-Range`ヘッダフィールドを
  無視しなければならない。
- バイト範囲の場合、送信者は範囲が切り出された元の表現の全体長 (`complete-length`) を示すことが望ましい
  - 全体長が不明または算出が困難な場合を除く
  - `complete-length`の代わりに`*`を用いた場合は、ヘッダ生成時点で表現の長さが不明であったことを示す

```
(表現の全体長が1234バイトであることを送信者が把握している場合)

Content-Range: bytes 42-1233/1234
```

```
(全体長が不明な場合)

Content-Range: bytes 42-1233/*
```

- `range-resp`において`last-pos`が`first-pos`より小さい`Content-Range`値は無効
- `complete-length`が`last-pos`以下である`Content-Range`値は無効
- 無効な`Content-Range`を受信した場合、受信者は受信した内容を保存済み表現と再結合してはならない
- バイト範囲リクエストに対して416 Range Not Satisfiable レスポンスを生成するサーバは
  ` unsatisfied-range`を含む`Content-Range`ヘッダフィールドを送信することが望ましい
  - この416レスポンスにおける`complete-length`は、選択された表現の現在の長さを示す

```
Content-Range: bytes */1234
```

- `Content-Range`は、その意味が明示的に定義されていないステータスコードに対しては意味を持たない
  - RFCにおいて`Content-Range`に意味を与えるステータスコードは206 Partial Content と416 Range Not Satisfiable のみ

```
(選択された表現の全体長が1234バイトである場合のContent-Range値の例)

(最初の500バイト)
Content-Range: bytes 0-499/1234

(次の500バイト)
Content-Range: bytes 500-999/1234

(最初の500バイトを除いた全体)
Content-Range: bytes 500-1233/1234

(最後の500バイト)
Content-Range: bytes 734-1233/1234
```

### Partial PUT
- Partial PUT = PUTリクエストに`Content-Range`を添付し、対象リソース状態を部分的に書き換えるよう要求する行為
  - HTTPの標準的なPUT仕様とは互換性がない。正式に標準化された機能ではなくサーバとクライアントの私的合意に依存する
  - オリジンサーバはPartial PUTをサポートしていない対象リソースに対してPUTリクエストで`Content-Range`を受信した場合
    400 Bad Request ステータスコードでレスポンスすることが望ましい
- Partial PUTは、PUTの本来の定義とは後方互換性がないため、現在の表現を完全に置き換える可能性がある
- リソースの一部更新は大きなリソースの一部を別のリソースとして管理する、PATCHメソッドを使うなどで実現できる

### Media Type multipart/byteranges
- 206 Partial Content レスポンスメッセージに 複数の範囲のボディが含まれる場合、
  それらはmultipartメッセージボディとして送信され、メディアタイプには`multipart/byteranges`が使用される
- `multipart/byteranges`メディアタイプは、1 つ以上のボディパートから構成され、
  各パートはそれぞれ独自の`Content-Type`および`Content-Range`ヘッダフィールドを持つ
- 必須パラメータ`boundary`は、各ボディパートを区切るために使用される境界文字列を指定する
  - ボディ内の最初の`boundary`文字列の前に追加のCRLFが存在する場合がある
  - 既存の実装の中には引用符付き`boundary`を正しく扱えないものがある
  - かつての初期ドラフトに基づき、`multipart/x-byteranges`というメディアタイプを使用して実装された
    クライアントやサーバが存在する。これは本仕様とほぼ互換だが、完全ではない
  - `multipart/byteranges`メディアタイプはバイト範囲に限定されない

## Status Codes https://www.ietf.org/rfc/rfc9110.html#name-status-codes
- レスポンスのステータスコードは3桁の整数コードであり、リクエストの結果およびレスポンスの意味論を示す
  - リクエストが成功したかどうかや、(存在する場合) どのようなボディが含まれているかが含まれる
  - 有効なステータスコードの範囲は100..599まで (両端を含む)
    - 100..599の範囲外の値は無効
    - 実装ではライブラリエラーなどを内部的に伝達するために、600..999を使用することがよくある
    - 無効なステータスコードを持つレスポンスを受信したクライアントは、そのレスポンスを5xxと同等に処理すべき
- ステータスコードの最初の1桁はレスポンスのクラスを定義し、残りの2 桁には分類上の意味はない
  - 1xx 情報: リクエストは受信され、処理が継続されている
  - 2xx 成功: リクエストは正常に受信され、理解され、受理された
  - 3xx リダイレクション: リクエストを完了するために追加の操作が必要である
  - 4xx クライアントエラー: リクエストに不正な構文が含まれている、または処理できない
  - 5xx サーバエラー: 一見すると有効なリクエストを、サーバが処理できなかった
- HTTP ステータスコードは拡張可能
- クライアントは、登録されているすべてのステータスコードの意味を理解している必要はない
- クライアントは、最初の桁によって示されるステータスコードのクラスを理解しなければならない
- クライアントは、認識できないステータスコードはそのクラスに対応する`x00`と同等として扱わなければならない
- 単一のリクエストに複数のレスポンスが関連付けられる場合がある
  - e.g. ステータスコードが1xx範囲に属する中間 (interim)レスポンスが0個以上続き、
    その後に他のいずれかの範囲のステータスコードを持つ最終 (final) レスポンスが正確に1つ送られる

### Overview of Status Codes
- RFCで定義されているステータスコードの示す理由句はあくまで推奨
  - ローカルな等価表現に置き換えたり、完全に省略したりしてもよい
- ヒューリスティックにキャッシュ可能と定義されているステータスコードが付いたレスポンスは、
  メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、
  ヒューリスティックな有効期限を用いてキャッシュにより再利用されてよい
  - e.g. 200、203、204、206、300、301、308、404、405、410、414、501
  - それ以外のステータスコードは、ヒューリスティックにキャッシュ可能ではない
- 本仕様の範囲外においても、HTTPで使用するための追加のステータスコードが定義されている
  - それらはすべて第16.2節で述べられているHypertext Transfer Protocol (HTTP) Status Code Registryに登録されるべき

### Informational 1xx
- 1xxのステータスコードは、要求された操作を完了し最終レスポンスを送信する前に、
  接続状態やリクエストの進行状況を伝達するための中間レスポンスを示す
  - HTTP/1.0では1xxステータスコードが定義されていなかったため、
    サーバはHTTP/1.0クライアントに対して1xx レスポンスを送信してはならない
- 1xxレスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない
- クライアントは最終レスポンス前に受信した1つ以上の1xxレスポンスを (想定外の受信でも) 解析できなければならない
  - ユーザエージェントは予期しない1xxレスポンスを無視してもよい
- プロキシは1xxレスポンスの生成をプロキシ自身が要求した場合を除き、1xxレスポンスを転送しなければならない
  - プロキシがリクエストを転送する際に`Expect: 100-continue`ヘッダフィールドを追加した場合、
    対応する100レスポンスを転送する必要はない

#### 100 Continue
- 100 Continue ステータスコードは、リクエストの初期部分が受信され、かつサーバによってまだ拒否されていないことを示す
  - サーバはリクエスト全体を受信して処理した後に、最終レスポンスを送信する意図を持っている
- リクエストに`Expect: 100-continue`ヘッダフィールドが含まれている場合、
  100レスポンスはサーバがリクエストのボディを受信したいと考えていることを示す
  - この場合クライアントはリクエストの送信を継続し100レスポンスは破棄すべきである
- リクエストに`Expect: 100-continue`ヘッダフィールドが含まれていない場合、クライアントはこのレスポンスを破棄可能

#### 101 Switching Protocols
- 101 Switching Protocols ステータスコードは、この接続上で使用されているアプリケーションプロトコルを変更するという
  `Upgrade`ヘッダフィールドによるクライアントの要求をサーバが理解し、かつそれに従う意思があることを示す
  - サーバはこのレスポンスの後、レスポンス内に有効となるプロトコルを示す`Upgrade`ヘッダフィールドを
    必ず生成しなければならない
- サーバは、プロトコルの切り替えが有利である場合にのみ切り替えに同意すると想定されている
  - 古いバージョンよりも新しいHTTPバージョンへ切り替えることが有利な場合や、
    リアルタイムかつ同期的な特性を用いるリソースを配信する際に
    そのような特性を持つプロトコルへ切り替えることが有利な場合など

### Successful 2xx
- 2xxのステータスコードは、クライアントのリクエストが正常に受信され、理解され、受理されたことを示す

#### 200 OK
- 200 OK ステータスコードはリクエストが成功したことを示す
- 200レスポンスで送信される内容はリクエストメソッドに依存する

| リクエストメソッド | レスポンス内容が表すもの                     |
| - | - |
| GET                | 対象リソース                                 |
| HEAD               | 対象リソース (表現データは転送されない)      |
| POST               | 処理の状態、または処理によって得られた結果   |
| PUT, DELETE        | 処理の状態                                   |
| OPTIONS            | 対象リソースに対する通信オプション           |
| TRACE              | サーバが受信したとおりのリクエストメッセージ |

- 200レスポンスにはメッセージ内容が含まれることが期待される
  - CONNECTに対するレスポンスを除く
    - CONNECTの成功の結果はトンネルの確立であり、それは200レスポンスのヘッダセクション直後から開始されるため、
      ボディは存在しない
  - メッセージのフレーミングによってボディの長さが0であることが明示されている場合を除く
    - 成功時にボディを含めないことを示す何らかの要素がリクエストに含まれている場合、
      オリジンサーバは代わりに204 No Content レスポンスを送信すべき
- 200レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- GETまたはHEADに対する200レスポンスでは、オリジンサーバは選択された表現に対し
  利用可能なすべての検証子フィールドを送信すべき
  - 特に、強いETagと`Last-Modified`日付の両方を送信することが望ましい
- 状態を変更するメソッドに対する200レスポンスにおいて、レスポンスに含まれる検証子フィールドは、
  リクエストの意味論が正常に適用された結果として生成された新しい表現に対する、現在の検証子を示す
  - PUTメソッドにはこれらの検証子を送信できない場合がある追加要件が存在する

#### 201 Created
- 201 Created ステータスコードは、リクエストが履行された結果として1つ以上の新しいリソースが作成されたことを示す
- リクエストによって作成された主要なリソースは、
  レスポンスに`Location`ヘッダフィールドが含まれている場合はそれによって、
  含まれていない場合は対象URIによって識別される
- 201レスポンスのボディは、通常作成されたリソースを記述し、それらへのリンクを含む
- レスポンスに含まれる検証子フィールドは、リクエストによって作成された新しい表現に対する現在の検証子を示す
  - PUTメソッドには、これらの検証子を送信できない場合がある追加要件が存在する

#### 202 Accepted
- 202 Accepted ステータスコードは、リクエストが受理されたものの、その処理がまだ完了していないことを示す
  - 実際に処理が行われるかどうかは未確定であり、後になって拒否される可能性もある
    - HTTP には、非同期処理の結果として後からステータスコードを再送する仕組みは存在しない
- 202レスポンスは意図的に確約を避けている
- 202レスポンスの目的は、サーバが別のプロセスのためにリクエストを受理しつつ、
  処理が完了するまでユーザエージェントとサーバとの接続を維持することを要求しないようにすること
- 202レスポンスとともに送信される表現は、リクエストの現在の状態を記述し、
  リクエストがいつ履行される見込みかを利用者に示すためのステータス監視手段を指し示すべき

#### 203 Non-Authoritative Information
- 203 Non-Authoritative Information ステータスコードは、リクエスト自体は成功したものの、
  同じリクエストに対してオリジンサーバが返す200 OK レスポンスの内容が
  変換プロキシによって変更されていることを示す
- 203レスポンスは内容に変換が適用された事実を受信者に通知するためのものであり、
  その情報は後続の意思決定に影響を与える可能性がある
  - その内容に対する将来のキャッシュ検証リクエストは、同一のリクエスト経路に沿ってのみ有効である場合がある
- 203レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 204 No Content
- 204 No Content ステータスコードは、サーバがリクエストを正常に履行した上で、
  レスポンスボディとして送信すべき追加のコンテンツが存在しないことを示す
  - レスポンスのヘッダフィールドに含まれるメタデータは、要求された操作が適用された後の対象リソース
    および選択されたその表現を参照する
  - e.g. PUTリクエストに対するレスポンスとして204レスポンスが返され、かつレスポンスに`ETag`が含まれている場合、
    そのPUTは成功しており、`ETag`の値には対象リソースの新しい表現に対するETagが含まれていることを意味する
- 204レスポンスは、対象リソースに対する操作が正常に適用されたことを示しつつ、
  ユーザエージェントが現在のドキュメント表示から遷移する必要がないことを暗黙に示す
  - サーバはユーザエージェントが自身のインターフェースに従って利用者に成功を何らかの形で通知し、
    レスポンスに含まれる新規または更新されたメタデータを、現在アクティブな表現に適用することを前提としている
  - 204ステータスコードは保存操作に対応するドキュメント編集インターフェースで一般的に用いられ、
    保存対象のドキュメントはそのまま利用者が編集可能な状態に保たれる
  - 分散バージョン管理システムのように、自動化されたデータ転送が多用されることを想定したインターフェースでも
    頻繁に使用される
- 204レスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない
- 204レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 205 Reset Content
- 205 Reset Content ステータスコードは、サーバがリクエストを履行したうえで、
  そのリクエスト送信の原因となったドキュメント表示をオリジンサーバから受信した当初の状態にリセットすることを
  ユーザエージェントに求めていることを示す
  - 一般的なデータ入力のユースケースを支援することを目的としている
    - e.g. ユーザがデータ入力を支援するコンテンツを受け取り、その領域でデータを入力または操作し、
      その入力内容をリクエストとして送信した後、次の入力操作を容易に開始できるようにデータ入力機構をリセットする
- 205ステータスコードは追加のコンテンツが提供されないことを意味する
  - サーバは205レスポンスに内容を生成してはならない

#### 206 Partial Content
- 206 Partial Content ステータスコードは、選択された表現の一部を転送することによって、
  サーバが対象リソースに対する範囲リクエストを履行していることを示す
  - 範囲リクエストをサポートするサーバは通常、要求されたすべての範囲を満たそうとする
    (送信するデータを減らすと残りの部分を取得するためにクライアントから追加のリクエストが送られる可能性が高いため)
  - サーバ自身の都合により要求されたデータの一部のみを送信する場合もある
    - 206は自己記述的なため、部分的充足であってもクライアントは解釈可能
- クライアントは206レスポンスに含まれる`Content-Type`および`Content-Range`フィールドを検査し、
  どの部分が含まれているか、追加のリクエストが必要かどうかを判断しなければならない
- 206レスポンスを生成するサーバは、同一リクエストに対して200で送るはずだった以下のヘッダを、
  該当する場合は生成しなければならない:
  - `Date`
  - `Cache-Control`
  - `ETag`
  - `Expires`
  - `Content-Location`
  - `Vary`
  - `Content-Length` (このメッセージのボディ長)
  - `Content-Range` (各範囲が表現全体のどこに位置するか) (全長情報を含む)
- `If-Range`ヘッダフィールドを含むリクエストに対して206レスポンスを生成する送信者は、
  必須とされるもの以外の表現ヘッダフィールドを生成すべきではない
  - クライアントがすでにそれらのヘッダフィールドを含む過去のレスポンスを保持しているためである
- 206レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- Single Part:
  - 単一の部分のみが転送される場合、206レスポンスを生成するサーバは選択された表現のどの範囲が含まれているかを示す
    `Content-Range`ヘッダフィールドと、その範囲に対応する内容を生成しなければならない

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
```

- Multiple Parts:
  - 複数の部分が転送される場合、206レスポンスを生成するサーバは、`multipart/byteranges`ボディを生成し、
    そのメディアタイプおよび必須の`boundary`パラメータを含む`Content-Type`ヘッダフィールドを生成しなければならない
  - Single Partレスポンスとの混同を避けるため、
    サーバはMultiple PartsレスポンスのHTTPヘッダセクションに`Content-Range`ヘッダフィールドを生成してはならない
    - このフィールドは、代わりに各パート内で送信される。
  - 各ボディパートのヘッダ領域内では、そのパートに含まれる範囲に対応する`Content-Range`を生成しなければならない
    - 選択された表現が200 OK レスポンスにおいて`Content-Type`を持っていたであろう場合、
      サーバは各パートのヘッダ領域内でも同じ`Content-Type`ヘッダフィールドを生成すべき
  - 複数の範囲が要求された場合、サーバは要求された範囲指定の順序にかかわらず、
    重複する範囲や複数パート送信のオーバーヘッドよりも小さいギャップしか持たない範囲を結合してもよい
    - 通常、`multipart/byteranges`の各パート間のオーバーヘッドは、
      表現のメディアタイプや`boundary`の長さにもよるがおよそ80バイト程度
      - そのため、多数の小さく分断された部分を転送するよりも、表現全体を転送するほうが効率的な場合がある
  - サーバは、単一範囲のみを要求するリクエストに対して`multipart`レスポンスを生成してはならない
    - 複数パートを要求していないクライアントが`multipart`レスポンスをサポートしていない可能性があるため
      - 複数範囲が要求され、そのうち1つのみが満たされた場合や、結合の結果1つの範囲のみが残った場合には、
        単一パートのみを含む`"multipart/byteranges"`レスポンスを生成してもよい
      - `multipart/byteranges`レスポンスを処理できないクライアントは複数範囲を要求するリクエストを生成してはならない
  - サーバは、満たされなかった範囲や他の範囲に結合されたものを除き、
    `Range`ヘッダフィールドに現れた順序と同じ順序でパートを送信すべき
    - `multipart`レスポンスを受信したクライアントは各ボディパートに含まれる`Content-Range`ヘッダフィールドを検査し
      そのパートにどの範囲が含まれているかを判断しなければならない
      - クライアントは、自身が要求した範囲やその順序がそのまま返されると仮定してはならない

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
```

- Combining Parts:
  - 接続が途中で切断された場合や、1つ以上の`Range`指定を用いたリクエストの場合、
    レスポンスは表現の一部分のみを転送することがある
    - こうした転送が複数回行われると、クライアントは同一表現の複数の範囲を受信している可能性がある
    - これらの範囲は、すべてが同一の強い検証子を共有している場合にのみ、安全に結合できる
  - 対象リソースに対するGETリクエストの複数の部分レスポンスを受信したクライアントは、
    それらが同一の強い検証子を共有している場合、より大きな連続範囲に結合してもよい
  - 最新のレスポンスが不完全な200 OK レスポンスである場合、そのレスポンスのヘッダフィールドが
    結合後のレスポンスに使用され、対応する保存済みレスポンスのヘッダフィールドを置き換える
  - 最新のレスポンスが206 Partial Content であり、対応する保存済みレスポンスの少なくとも1つが200 OK である場合、
    結合後のレスポンスのヘッダフィールドは、最新の200レスポンスのものから構成される
    - 対応する保存済みレスポンスがすべて206レスポンスである場合、最も新しいヘッダフィールドを持つ
      保存済みレスポンスが、結合後のレスポンスのヘッダフィールドの元として使用される
      - クライアントは`Content-Range`を除き、新たなレスポンスで提供された他のヘッダフィールドを用いて、
        保存済みレスポンス中の対応するヘッダフィールドをすべて置き換えなければならない
  - 結合後のレスポンスボディは、新しいレスポンスおよび対応するすべての保存済みレスポンスに含まれる
    部分範囲の和集合から構成される
    - その和集合が表現全体の範囲を含む場合、クライアントは完全な長さを反映した`Content-Length`を含む、
      完全な200 OK レスポンスであるかのように結合後のレスポンスを処理しなければならない
      - そうでない場合クライアントは、連続した範囲の集合を次のいずれかとして処理しなければならない:
        - (結合後のレスポンスが表現の先頭部分である場合) 不完全な200 OK レスポンス
        - `multipart/byteranges`ボディを含む単一の206 Partial Content レスポンス
        - それぞれが`Content-Range`によって示される1つの連続範囲を持つ複数の206 Partial Content レスポンス

### Redirection 3xx
- 3xxステータスコードは、リクエストを履行するためにユーザエージェントによる追加の操作が必要であることを示す
  - 301 Moved Permanently、302 Found、307 Temporary Redirect、308 Permanent Redirect
    - 別のURIにリソースが存在する可能性を示すリダイレクション
    - `Location`ヘッダフィールドによって示されるURIにおいて利用可能である可能性を示す
  - 300 Multiple Choices
    - 同一リソースを表現しうる複数の候補から選択肢を提示するリダイレクション
  - 303 See Other
    - 間接的なレスポンスを表す別リソースへのリダイレクション
    - Location ヘッダフィールドで識別される別リソースを指すもの。
  - 304 Not Modified
    - 以前に保存された結果へのリダイレクション

```
歴史

HTTP/1.0では301 Moved Permanently および302 FoundはCERNにおける実装に合わせ、
メソッドを保持するものとして定義されていた。

一方、303 See Other はメソッドをGETに変更するリダイレクションとして定義された。

初期のユーザエージェントは、POST リクエストをリダイレクトする際に、
当時の仕様どおりPOSTのままにするか、より安全な代替としてGETに変更するかで挙動が分かれていたが、
最終的に、主流の実装はGETに変更する挙動へと収束した。

これを踏まえ、後に307 Temporary Redirect および308 Permanent Redirect が追加され、
メソッドを保持するリダイレクションであることを明確に示すようになった。
また、301 および 302 についても、POSTリクエストをGETとしてリダイレクトできるよう調整された。
```

- `Location`ヘッダフィールドが提供されている場合、ユーザエージェントはたとえそのステータスコードの詳細な意味を
  理解していなくても、`Location`フィールド値が参照するURIへ自動的にリダイレクトしてもよい
  - 「安全であると知られていない」メソッドについては、利用者がそのようなリクエストのリダイレクトを望まない可能性が
    あるため、自動リダイレクトは慎重に行う必要がある
- リダイレクトされたリクエストを自動的に追跡する場合、ユーザエージェントは以下の修正を加えたうえで、
  元のリクエストメッセージを再送信すべき:
  - 対象URIを、リダイレクトレスポンスの`Location`値が参照するURI (元の対象URIに対して相対解決したもの) に置き換える
  - 実装によって自動生成されたヘッダフィールドを削除し、新しいリクエストに適切な値で置き換える:
    - 接続固有のヘッダフィールド
    - クライアントのプロキシ設定に固有のヘッダフィールド (`Proxy-Authorization` など)
    - オリジン固有のヘッダフィールド (`Host` など)
    - 実装のキャッシュによって追加された検証用ヘッダフィールド (`If-None-Match`、`If-Modified-Since` など)
    - リソース固有のヘッダフィールド (`Referer`、`Origin`、`Authorization`、`Cookie` など)
  - セキュリティ上の影響がある場合には、実装が自動生成していないヘッダフィールドについても削除を検討する
    - `Authorization`、`Cookie`やそれ以外
  - リダイレクトを指示するステータスコードの意味論に従い、必要に応じてリクエストメソッドを変更する
  - リクエストメソッドがGETまたはHEADに変更された場合、ボディ固有のヘッダフィールドを削除する
    - `Content-Encoding`
    - `Content-Language`
    - `Content-Location`
    - `Content-Type`
    - `Content-Length`
    - `Digest`
    - `Last-Modified` など
- クライアント無限リダイレクトループを検出し、介入すべき
  - 本仕様の以前の版では、最大5回までのリダイレクションを推奨していた
  - コンテンツ開発者は、クライアントによってそのような固定上限を実装している場合があることを認識しておく必要がある

#### 300 Multiple Choices
- 300 Multiple Choices ステータスコードは、対象リソースが複数の表現を持ち、
  それぞれがより具体的な識別子を有していることを示す
  - 利用者 (またはユーザエージェント) がそれらの識別子の1つ以上へリクエストをリダイレクトすることによって
    好ましい表現を選択できるよう、代替案に関する情報が提供されていることを意味する
    - サーバはユーザエージェントがReactive Negotiationに関与し、自身の要件に最も適した表現を選択することを望む
- サーバに優先する選択肢がある場合、サーバはその優先選択肢のURI参照を含む`Location`ヘッダフィールドを生成すべき
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
- HEAD以外のリクエストメソッドに対して、サーバは利用者またはユーザエージェントが最も好ましいものを選択できるよう
  表現のメタデータおよびURI参照の一覧を含むボディを300レスポンスで生成すべき
  - ユーザエージェントは、提供されたメディアタイプを理解できる場合、その一覧から自動的に選択してもよい
    - 自動選択のための特定の形式は本仕様では定義されていない (HTTPが内容の定義から独立であることを目指しているため)
      - 実際には共有された設計やコンテンツネゴシエーションによってユーザエージェントに受け入れられると考えられる
        解析しやすい形式、一般的に受け入れられているハイパーテキスト形式で表現が提供される
- 300レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 301 Moved Permanently
- 301 Moved Permanently ステータスコードは、対象リソースに新しい恒久的なURIが割り当てられ、
  将来このリソースを参照する際には同封されているURIのいずれかを使用すべきであることを示す
  - サーバはリンク編集機能を備えたユーザエージェントであれば、対象URIへの参照を、
    サーバが送信した新しい参照のいずれかに恒久的に置き換えられることを示唆している
    - 一般的に、ユーザエージェントが実際に参照の編集を行っており、接続がセキュアで、
      かつオリジンサーバが編集対象コンテンツの信頼できる権威である場合を除いてはサーバの示唆は無視される
- サーバは新しい恒久的URIの優先候補を示す`Location`ヘッダフィールドをレスポンスに生成すべき
  - ユーザエージェントは自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、新しいURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 歴史的な理由によりユーザエージェントは、後続のリクエストにおいてリクエストメソッドをPOSTからGETへ変更してもよい
  - その挙動が望ましくない場合は、代わりに308 Permanent Redirect ステータスコードを使用できる
- 301レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 302 Found
- 302 Found ステータスコードは、対象リソースが一時的に別のURIの下に存在していることを示す
  - このリダイレクションは状況に応じて変更される可能性があるため、クライアントは将来のリクエストにおいても、
    引き続き元の対象URIを使用すべき
- サーバは、別のURIを示すURI参照を含む`Location`ヘッダフィールドをレスポンスに生成すべきである
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
    - サーバのレスポンスボディには通常、別のURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 歴史的な理由によりユーザエージェントは、後続のリクエストにおいてリクエストメソッドをPOSTからGETへ変更してもよい
  - その挙動が望ましくない場合は、代わりに307 Temporary Redirect ステータスコードを使用できる

#### 303 See Other
- 303 See Other ステータスコードは、`Location`ヘッダフィールドに示されたURIによって識別される別のリソースへ、
  ユーザエージェントをリダイレクトすることをサーバが意図していることを示す
  - 対象の別リソースは元のリクエストに対する間接的なレスポンスを提供することを目的としている
  - ユーザエージェントは、そのURIを対象とした取得リクエスト (GET / HEAD)を実行でき、
    その取得リクエストがさらにリダイレクトされる場合もある
  - 最終的に得られた結果は元のリクエストに対する回答として提示されうる
  - `Location`ヘッダフィールドに示される新しいURIは、元の対象URIと等価なものとは見なされない
- このステータスコードは、あらゆるHTTP メソッドに適用可能
  - 主な用途はPOST出力を別のリソースへユーザエージェントをリダイレクトさせること
    - POSTレスポンスに対応する情報を個別に識別可能でブックマーク可能かつキャッシュ可能なリソースとして提供するため
- GETリクエストに対する303レスポンスはオリジンサーバがHTTPを介して転送可能な対象リソースの表現を持たないことを示す
  - `Location`フィールド値が参照するリソースは対象リソースを記述するものであり、
    その別リソースに対して取得リクエストを行うことによって受信者に有用な表現が得られる可能性がある
    - それが元のターゲットリソースを表現していることを意味するわけではない
      (何が表現可能であるか、どの表現が適切か、何が有用な記述であるかといった問題はHTTPの範囲外)
- HEADリクエストに対するレスポンスを除き、303レスポンスの表現には、
  `Location`ヘッダフィールドに示されたURI参照へのハイパーリンクを含む短いハイパーテキストの注記を含めるべきである

#### 304 Not Modified
- 304 Not Modified ステータスコードは、条件付きのGETまたはHEADリクエストが受信され、
  その条件がfalseと評価されて200 OK レスポンスにはならなかったことを示す
  - その条件がなければ200 OK になっていたとしても、条件付きリクエストを行ったクライアントはすでに
    有効な表現を保持しているため、サーバが対象リソースの表現を転送する必要はない
    - サーバはクライアントに対し、保存済みの表現を200 OK レスポンスのボディであるかのように利用するよう促している
- 304レスポンスを生成するサーバは、同一リクエストに対して200 OK レスポンスで送信されていたであろう、
  以下のヘッダフィールドを生成しなければならない:
  - `Content-Location`
  - `Date`
  - `ETag`
  - `Vary`
  - `Cache-Control`および`Expires`
- 304レスポンスの目的は受信者がすでに1つ以上のキャッシュ済み表現を保持している場合に、情報転送量を最小化すること
  - そのため送信者は、上記に列挙されたフィールド以外の表現メタデータを生成すべきではない
    - ただし、キャッシュ更新を誘導する目的で必要なメタデータがある場合はこの限りではない
      - 304レスポンスを受信したキャッシュに対する要件は、［CACHING］の 4.3.4 節で定義されている。
- 条件付きリクエストが共有プロキシに対して条件付きGETを送信する独自キャッシュを持つユーザエージェントなど
  外向きのクライアントから発せられたものである場合、そのプロキシは304レスポンスを当該クライアントへ転送すべき
- 304レスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない

#### 305 Use Proxy
- 305 Use Proxy ステータスコードは、本仕様の以前の版で定義されていたが、現在は非推奨

#### 306 (Unused)
- 306 ステータスコードは、本仕様の以前の版で定義されていたが、現在は使用されておらず、このコードは予約済み

#### 307 Temporary Redirect
- 307 Temporary Redirect ステータスコードは、対象リソースが一時的に別のURIの下に存在していることを示す
- ユーザエージェントがそのURIへ自動的にリダイレクトを行う場合、リクエストメソッドを変更してはならない
    - このリダイレクションは時間とともに変更される可能性があるため、クライアントは将来のリクエストにおいても、
      引き続き元の対象URIを使用すべき
- サーバは別のURIを示すURI 参照を含む`Location`ヘッダフィールドをレスポンスに生成
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、別のURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる

#### 308 Permanent Redirect
- 308 Permanent Redirect ステータスコードは、対象リソースに新しい恒久的なURIが割り当てられ、
  将来このリソースを参照する際には同封されているURIのいずれかを使用すべきであることを示す
  - サーバはリンク編集機能を備えたユーザエージェントであれば、対象URIへの参照を、
    サーバが送信した新しい参照のいずれかに恒久的に置き換えられることを示唆している
    - 一般的に、ユーザエージェントが実際に参照の編集を行っており、接続がセキュアで、
      かつオリジンサーバが編集対象コンテンツの信頼できる権威である場合を除いてはサーバの示唆は無視される
- サーバは新しい恒久的URIの優先候補を示す`Location`ヘッダフィールドをレスポンスに生成すべきである
  - ユーザエージェントは自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、新しいURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 308レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- 308 Permanent Redirect ステータスコードは比較的新しく (2014年6月) 、環境によっては認識されない可能性がある

### Client Error 4xx
#### 400 Bad Request
#### 401 Unauthorized
#### 402 Payment Required
#### 403 Forbidden
#### 404 Not Found
#### 405 Method Not Allowed
#### 406 Not Acceptable
#### 407 Proxy Authentication Required
#### 408 Request Timeout
#### 409 Conflict
#### 410 Gone
#### 411 Length Required
#### 412 Precondition Failed
#### 413 Content Too Large
#### 414 URI Too Long
#### 415 Unsupported Media Type
#### 416 Range Not Satisfiable
#### 417 Expectation Failed
#### 418 (Unused)
#### 421 Misdirected Request
#### 422 Unprocessable Content
#### 426 Upgrade Required
### Server Error 5xx
#### 500 Internal Server Error
#### 501 Not Implemented
#### 502 Bad Gateway
#### 503 Service Unavailable
#### 504 Gateway Timeout
#### 505 HTTP Version Not Supported
