# RFC 9110 HTTP Semantics https://www.ietf.org/rfc/rfc9110.html
## Length Requirements https://www.ietf.org/rfc/rfc9110.html#name-length-requirements
- [SHOULD] 受信者は受信したプロトコル要素を防御的に解析すべきである
  - その要素がABNF文法に完全に適合していることや、妥当なバッファサイズ内に収まることについては、
    最小限の期待しか置かない前提で処理するべきである
- HTTPでは多くのプロトコル要素について明確な長さの制限を定めていない
  - 配備環境や実装の目的によって適切な長さが大きく異なるため
  - 送信者と受信者の相互運用性は、各プロトコル要素について妥当な長さが何であるかという共有された期待に依存する
    - HTTPが利用されてきた過去30年余りの間に、いくつかのプロトコル要素について妥当と理解される長さは変化しており、
      将来にわたっても変化し続けると考えられる
- [MUST] 受信者は同種のプロトコル要素について、
  自らが他のメッセージで生成しうる長さと同等以上の長さを解析および処理できなければならない
  - オリジンサーバが自身のリソースに対して非常に長いURI参照を公開している場合、
    そのサーバはそれらが対象URIとして受信された際にも同じ参照を解析・処理できる必要がある
- 受信されるプロトコル要素の多くは、下流へ転送するために必要な範囲でのみ解析される
  - 中継者は、受信したフィールドをフィールド名とフィールド値に分解して解析するが、
    フィールド値の内部構造までは解析せず、そのまま転送することがある

## Error Handling https://www.ietf.org/rfc/rfc9110.html#name-length-requirements
- [MUST] 受信者は本仕様および本仕様への拡張で定義されている意味論に従い、受信したプロトコル要素を解釈する
  - 受信者が経験や設定を通じて、送信者がその意味論に含意される挙動を誤って実装していると判断した場合は
    この限りではない
    - e.g. `User-Agent`ヘッダフィールドを調査した結果、特定の実装バージョンがある種のコンテンツコーディングを
      受信すると失敗することが知られている場合、オリジンサーバは受信した`Accept-Encoding`の内容を無視することがある
- [MAY] 特に明記されていない限り、受信者は不正な構造から利用可能なプロトコル要素を回復しようと試みてもよい
  - HTTPは、セキュリティに直接影響する場合を除き、具体的なエラー処理機構を定義していない
    (プロトコルの利用形態によって適切なエラー処理戦略が異なるためである)
    - e.g. Webブラウザは、`Location`ヘッダフィールドがABNFに従って解析できないレスポンスからでも、
      透過的に回復することを望むかもしれない一方で、システム制御用のクライアントは、
      いかなる形のエラー回復であっても危険と見なす可能性がある
- 基盤となる接続障害が発生した場合には、クライアントが一部のリクエストを自動的に再試行できる場合がある
  (Idempotent Methods)

## Terminology and Core Concepts https://www.ietf.org/rfc/rfc9110.html#name-terminology-and-core-concep
- リソース Resource
  - リクエストの対象。URIによって識別される
- 表現 Representation
  - ある時点におけるリソースの状態を、HTTPメッセージで伝送可能な形にしたもの
  - リクエストに基づきコンテンツネゴシエーションによって選択される
- クライアント Client
  - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- サーバ server
  - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- メッセージ Messages
  - 接続を介して交換される情報
  - クライアントは、メソッドおよび対象リソースを含むリクエストメッセージをサーバへ送信する
    - リクエストにはリクエスト修飾子、クライアント情報、表現メタデータのためのヘッダフィールド、
      メソッドに従って処理されることを意図したボディ、
      ボディの送信中に収集された情報を伝達するためのトレーラフィールドが含まれる場合がある
 - サーバは、クライアントのリクエストに対し、1つ以上のレスポンスメッセージを送信することで応答する
   - レスポンスにはステータスコードが含まれる
   - レスポンスにはサーバ情報、リソースメタデータ、表現メタデータのためのヘッダフィールド、
     ステータスコードに従って解釈されるボディ、
     ボディの送信中に収集された情報を伝達するためのトレーラフィールドが含まれる場合がある
- ユーザエージェント User Agent
  - リクエストを開始するさまざまなクライアントアプリケーション
  - e.g. Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- オリジンサーバ Origin Server
  - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - e.g. 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- 中継者 Intermediary
  - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
    - プロキシ Proxy - クライアントが利用するメッセージ転送エージェント
    - ゲートウェイ Gateway (Reverse Proxy) - オリジンサーバが利用するメッセージ転送エージェント
    - トンネル Tunnel - メッセージを変更せずにユーザエージェント/オリジンサーバ間を中継する
- キャッシュ Cache
  - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP https://www.ietf.org/rfc/rfc9110.html#name-identifiers-in-http
### URI References
- URI参照はリクエストの対象を指定し、リダイレクトを示し、リソース間の関係を定義するために用いられる

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

- HTTPにおいてURI参照を許可する各プロトコル要素は、そのABNF定義の中でどの形式の参照を許可するかを示す
  - 任意の形式のURI参照 (URI-reference) を許可するか、絶対URI (absolute-URI) のみを許可するか、
    パスと任意のクエリ要素のみ（partial-URI）を許可するか、あるいはそれらの組み合わせかが明示される
    - 特に明記されていない限りURI参照は対象URIに対して相対的に解釈される
- [RECOMMENDED] すべての送信者および受信者は、プロトコル要素内で8000オクテット長以上のURIをサポートすることが
  推奨される
  - 一部の構造や通信路上の表現は、場合によっては必然的により大きくなりうる

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

#### http URI Scheme
- http URIスキームは、特定のポートでTCP接続を待ち受ける可能性のあるHTTPオリジンサーバによって管理される、
  階層的な名前空間内で識別子を発行するために定義される

```
http-URI = "http" "://" authority path-abempty [ "?" query ]
```

- http URIのオリジンサーバは、`authority`構成要素によって識別される
  - `authority`にはホスト識別子と任意のポート番号が含まれる
  - ポートの副要素が空である場合または指定されていない場合はTCP ポート80が既定値となる
  - オリジンは識別されたリソースを対象とするリクエストに対して、誰が権威をもって応答できるかを決定する
- [MUST NOT] 送信者はホスト識別子が空のhttp URIを生成してはならない
  - [MUST] そのようなURI参照を処理する受信者は、それを無効として拒否しなければならない
- 階層的な`path`構成要素および任意の`query`構成要素は、オリジンサーバの名前空間内における対象リソースを識別する

#### https URI Scheme
- https URIスキームは、特定のポートでTCP接続を待ち受け、HTTP 通信のためにセキュアに確立されたTLS接続を確立できる
  可能性のあるオリジンサーバによって管理される、階層的な名前空間内で識別子を発行するために定義される

```
セキュア:

当該`authority`を代表して動作していることがサーバとして認証されていること、
当該サーバとのすべてのHTTP通信がクライアントおよびサーバ双方にとって
受容可能な機密性および完全性の保護を備えていること
```

```
https-URI = "https" "://" authority path-abempty [ "?" query ]
```

- http URIのオリジンサーバは、`authority`構成要素によって識別される
  - `authority`にはホスト識別子と任意のポート番号が含まれる
  - ポートの副要素が空である場合または指定されていない場合はTCP ポート80が既定値となる
  - オリジンは識別されたリソースを対象とするリクエストに対して、誰が権威をもって応答できるかを決定する
- [MUST NOT] 送信者は、ホスト識別子が空のhttps URIを生成してはならない
  - [MUST] そのようなURI参照を処理する受信者は、それを無効として拒否しなければならない
- 階層的な`path`構成要素および任意の`query`構成要素は、そのオリジンサーバの名前空間内における対象リソースを識別する
- [MUST] クライアントは、httpsリソースに対するHTTPリクエストがセキュアであることを通信前に保証する
- [MUST] クライアントは、それらのリクエストに対してセキュアなレスポンスのみを受け入れる
  - どの暗号学的機構がクライアントおよびサーバにとって受容可能であるかの定義は、
    通常はネゴシエーションによって決定され、時間とともに変化し得る
- httpsスキームを通じて提供されるリソースは、httpスキームと同一のアイデンティティを共有しない
  - https / httpは別個のオリジンであり、独立した名前空間を持つ
    - Cookieプロトコルのように、同一ホストを持つすべてのオリジンに適用されるHTTP拡張は、
      一方のサービスによって設定された情報が、対応するホストドメイン群内の他のサービスとの通信に影響を与えることを
      許している
      - [ought to] このような拡張は、セキュアな接続から得られた情報が意図せず
        非セキュアな文脈に交換されることを防ぐため、細心の注意を払って設計されるべき

#### http(s) Normalization and Comparison
- httpまたはhttpsスキームを持つURIは、各スキームに対して前述の既定値を用い、[URI] 6で定義されている方法に従って
  正規化および比較される
- HTTPは同値性を判断するための特定の方法を必須としていない
  - キャッシュキーは構文ベースの正規化後に単純な文字列として比較される場合もあれば、
    スキームベースの正規化後に比較される場合もある
- httpおよびhttps URIに対するスキームベースの正規化 [URI] 6.2.3 には、以下の追加規則が含まれる:
  - ポートがそのスキームの既定ポートと等しい場合、正規形ではポート副要素を省略する
  - OPTIONSリクエストのターゲットとして使用されていない場合、空の`path`要素は絶対パス`/`と等価であるため、
    正規形では`path`を`/`とする
  - スキームおよびホストは大文字・小文字を区別せず、通常は小文字で提供される
    - 他の構成要素は大文字・小文字を区別して比較される
- `reserved`集合に含まれない文字は、パーセントエンコードされたオクテットと等価
  - 正規形ではそれらをエンコードしない [URI] 2.1 / [URI] 2.2

```
(以下は等価)

http://example.com:80/~smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
```

- 正規化後に等価となる2つのHTTP URIは、同一のリソースを識別しているとみなしてよい
  - [MAY] HTTPのいかなる構成要素も正規化を行ってもよい
  - [SHOULD NOT] その結果として、正規化後に等価となるHTTP URIを用いて異なるリソースを識別すべきではない

#### Deprecation of userinfo in http(s) URIs
- URIの汎用構文における`authority`には、ユーザー認証情報をURIに含めるための`userinfo`要素 [URI] 3.2.1 が含まれる
  - この副要素において`user:password`形式の使用は非推奨
  - 一部の実装では、URI中の`userinfo`要素を、コマンド実行時のオプション、設定ファイル、
    ブックマークリストなどにおける内部的な認証情報設定として利用している場合がある
    - そのような使用は、ユーザー識別子やパスワードを露出させる可能性がある。
- [MUST NOT] 送信者はメッセージ内で対象URIまたはフィールド値としてhttpまたはhttps URI参照を生成する際、
  `userinfo`およびその区切り文字`@`を生成してはならない
- [SHOULD] 信頼できない送信元から受信したhttpまたはhttps URI 参照を利用する前に、
  受信者は`userinfo`の有無を解析し、その存在をエラーとして扱うべき
  (フィッシング攻撃の目的で`authority`を偽装するために用いられている可能性が高いため)

#### http(s) References with Fragment Identifiers
- フラグメント識別子は [URI] 3.5 で定義されているとおり、URIスキームとは独立に
  二次的なリソースを間接的に識別するためのもの
  - URIを参照する一部のプロトコル要素ではフラグメントの包含が許可されているが、他の要素では許可されていない
    - これらはフラグメントを許可する場合に用いられるABNF規則が使用されているかどうかによって区別される
    - フラグメントが許可されない場合には、それを除外する特定の規則が用いられる
- フラグメント識別子要素はURIスキームの定義の一部ではなく、httpおよびhttps URIスキームのABNF定義には
  フラグメントは含まれていない

### Authoritative Access (権威的アクセス)
- 特定の識別子を参照して識別されたリソースへアクセスする際
  そのアクセスが権威的である = リソース所有者によって制御されているとクライアントが信頼している方法で行われること
  - アクセスが許可されるかどうかを判断するプロセスはURIスキームによって定義される
    - 汎用構文が用いられる場合には`authority`構成要素のようなURI構成要素内のデータがしばしば利用される
- 権威を持っている = そのURIを代表している

#### URI Origin
- あるURIに対するオリジン originとは、スキーム・ホスト・ポートの3要素の組
  - スキームおよびホストは小文字に正規化され、ポートは先頭の0を除去する形で正規化される
  - URIからポートが省略されている場合は、そのスキームに対する既定のポートが用いられる

```
e.g.

URI
https://Example.Com/happy.js

オリジン (スキーム・ホスト・ポート)
{ "https", "example.com", "443" }

正規化済みURIプレフィックス
https://example.com:443
```

- 各オリジンはそれぞれ独自の名前空間を定義し、その名前空間内の識別子がどのようにリソースへ対応付けられるか制御する
- 利用者がURIに結び付けて理解する意味論は、
  オリジンが有効なリクエストに対し、時間を通じて一貫した応答を行うことによって形成される
  - その意味論が有用であることにより、最終的にこれらは将来にわたって参照・アクセスされるリソースとして機能する
- スキーム、ホスト、またはポートのいずれかが異なるオリジン同士は異なるオリジン同士とされる
  - たとえ同一の主体が2つの異なるオリジンを管理していることが検証できたとしても、
    そのオリジンに対して権威を持つサーバによって明示的にエイリアス化されない限り、
    それぞれのオリジン配下の名前空間は別個のもの

#### http Origin
- httpスキームでは、URIに含まれる`authority` (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバが権威を持つとみなされる
- ホスト識別子がIPアドレスの場合、そのIPアドレス上の指定TCPポートで待ち受けているサーバがオリジンサーバ
- ホスト識別子が登録名の場合、その登録名は名前解決を介し適切なオリジンサーバのアドレスを見つけるための間接的識別子
- [MAY] http URIが、示されたリソースへのアクセスを要請する文脈で用いられた場合、
  クライアントはホスト識別子をIPアドレスに解決し、指定ポートでTCP接続を確立し、
  その接続上でクライアントの対象URIに一致するリクエストターゲットを含むHTTPリクエストメッセージを送信することで、
  アクセスを試みてもよい
  - そのようなリクエストに対してサーバが (中間ではない) HTTPレスポンスを返した場合、そのレスポンスは、
    クライアントのリクエストに対する権威的な応答とみなされる
    - 上記は権威的な応答を得るための唯一の手段ではなく、常に権威的な応答が必要であるわけでもない
      - e.g. オリジンサーバは`Alt-Svc`ヘッダフィールドを用いて、そのオリジンに対して権威を持つ他のサービスを
        示すことができる

#### https Certificate Verification
- httpsスキームでは、URIに含まれるhost:portではなく、当該オリジンサーバに対して有効であるとクライアントが信頼する
  証明書に対応する秘密鍵を持つサーバが権威を持つと見なされる
  - クライアントは通常、事前に取り決められたまたは設定されたトラストアンカーから伝達される信頼の連鎖に基づいて
    その証明書を信頼できるものと判断する
- HTTP/1.1以前では、クライアントは当該URIオリジンのホストに対して特定的に確立され、
  かつセキュアに保護された接続上で通信している場合にのみ、サーバに権威を帰属させる
  - 接続の確立および証明書検証は、権威の証拠として用いられる。
- HTTP/2およびHTTP/3 では、クライアントは正常に確立されセキュアに保護された接続上で通信しており、
  かつURIオリジンのホストがサーバ証明書に含まれるいずれかのホストと一致し、
  さらにそのURIに対して当該ホストへの接続を開けるとクライアントが信じられる場合に、サーバに権威を帰属させる
  - 実際にはクライアントはDNS問い合わせを行い、オリジンのホストが確立済み接続と同じサーバIPアドレスを
    指していることを確認する
    - この制約はオリジンサーバが同等性を示す`ORIGIN フレーム`を送信することで緩和できる
- リクエスト対象のホストおよびポートの値はHTTPリクエスト内で渡され、オリジンを識別するとともに、
  同一サーバが制御している可能性のある他の名前空間と区別する
  - 証明書の秘密鍵を制御できる任意のサービスが対応するhttps名前空間の管理について同等の責任を負うこと、
    または少なくとも誤って配送されたように見えるリクエストを拒否できることを保証するのはオリジンの責任
- オリジンサーバはたとえ権威を有していても、特定の対象URIに対するリクエスト処理を望まない場合がある
  - e.g. 同一ホストが異なるポートで別々のサービスを提供している場合、接続がセキュアに確立された後であっても
    オリジンサーバで対象URIを検査することが必要なため
    - さもなくばネットワーク攻撃者が、あるポート向けの接続を別のポートで受信させることにより、
      ある対象URIへのレスポンスを、別ポートからの一見権威的なレスポンスに置き換えることを許可するおそれがある
- httpsスキームは権威の関連付けにTCPや接続先ポート番号を用いない
  - これらはセキュアな通信の外側にあり、決定的なものとして信頼できないため
    - そのためHTTP通信はセキュアに保護された任意のチャネル上で行われ得る
- [MAY] https URIが示されたリソースへのアクセスを要請する文脈で用いられた場合、
  クライアントはホスト識別子をIPアドレスに解決し、指定ポートでTCP接続を確立し、
  TCP上でTLSを正常に開始して機密性および完全性の保護により接続をEnd-to-Endで保護し、
  その接続上でクライアントの対象URIに一致するリクエスト対象を含むHTTPリクエストメッセージを送信することで、
  アクセスを試みてもよい
  - そのようなリクエストに対して、サーバが (中間ではない) HTTP レスポンスを返した場合、
    そのレスポンスは、クライアントのリクエストに対する権威的な応答とみなされる
    - 上記は権威的な応答を得るための唯一の手段ではなく、常に権威的な応答が必要であるわけでもない

#### IP-ID Reference Identity
- https URIの`host`フィールドにIP アドレスのリテラルが用いられて識別されるサーバは、
  IP-ID (P Address Identity) 型の参照アイデンティティを持つ
  - IPv4 アドレスはIPv4addressのABNF規則を使用する
  - IPv6アドレスはIP-literal生成規則のうちIPv6addressの選択肢を使用する
- IP-ID型の参照アイデンティティは、IPアドレスをデコードしたバイト列を含む
- IPv4 アドレスは4 オクテット、IPv6アドレスは16オクテット
- IP-IDの使用はこれら以外のIP バージョンについては定義されていない
  - 証明書の subjectAltName 拡張におけるiPAddressの選択肢は、IPバージョンを明示的に含まないため、
    アドレス長によってバージョンを区別する
  - IP-ID型の参照アイデンティティは、そのアドレスが証明書のsubjectAltName拡張に含まれるiPAddressの値と
    完全に一致する場合に一致すると判定される

## Fields https://www.ietf.org/rfc/rfc9110.html#name-fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される

### Field Names

- フィールド名は、対応するフィールド値がその名前によって定義された意味論を持つことを示す

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- [ought to] フィールド名はHypertext Transfer Protocol (HTTP) Field Name Registryに登録されていることが望ましい
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
  - そのフィールドが存在しない場合における受信者の既定の振る舞いは変化し得る
  - [ought to] `Host`および`Connection`は、HTTP/1.1 への適合を明示的に主張していない場合であっても、
    すべてのHTTP実装が認識すべき
- 新しいフィールドは、認識しない受信者が安全に無視できるように意味論が定義されていれば
  プロトコルバージョンを変更することなく導入できる
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する
- [MUST] プロキシは、認識できないヘッダフィールドであってもそのフィールド名が`Connection`に列挙されていない、
  あるいは当該フィールドを遮断・変換するよう明示的に設定されていない限り、
  当該フィールドををオリジンに転送しなければならない
  - [SHOULD] その他の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視すべき
    - これらの要件に従うことで、配備済みの中継者を更新または撤去することなくHTTPの機能を拡張できる

### Field Lines and Combined Field Value
- フィールドは任意数のフィールド行から構成される
- フィールド行はフィールド名とフィールド行値から構成される
- 同名のフィールド名が複数の別の行で現れた場合、
  フィールド値は各行の値をその出現順にカンマ区切りで連結したリストとして解釈される

```
Example-Field: Foo, Bar
Example-Field: Baz
```

### Field Order
- [MAY] 受信者は、1つのフィールドセクション内に同一のフィールド名を持つ複数のフィールド行が存在する場合、
  それらを1つのフィールド行に結合してもよい
  - 最初のフィールド行値に続けて、後続の各フィールド行値を出現順に、`,`と任意の空白 (OWS) で区切って追加する
  - 整合性のため、カンマ + SP を用いることが推奨される
- [MUST NOT] プロキシはメッセージを転送する際、これらのフィールド行値の順序を変更してはならない
  - [MUST NOT] 送信者は同一名のフィールド行をヘッダ/トレーラを含むメッセージ内に複数生成してはならない
  - [MUST NOT] 同名のフィールド行がすでに存在する場合に新たなフィールド行を追加してはならない
  - 当該フィールドの定義が、複数のフィールド行値をカンマ区切りリストとして再結合できることを許している場合を除く
- [ought to] `Set-Cookie`ヘッダフィールドはは単一のフィールド値に結合できないため、
  受信者はフィールド処理において特別扱いすべき
  - `Set-Cookie`はレスポンスメッセージ内で複数のフィールド行として現れることが多く、
    リスト構文を用いないため、上記の「同一名フィールド行」に関する要件に反する
- 異なるフィールド名を持つフィールド行同士の順序は解釈上は重要ではないが、
  実装が可能な限り早期にメッセージを処理しない判断を下せるよう、
  追加の制御情報を含むヘッダを先に送信するのは良いプラクティス
- [MUST NOT] サーバは、リクエストヘッダセクション全体を受信し終えるまでそのリクエストを対象リソースに適用しない
  - 後続のヘッダ行に条件付きリクエスト、資格情報、そのほか処理に影響を与え得る意図的に誤解を招く重複ヘッダが
    含まれる可能性があるため

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
  - 実際には個々のフィールドの意味論に依存して、アドホックな長さ制限が設けられていることが多い
- [MUST] サーバは、大きすぎる大きなリクエストヘッダのフィールド行、フィールド値、フィールド集合を受信した場合、
  適切な4xxステータスコードで応答しなければならない
- [MAY] クライアントは、大きすぎるフィールド行を受信した場合、そのフィールドの意味論上、
  値を破棄または切り詰めてもメッセージのフレーミングやレスポンスの意味論が変化しないのであれば、
  それらのフィールド行を破棄または切り詰めてもよい

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値には先頭や末尾の空白文字は含まれない
  - [MUST] 特定のHTTPバージョンでそのような空白がメッセージ中に現れ得る場合、
    フィールド解析実装はフィールド値を評価する前にそれらの空白を除去しなければならない
- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
  - 歴史的にはHTTPはISO-8859-1文字集合 [ISO-8859-1] のテキストを含むフィールド内容を許可しており、
    他の文字集合は [RFC2047] のエンコーディングを通じてのみサポートされてきた
  - [SHOULD] 新たに定義されるフィールドの仕様は、その値を可視US-ASCIIオクテット (VCHAR) 、SP、HTABに制限すべき
  - [SHOULD] 受信者は、フィールド内容中のその他の許可オクテット (obs-text) を不透明なデータとして扱うべきである
- CR / LF / NULを含むフィールド値は無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
  - [MUST] CR / LF / NUL文字をフィールド値内に受信した受信者はメッセージを拒否するか、
    各文字をSPに置き換えた上で処理または転送を続行しなければならない
  - [MAY] 他のCTL文字を含むフィールド値も無効であるが、安全な文脈に限っては堅牢性のために保持してもよい
- Singleton fields ... フィールド値として単一の要素のみを想定するフィールド
- List-based fields ... フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
  - [ought to] HTTP-dateやURI-referenceのように要素内部にカンマを含み得るフィールドは、
    そのデータ内のカンマとリスト区切りのカンマを区別できるよう、区切り記号で囲む形で定義されるべき

```
Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される
  - [ought to]両形式を許可する場合、パラメータ値の意味は
    tokenとして受信された場合でもquoted-stringとして受信された場合でも同一であるべき

### Common Rules for Defining Field Values
#### Lists (#rule ABNF Extension)
- リストベースのフィールド値定義の可読性を高めるために [RFC5234] のABNF 規則に対する`#rule`拡張が用いられる

```
<n>#<m>element

最小 <n> 個、最大 <m> 個のelementからなるリスト
各要素は単一のカンマと任意の空白 (OWS) で区切る
```

- 送信者の要件:
  - [MUST NOT] リスト構文を使用するすべての生成規則において、送信者は空のリスト要素を生成してはならない
  - 送信者は次の構文を満たすリストのみを生成しなければならない:
    - `1#element => element *( OWS "," OWS element )`
    - `#element => [ 1#element ]`
    - n ≥ 1 かつ m > 1 の場合:
      - `<n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )`
- 受信者の要件:
  - 空の要素は要素数のカウントに含めない
  - [MUST] 受信者は、合理的な数の空要素を解析して無視しなければならない。空の要素は要素数のカウントに含めない
    - 値の結合など送信者のよくある誤りに対処できる程度である一方、DoS攻撃に利用されない範囲に限定される必要がある
  - 受信者は次の構文を満たすリストを受け入れなければならない:
    - `#element => [ element ] *( OWS "," OWS [ element ] )`
  - すべてのケースは、個数指定がないものとして扱われる。

```
e.g.
example-list      = 1#example-list-elmt
example-list-elmt = token ; 5.6.2 節参照

このとき、

以下の値はexample-listとして有効:
"foo,bar"
"foo ,bar,"
"foo , ,bar,charlie"

以下の値はexample-listとして無効:
""
","
",   ,"
```

#### Tokens
- トークンは、空白や区切り文字を含まない短いテキスト識別子

```
token          = 1*tchar

tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
               / DIGIT / ALPHA
               ; 区切り文字を除く任意の VCHAR
```

- 多くのHTTP フィールド値は、共通の構文要素を空白、または特定の区切り文字で分離して定義されている
- 区切り文字は、トークンに含めることが許可されていないUS-ASCIIの可視文字から選ばれる
  - DQUOTE および `"(),/:;<=>?@[\]{}`

#### Whitespace
- OWS (optional whitespace)
  - 0個以上の線形空白オクテットが出現し得る場所で用いられる空白
  - [SHOULD] 可読性向上のために任意空白が望ましい場合、送信者は単一のSP として生成する
  - [SHOULD NOT] それ以外の場合、送信者は必要な場合を除き任意空白を生成すべきではない
- RWS (required whitespace)
  - フィールドトークンを分離するため、少なくとも1つの線形空白が必要な場合に用いられる空白
  - [SHOULD] 送信者はRWSを単一のSPとして生成する
  - OWSとRWSは、意味論的には単一のSPと同等
    - [MAY] OWSまたはRWSと定義されているコンテントは、解釈や転送の前に単一のSP に置き換えてよい
- BWS ("bad" whitespace)
  - 歴史的理由のみで文法が任意空白を許している箇所に用いられる空白
  - [MUST NOT] 送信者はBWSを生成してはならない
  - [MUST]受信者はBWSを解析して除去しなければならない
  - BWS には意味論はない。BWS と定義されている内容は、解釈や転送の前に 削除してよい（MAY）。

```
OWS =  *( SP / HTAB ) ; optional whitespace
RWS = 1*( SP / HTAB ) ; required whitespace
BWS = OWS             ; "bad" whitespace
```

#### Quoted Strings
- テキストの文字列は二重引用符`"`で囲まれている場合、単一の値として解析される

```
quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
```

- `"\"`は、quoted-stringおよびcomment構文内での1オクテットのエスケープ機構として使用できる
- [MUST] quoted-stringの値を処理する受信者はquoted-pairを、バックスラッシュの直後のオクテットに置き換えたものとして
  扱わなければならない

```
quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```

- [SHOULD NOT] 送信者は、引用符付き文字列内に存在するDQUOTEおよび`\`を引用符で囲む必要がある場合を除き、
  quoted-string内にquoted-pairを生成すべきではない
- [SHOULD NOT] 送信者は、コメント内に存在する括弧`()`および`\`を引用符で囲む必要がある場合を除き、
  comment内にquoted-pairを生成すべきではない

#### Comments
- 丸括弧で囲むことにより、いくつかのHTTPフィールド内にコメントを含めることができる
- コメントは、フィールド値定義に`comment`が含まれているフィールドにのみ許可される

```
comment        = "(" *( ctext / quoted-pair / comment ) ")"
ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

#### Parameters
- パラメータは`name/value`の組として表現される (e.g. `Media-Type`、`Accept`)
  - フィールド値に補助的な情報を付加するための共通構文としてよく用いられる
  - 各パラメータは通常、直前のセミコロン`;`によって区切られる

```
parameters      = *( OWS ";" OWS [ parameter ] )
parameter       = parameter-name "=" parameter-value
parameter-name  = token
parameter-value = ( token / quoted-string )
```

- パラメータ名は大文字・小文字を区別しない
- パラメータ値が大文字・小文字を区別するかどうかは、そのパラメータ名の意味論に依存する
- token構文に合致するparameter値は、tokenとして送信しても、quoted-string として送信しても等価
- parameterでは、`=`の前後にいかなる空白も許可されない

#### Date/Time Formats
- 歴史的経緯により日付/時刻フォーマットは3形式が定義されている
- 推奨フォーマットは、Internet Message Format [RFC5322] で用いられる日付・時刻仕様のうち、
  固定長かつ単一タイムゾーンに限定したサブセット

```
HTTP-date = IMF-fixdate / obs-date

推奨形式:
Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

廃止形式:
Sunday, 06-Nov-94 08:49:37 GMT   ; 廃止されたRFC 850形式
Sun Nov  6 08:49:37 1994         ; ANSI Cのasctime() 形式
```

```
推奨形式:
IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT

day-name     = %s"Mon" / %s"Tue" / %s"Wed"
             / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

date1        = day SP month SP year
             ; 例: 02 Jun 1982

day          = 2DIGIT
month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
             / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
             / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
year         = 4DIGIT

GMT          = %s"GMT"

time-of-day  = hour ":" minute ":" second
             ; 00:00:00 - 23:59:60（うるう秒を含む）

hour         = 2DIGIT
minute       = 2DIGIT
second       = 2DIGIT
```

```
廃止形式:

obs-date      = rfc850-date / asctime-date

rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
date2        = day "-" month "-" 2DIGIT
             ; 例: 02-Jun-82

day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
             / %s"Thursday" / %s"Friday" / %s"Saturday"
             / %s"Sunday"

asctime-date = day-name SP date3 SP time-of-day SP year
date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
             ; 例: Jun␠␠2
```

- [MUST] HTTPフィールド内のタイムスタンプ値を解析する受信者は、これら3種類すべてのHTTP-date形式を受け入れる
- [MUST] 送信者がHTTP-dateとして定義されたタイムスタンプを含むフィールドを生成する場合、
  必ずIMF-fixdate形式で生成しなければならない
- HTTP-dateの値はUTC時刻を表す
  - クロックは、UTCにおける現在時刻を妥当に近似して提供できる実装のこと
  - クロック実装はNTP [RFC5905] やそれに類するプロトコルを用いてUTCと同期することが望ましい
- HTTP-dateは大文字・小文字を区別する
  - [CACHING] 4.2 にて、キャッシュ受信者に対してこの制約が緩和されている
- [MUST NOT] 送信者は、文法でSPとして明示的に含まれているもの以外の追加の空白を HTTP-date 内に生成してはならない
- day-name、day、month、year、time-of-dayの意味論は、Internet Message Formatの構成要素 [RFC5322] 3.3 と同一
- [MUST] RFC 850形式のように2桁の年を用いるタイムスタンプを受信した場合、
  現在より50年以上未来を指しているように見える値は、過去で最も近い同じ下2桁の年として解釈しなければならない
- フィールド定義で特に制限されていない限り、受信者はタイムスタンプ解析において堅牢であることが推奨される
  - HTTP以外の情報源から転送されたメッセージが、Internet Message Formatで定義された
    いずれかの日付・時刻仕様を生成することがあるため

## Message Abstraction (HTTPメッセージの抽象型) https://www.ietf.org/rfc/rfc9110.html#name-message-abstraction
- HTTPの各メジャーバージョンは、それぞれ独自の構文を用いてメッセージを通信する
  - Message Abstractionはメッセージの特性・共通構造・意味を伝達する能力を一般化したHTTPメッセージの抽象型を定義する
    - この抽象化はHTTPのバージョンに依存しない形で送信者および受信者の要件を定義するために用いられ、
      あるバージョンのメッセージを別のバージョンを介して中継しても、その意味が変わらないことを目的とする
- メッセージの構成要素
  - Control data (制御データ) メッセージを記述し、経路制御するために必要な情報
    - 受信者が即座に知る必要のある事項
  - Headers lookup table (ヘッダ表) 制御データを拡張し、送信者・メッセージ・内容の追加情報を伝える名前:値の組の集合
    - 受信者がコンテンツ受信前に知る必要のある事項
  - Content (コンテンツストリーム) 任意・潜在的にサイズ無制限のストリーム
    - メッセージのセマンティクスを満たすために受信者が必要とする本体
  - Trailers lookup table (トレーラ表) コンテン送信中に得られた情報を伝えるための名前:値の組の集合
    - コンテンツ送信前には不明であった任意のメタデータ
- メッセージの送信順
  - フレーミングおよび制御データ
  - ヘッダテーブルのフィールドを含むヘッダーセクション
  - (任意) コンテンツ
  - (任意) トレーラーテーブルのフィールドを含むトレーラーセクション
- メッセージはストリームとして前方から処理されることが想定されている
  - そのストリームの目的や処理の継続性は、読み進める過程で明らかになる
- メッセージは自己記述的であることが意図されている
  - 受信者がメッセージについて知る必要がある情報はすべて、
    送信中に圧縮または省略された部分をデコードまたは再構成した後、メッセージ自体を参照することで判断できる
    - 送信者の現在のアプリケーション状態 = 過去のメッセージによって確立され他状態を理解する必要はない
    - クライアントは対応するレスポンスを解析、解釈、キャッシュする際、リクエストに関する知識を保持する必要がある
      - e.g. HEADメソッドとGETのそれぞれのレスポンスは先頭部分の見た目は同じがだが同じように解析することはできない

### Framing and Completeness
- メッセージフレーミングは、各メッセージの開始と終了を示す
  - 各メッセージを同じ接続上の他のメッセージやノイズと区別するための仕組み
  - HTTPはメジャーバージョンごとに独自のフレーミングメカニズムを定義する
- HTTP/0.9 および初期のHTTP/1.0では接続のクローズを以てレスポンスの終了としていた (暗黙的なフレーミング)
  - HTTP/1.1でも後方互換性のため許可されている
  - 接続が早期に閉じられた場合、不完全なレスポンスを区別できない可能性がある
    - ほとんどの最新の実装では、メッセージデータを長さで区切る形式で明示的なフレーミングを行う
      - HTTP/1.1の`Content-Length`、`Transfer-Encoding: chunked`
      - HTTP/2およびHTTP/3のフレーム境界
- メッセージは、そのフレーミングで示されるすべてのオクテットが利用可能な時点で完了したとみなされる
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- メッセージは、その主な目的を示す制御データで始まる
  - リクエストメッセージの制御データには以下が含まれる:
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データには以下が含まれる:
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前では、制御データはメッセージの1行目として送信される
- HTTP/2およびHTTP/3では、制御データは予約名プレフィックス付きの擬似ヘッダーフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージにはプロトコルバージョンがある
  - 使用されているバージョンに応じて、メッセージ内で明示的に識別される場合もあれば、
    メッセージが受信された接続から推測される場合もある
  - 受信者はバージョン情報を使用し、送信者との以降の通信における制限事項や可能性を判断する
- メッセージが中継者によって転送された場合、プロトコルバージョンはその中継者が使用するバージョンへ更新される
  - `Via`ヘッダーフィールド は、転送されたメッセージ内で上流プロトコル情報を伝達するために使用される
- [SHOULD] クライアントは自身が準拠している中で最も高いバージョン、
  かつサーバが対応していると分かっている最も高いバージョンをリクエストバージョンとして送信するべき
  - [MUST NOT] クライアントは、自身が準拠していないバージョンを送信してはいけない
- [MAY] サーバがHTTP仕様を誤って実装していることが分かっている場合、
  クライアントはより低いリクエストバージョンを送信してもよいが、
  これはクライアントが少なくとも1つの通常のリクエストを試行し、
  レスポンスのステータスコードやヘッダフィールドの情報から
  サーバがより高いリクエストバージョンを適切に処理していないことを確認した後に限る
- [SHOULD] サーバは、サーバ自身が準拠している最高バージョンに等しいレスポンスバージョンを送信すべき
  - ただし、リクエストで受信したバージョン以下であること
  - [MUST NOT] サーバは、自身が準拠していないバージョンを送信してはいけない
  - サーバは、何らかの理由でクライアントのメジャープロトコルバージョンのサービスを拒否したい場合、
    505 HTTP Version Not Supported レスポンスを送信してもよい
- [SHOULD] 受信者は、自身が実装しているメジャーバージョン番号およびそれよりも高いマイナーバージョン番号を持つ
  メッセージを受信した場合そのメッセージを、受信者が準拠しているメジャーバージョン内で
  最も高いマイナーバージョンであるかのように処理する必要がある
  - 受信者は、より高いマイナーバージョンのメッセージが
    まだそのバージョンへの対応を示していない受信者に送信されたとしても、
    同一メジャーバージョン内であれば後方互換性が十分に保たれており、安全に処理できると仮定してよい

### Header Fields
- ヘッダフィールドは、コンテンツの前に送受信されるフィールド
- メッセージのヘッダセクションは、一連のヘッダーフィールド行 (フィールド名 + フィールド値) で構成される
  - 各ヘッダーフィールドは、メッセージのセマンティクスを変更または拡張したり、送信者を記述したり、
    コンテンツを定義したり、追加のコンテキストを提供したりする場合がある

### Content
- HTTPメッセージは多くの場合、メッセージのコンテンツとして、表現の全体または一部を転送する
  - コンテンツはメッセージフレーミングによって定義され、ヘッダセクションの後に送信される
    オクテットのストリームとして送信される
- コンテンツの抽象的定義は、メッセージフレーミングから取り出された後のデータを指す
  - e.g. HTTP/1.1メッセージボディは、チャンク転送コーディングでエンコードされたデータストリーム
    (一連のデータチャンク、長さゼロのチャンク1つ、およびトレーラーセクション) で構成される場合がある。
    しかしそのメッセージのコンテンツに含まれるのは転送符号化をデコードした後のデータストリームのみであり、
    チャンク長、チャンク化のフレーミング構文、トレーラフィールドは含まれない

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

- リクエストにおけるコンテンツの目的は、リクエストメソッドの意味論によって定義される
  - e.g. PUTリクエストのコンテンツにおける表現 ... リクエストが正常に適用された後の対象リソースの望ましい状態
    POSTリクエストのコンテンツにおける表現 ... 対象リソースによって処理される情報を表
- レスポンスにおけるコンテンツの目的は、リクエストメソッド、ステータスコード、
  コンテンツを記述するレスポンスフィールドによって定義される
  - e.g. GETに対する200 OK レスポンスのコンテンツ ... メッセージ送信日における対象リソースの現在の状態
    POSTレスポンスにおける同じステータスコードのコンテンツ ... 処理結果または処理適用後の対象リソースの新しい状態
  - GETに対する206 Partial Content レスポンスのコンテンツは、選択された表現の単一部分、
    または複数の部分を含むmultipartメッセージボディのいずれか
  - エラーステータスコードを持つレスポンスメッセージには通常、
    エラー状態を表す内容 (エラー状態と、それを解決するための推奨手順) が含まれる
  - HEADリクエストへのレスポンスにはコンテンツは含まれない
    - 関連するレスポンスヘッダフィールドは、リクエストメソッドがGETであった場合の値のみを示す
  - CONNECTリクエストへの2xx Successful レスポンスはコンテンツを含める代わりに接続をトンネルモードに切り替える
  - 1xx Informational、204 No Content、304 Not Modified レスポンスにはコンテンツは含まれない
  - その他のレスポンスにはコンテンツが含まれるが、サイズは0になる場合がある

#### Identifying Content
- 完全または部分的な表現がコンテンツとして転送される場合、
  送信者がその特定の表現に対応するリソースの識別子を提供するか、受信者がそれを判別できると望ましい場合が多い
- リクエストメッセージの場合:
  - リクエストに`Content-Location`ヘッダフィールドがある場合:
    - 送信者はそのコンテンツが`Content-Location`フィールド値で識別されるリソースの表現であると主張している。
      ただしこのような主張は、他の手段によって検証されない限り信頼できない。
  - それ以外の場合:
    - コンテンツはHTTPによって識別されないが、より具体的な識別子がコンテンツ自身の中で提供されている可能性がある
- レスポンスメッセージの場合:
  - 一致するものが見つかるまで以下のルールが順に適用される:
    - リクエストメソッドがHEAD、またはレスポンスステータスコードが204 No Content か304 Not Modifiedの場合:
      - レスポンスはコンテンツを含まない
    - リクエストメソッドがGET、かつレスポンスステータスコードが200 OK の場合:
      - レスポンスは対象リソースの表現をコンテンツとして含む
    - リクエストメソッドがGET、かつレスポンスステータスコードが203 Non-Authoritative Information の場合:
      - レスポンスは中継者によって提供された対象リソースの潜在的に変更または拡張された表現をコンテンツとして含む
    - リクエストメソッドがGET、かつレスポンスステータスコードが206 Partial Contentの場合:
      - レスポンスは対象リソースの表現の一部をコンテンツとして含む
    - レスポンスに`Content-Location`ヘッダフィールドがあり、そのフィールド値が対象URIと同じURIへの参照である場合:
      - レスポンスは対象リソースの表現をコンテンツとして含む
    - レスポンスに`Content-Location`ヘッダフィールドがあり、その値が対象URIとは異なるURIへの参照である場合:
      - 送信者はコンテンツが`Content-Location`フィールド値で識別されるリソースの表現であると主張する。
        ただしこのような主張は、他の手段によって検証されない限り信頼できない。
    - それ以外の場合:
      - コンテンツはHTTPによって識別されないが、より具体的な識別子がコンテンツ自身の中で提供されている可能性がある

### Trailer Fields
- トレーラセクション内に配置されたフィールドは、
- トレーラフィールドは、トレーラセクション内に配置されたフィールドのこと
  - トレーラーフィールドは、メッセージの整合性チェック、デジタル署名、配信メトリクス、
    後処理ステータス情報の提供などを行う
- [ought to] トレーラフィールドは、ヘッダセクション内のフィールドとは別に処理および保存するべき
  - ヘッダセクションが完成した時点で既に分かっているメッセージの意味論との矛盾を避けるため
- 特定のヘッダフィールドの有無は、トレーラを受信する前に行われたメッセージ全体のルーティングや処理の選択に
  影響を与える可能性があり、これらの選択は、後からトレーラフィールドが発見されたとしても取り消すことはできない

#### Limitations on Use of Trailers
- トレーラセクションは、使用しているHTTPのバージョンによってサポートされており、
  明示的なフレーミングメカニズムによって有効化されている場合にのみ使用できる
  - e.g. HTTP/1.1のチャンク転送コーディングでは、コンテンツの後にトレーラーセクションを送信できる
- 多くのフィールドはコンテンツの受信前に評価する必要があるため、ヘッダセクションの外で処理することができない
  - メッセージのフレーミング
  - ルーティング
  - 認証
  - リクエスト修飾子
  - レスポンス制御
  - コンテンツ形式を記述するフィールド など
  - コンテンツを受信する前に評価する必要があるため、ヘッダセクションの外で処理することはできません。
  - [MUST NOT] 送信者は対応するヘッダフィールド名の定義によって、そのフィールドがトレーラとして送信されることを
    許可していると分かっている場合を除いて、トレーラーフィールドを生成してはならない
- トレーラフィールドは、あるプロトコルバージョンから別のプロトコルバージョンにメッセージを転送する中継者にとって
  処理が困難な場合がある
  - メッセージ全体を転送中にバッファリングできる場合、中継者によっては、
    転送前にトレーラフィールドをヘッダセクションにマージできる可能性がある
    - ほとんどの場合、トレーラーは単に破棄される
    - [MUST NOT] 受信者が対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラフィールドの値を
      安全にマージする方法を明示的に許可および定義している場合を除き、
      トレーラフィールドをヘッダセクションにマージしてはならない
- `TE`リクエストヘッダフィールドにキーワード`trailers`が含まれる場合、
  クライアントは自身および下流のクライアントのためにトレーラフィールドを受け入れる意思があることを示す
  - 中継者からのリクエストの場合、すべての下流クライアントが転送されたレスポンス内のトレーラフィールドを
    受け入れる意思があることを意味する
  - `trailers`はクライアントがレスポンス内の特定のトレーラフィールドを処理することを意味するわけではなく、
    トレーラセクションがどのクライアントによっても破棄されないことを意味する
- [SHOULD NOT] トレーラフィールドは転送中に破棄される可能性があるため、
  サーバーはユーザーエージェントが受信する必要があると思われるトレーラーフィールドを生成すべきではない

#### Processing Trailer Fields
- `Trailer`レスポンスヘッダフィールドは、トレーラセクションで送信される可能性のあるフィールド名を事前に示す
  - これにより、受信者はコンテンツを処理する前に受信の準備をすることができる
  - e.g. フィールド名がコンテンツの受信時に動的なチェックサムを計算し、トレーラフィールド値を受信したら
    すぐにチェックする必要があることを示している場合などに有用
- ヘッダフィールドと同様、同じ名前のトレーラフィールドは受信順に処理され、
  同じ名前のトレーラフィールド行が複数ある場合は複数の値をメンバーのリストとして追加するのと同等の意味を持つ
  - [MUST] メッセージ中に複数回生成される可能性のあるトレーラフィールドは、
    たとえ各メンバ値が受信フィールド行ごとに一回しか処理されなかったとしても、
    リスト型のフィールドとして定義されなければならない
- [MAY] メッセージの末尾で、受信者は受信したトレーラフィールドの集合を、
  ヘッダフィールドと同じような (ヘッダーフィールドとは別の) 名前:値の組のデータ構造として扱ってもよい
  - トレーラでの利用を意図したフィールドに関する追加の処理要件がある場合は、そのフィールド仕様の中で定義できる

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- `Date`ヘッダフィールドは、メッセージが生成された日時を表す
  - [RFC5322] 3.6.1 で定義されている`orig-date`と同じ意味
  - フィールド値はHTTP-date形式
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Date

```
Date = HTTP-date
```

```
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

- [SHOULD] `Date`ヘッダフィールドを生成する送信者は、フィールド値をメッセージ生成日時の可能な限り近似値にするべき
  - 理論上、日付はメッセージコンテンツを生成する直前の時点を表す必要がある
  - 実際には、送信者はメッセージ生成中の任意の時点で日付値を生成できる
- [MUST] クロックを持つオリジンサーバは、すべての2xx、3xx、4xxレスポンスに`Date`を生成しなければならない
  - [MAY] 1xx、5xxレスポンスにも`Date`を生成してもよい
- [MUST NOT] クロックを持たないオリジンサーバーは、`Date`を生成してはならない
- [MUST] クロックを持つ受信者が、`Date`のないレスポンスメッセージを受信した場合、
  その受信時刻を記録し、そのメッセージがキャッシュまたは下流に転送される場合は、
  対応する`Date`をメッセージのヘッダーセクションに追加しなければならない
- [MAY] クロックを持つ受信者が、無効な`Date`ヘッダフィールド値を持つレスポンスを受信した場合、
  その値をレスポンスの受信時刻に置き換えてもよい
- [MAY] ユーザーエージェントはリクエストにDateヘッダーフィールドを含めてもよい
  - が、サーバーにとって有用な情報を伝えると考えられる場合を除いて、通常は送信しない
  - e.g. HTTPのカスタムアプリケーションでは、ユーザーエージェントとサーバーのクロックの違いに基づき
    サーバーがユーザーの要求の解釈を調整することが予想される場合、`Date`を送信することがある

#### Trailer
- `Trailer`ヘッダフィールドは、送信者がメッセージ内でトレーラフィールドとして送信することを想定している
  フィールド名のリストを提供する
  - 受信者はこれにより、コンテンツの処理を開始する前に指定されたメタデータの受信に備えることができます
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Trailer

```
Trailer = #field-name
```

- e.g. 送信者がコンテンツをストリーミングしながら署名を計算し、最終的な署名値をトレーラフィールドとして送信する場合
  `Trailer`ヘッダによって署名フィールドの存在を事前に示しておけば、受信者はコンテンツを受信しつつ、
  同時に検証処理を行うことができる
- [SHOULD] メッセージ内に1つ以上のトレーラフィールドを生成する送信者は、
  そのメッセージのヘッダセクションに`Trailer`ヘッダフィールドを生成することによって
  トレーラに含まれる可能性のあるフィールドを示すべき
- 中継者が転送中にトレーラセクションを破棄した場合、
  `Trailer`フィールドは失われたメタデータのヒントとなる可能性がある
  - ただし`Trailer`の送信者が常に指定されたフィールドを送信するという保証はない

## Routing HTTP Messages https://www.ietf.org/rfc/rfc9110.html#name-routing-http-messages
- HTTPリクエストメッセージのルーティングは、対象リソース、クライアントのプロキシ設定、
  受信接続の確立または再利用に基づいて各クライアントが決定する
- 対応するレスポンスのルーティングは同じ接続経路を逆方向にたどってサーバからクライアントへ返送される

### Determining the Target Resource
- HTTPにおいてほとんどのクライアントは汎用Webブラウザと同じリソース識別メカニズムと設定手法を利用している
  - 通信オプションがクライアントの設定にハードコードされていても、それらを総合した結果をURI参照と考えることができる
  - URI参照は絶対形式に解決されると、ターゲットURI (Target URI) となる
  - ターゲットURIは、参照のフラグメント要素を除外する
    - フラグメント識別子がクライアント側処理用に予約されているため ([URI] 3.5)
- ターゲットリソース (Target Resource: クライアントが操作したいリソースそのもの) に対してアクションを実行するため、
  クライアントは、受信側がそのリソースを識別できる解析済みターゲットURI (リクエストターゲット) の構成要素を含む
  リクエストメッセージを送信する
  - 歴史的な理由からリクエストターゲットは、メッセージ制御データと`Host`ヘッダフィールドに含めて送信される
    - 例外1) CONNECTの場合、リクエストターゲットはトンネル接続先の`ホスト名:ポート番号`
    - 例外2) OPTIONSの場合、リクエストターゲットは`*`にすることができる
    - [MUST NOT] これらの形式は他のメソッドと組み合わせて使用してはならない
- サーバはクライアントからのリクエストを受信すると、ローカル設定と受信接続の文脈に基づき、
  受信した構成要素からターゲットURIを再構築する
  - 再構築の方法は主要なプロトコルバージョンごとに異なる

### Host and :authority
- リクエストにおける`Host`ヘッダフィールドは、対象URIに含まれるホスト名およびポート情報を提供し、
  オリジンサーバが複数のホスト名に対するリクエストを処理する際に対象のリソースを識別できるようにする
  - HTTP/2 or 3では場合によってリクエスト制御データに含まれる`:authority`擬似ヘッダフィールドが`Host`の役割を担う
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Host
    - リクエストの送信先のサーバのホスト名とポート番号を指定する
- クライアントはリクエストに`Host`ヘッダフィールドもしくは`:authority`擬似ヘッダーフィールドを必ず含める

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

- リクエストにおける`Host`ヘッダフィールドは、ターゲットURIのホストとポート番号の情報を提供する
  - これにより、オリジンサーバは複数のホスト名へのリクエストを処理する際にリソースを区別することができる
  - HTTP/2 [HTTP/2] および HTTP/3 [HTTP/3] では、
    リクエストの制御データに含まれる`:authority`疑似ヘッダフィールドが`Host`ヘッダフィールドを置き換える場合がある

```
Host = uri-host [ ":" port ] ; Section 4
```

- [MUST] ターゲットURIのauthorityの情報はリクエストの処理において非常に重要であるため、
  ユーザーエージェントはリクエスト内で`Host`ヘッダフィールドを生成しなければならない
    - ターゲットURIの権限情報を`:authority`疑似ヘッダーフィールドとして送信する場合を除く
  - [SHOULD] `Host`を送信するユーザーエージェントは、リクエストのヘッダセクションの最初のフィールドとして
    `Host`を送信すべき

```
(e.g. オリジンサーバの http://www.example.org/pub/WWW/ へのGETリクエストの場合)
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

- ホスト名とポート番号の情報はアプリケーションレベルのルーティングメカニズムとして機能するため、
  共有キャッシュを改ざんしたり、リクエストを意図しないサーバーにリダイレクトしようとするマルウェアの標的となりがち
  - 透過プロキシは、接続先IPアドレスがそのホスト名に対して正当なものであるかを検証しないまま、
    ホスト名・ポート情報を内部サーバへの振り分けや共有キャッシュのキーとして使用すると、特に脆弱になりやすい

### Routing Inbound Requests
- ターゲットURIとそのオリジンが決定されると、クライアントは目的の意味論を実現するため
  ネットワークリクエストが必要かどうか、必要であればリクエストをどこに送信すべきかを決定する

#### To a Cache
- クライアントがキャッシュ [CACHING] を持ち、そのリクエストがキャッシュによって満たされる場合、
  リクエストはまずキャッシュへ送信される

#### To a Proxy
- リクエストがキャッシュによって満たされない場合、典型的なクライアントは自身の設定を確認し、
  リクエストを満たすためにプロキシを使用するかどうかを判断する
  - プロキシの設定は実装に依存するが、多くの場合はURIプレフィックスの一致、authorityの選択的な一致、
    あるいはその両方に基づいて決定される
  - プロキシ自体は通常httpまたはhttps URIで識別される
- httpまたはhttpsプロキシが適用可能な場合、クライアントは当該プロキシへの接続を確立または再利用し、
  ターゲットURIに一致するリクエストターゲットを含むHTTPリクエストメッセージをプロキシ宛に送信する

#### To the Origin
- 適用可能なプロキシがない場合、典型的なクライアントはターゲットURIのスキームに固有のハンドラルーチンを呼び出し、
  特定されたリソースへのアクセスを行う
  - リクエストターゲットがhttpリソースの場合、識別されたオリジンサーバへの接続を確立または再利用し、
    ターゲットURIに一致するリクエストターゲットを含むHTTPリクエストを送信する
  - リクエストターゲットがhttpsリソースの場合、
    識別されたオリジンに対して権威を持つオリジンサーバとのセキュアな接続を確立または再利用し、
    その上でターゲットURIに一致するリクエストターゲットを含むHTTPリクエストを送信する

### Rejecting Misdirected Requests (誤った宛先へのリクエストの拒否)
- サーバはリクエストを受信し、そのターゲットURIを特定できた後、そのリクエストへの対応を決定する
  - リクエストを自身で処理する
  - リクエストを別のサーバに転送するか
  - クライアントを別のリソースにリダイレクトする
  - エラーで応答する
  - 接続を切断する
- この決定は、リクエストまたは接続コンテキストに関するあらゆる情報に左右される
  - 特にサーバがそのターゲットURIへのリクエストを処理するように設定されているかどうか、
    および接続コンテキストがそのリクエストに適切かどうかに左右される
  - リクエストが意図的または偶発的に誤った宛先に送られ、`Host`の情報が接続のホストやポートと異なる可能性がある
    - 接続が信頼できるゲートウェイからのものであれば、このような不一致も想定内としてありえるが、
      そうでない場合はセキュリティフィルタをバイパスしようとしたり、サーバを騙して非公開コンテンツを配信させたり、
      キャッシュをポイズニングしようとしたりしている可能性がある
  - [MUST] 接続元が信頼されたゲートウェイでない限り、オリジンサーバは、
    ターゲットURIのスキーム固有の要件が満たされていない場合はリクエストを拒否しなければならない
    - [MUST] 特にhttpsリソースへのリクエストは、ターゲットURIのオリジンに対して有効な証明書によって
      保護された接続を介して受信されない限り、拒否しなければならない
- レスポンスのステータスコード421 Misdirected Request は、
  リクエストが誤って送信された可能性があり、オリジンサーバーがリクエストを拒否したことを示す

### Response Correlation (レスポンスの対応づけ)
- 1つの接続は複数のリクエスト - レスポンス交換に使用される場合がある
- リクエストとレスポンスの組みを対応付ける仕組みはHTTPのバージョンによって異なる
- すべてのレスポンスは、ステータスコードにかかわらずリクエストの受信後であればいつでも送信できる
  - リクエストがまだ完了していない場合であっても、レスポンスが先に完了することもある
  - クライアントはレスポンスを待つために特定の時間だけ待機することを期待されてはいない
    - クライアントは、合理的な時間内にレスポンスを受信できない場合、そのリクエストを放棄することがある
  - 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に中止を示す指示を受け取らない限り、
    当該リクエストの送信を継続すべき

- 1つのコネクションは、複数のリクエスト / レスポンス交換に使用される場合がある
- リクエストメッセージとレスポンスメッセージの組みを関連付けるメカニズムはバージョンに依存する
  - HTTPのバージョンによって、メッセージの順序付けを暗黙的に行うものもあれば、明示的な識別子を使用するものもある
- (中間レスポンスを含む) すべてのレスポンスはステータスコードに関わらず、
  リクエストがまだ完了していなくても、リクエスト受信後にいつでも送信できる
  - 対応するリクエストが完了する前にレスポンスが完了することもある
  - クライアントはレスポンスを待つために特定の時間待つ必要はない
  - 中継者を含むクライアントは、妥当な時間内にレスポンスを受信できない場合、リクエストを破棄することがある
- [SHOULD] 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に反対の指示を受けない限り、
  そのリクエストの送信を継続すべき

### Message Forwarding
- 中継者はHTTPリクエスト/レスポンスの処理において様々な役割を果たす
  - 性能・可用性向上 (キャッシュ、ロードバランシング)
  - アクセス制御 (認証・認可、フィルタリング、セキュリティゲートウェイ)
- HTTPストリームははpipe-and-filterアーキテクチャに類似した特性を持つため、
  中継者がストリームの双方向に対しても機能を拡張 (あるいは干渉) する場合において、本質的な制限は存在しない
- 中継者は、プロトコル要素 (新しいメソッド、ステータスコード、フィールド名など) を認識できない場合でも、
  メッセージを転送することが期待される (下流の受信者に対する拡張性を維持するため)
- [MUST] トンネルとして動作しない中継者は`Connection`ヘッダフィールドを実装し、
  受信側の接続のみを意図するフィールドを転送対象から除外しなければならない
- [MUST NOT] 中継者は、無限リクエストループから保護されていない限り、メッセージを自身に転送してはならない
- 一般的に中継者は、自身のサーバ名 (エイリアス、ローカルなバリエーション、リテラルIPアドレスを含む) を認識し、
  そのようなリクエストに直接応答する必要があります
- HTTPメッセージは、段階的に処理したり下流に転送したりするために、ストリームとして解析できる
  - 送信者および受信者は、部分的なメッセージが逐次的に配信されることを前提にしてはならない
  - 一部の実装では、ネットワーク効率、セキュリティチェック、またはコンテンツ変換のために、
    メッセージ転送をバッファリングまたは遅延させるため

#### Connection
- `Connection`ヘッダフィールドは、送信者が現在の接続に必要な制御オプションを列挙するためのもの
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Connection
    - `Connection`は、現在のトランザクションが完了したあとも、ネットワーク接続を開いたままにするかどうかを制御する
      - 送信された値が`keep-alive`の場合は接続が維持され、同一のサーバに送る後続のリクエストで再利用される
      -  `Connection`や`Keep-Alive`などの接続固有のヘッダフィールドは、HTTP/2では禁止

```
Connection        = #connection-option
connection-option = token
```

- `connection-option`は大文字・小文字を区別しない
- [MUST] `Connection`以外のフィールドを現在の接続に関する制御情報の提供に使用する場合、
  送信者は対応するフィールド名を`Connection`ヘッダフィールド内に列挙しなければならない
  - HTTPの一部のバージョンでは、このような情報のためのフィールドの使用が禁止されており、
    `Connection`フィールドは許可されない
  - 注意: HTTPの一部のバージョンでは、この種の情報のためにフィールドを使用すること自体が禁止されており、
    `Connection`フィールドも許可されていない
- [MUST] 中継者は、メッセージを転送する前に受信した`Connection`ヘッダフィールドを解析し、
  このフィールド内の各`connection-option`について、
  その`connection-option`と同じ名前のヘッダフィールドまたはトレーラフィールドをメッセージから削除し、
  その後`Connection`ヘッダフィールド自体を削除 (または転送メッセージに対する中継者独自の制御オプションで置き換え)
  なければならない
  - このために、`Connection`は直近の受信者のみに意図されたフィールド (hop-by-hop) と、
    チェーン上のすべての受信者に意図されたフィールド (end-to-end) とを宣言的に区別する手段を提供する
    - これによりメッセージは自己記述的となり、将来の接続固有の拡張であっても、
      古い仲介者によって無条件に転送されてしまうことを恐れずに導入できるようになる
- [SHOULD] 中継者は`connection-option`として指定されているかどうかにかかわらず、
  転送前に削除する必要があることがわかっているフィールドを、
  それらの意味論を適用した後に削除または置換すべき
  - `Proxy-Connection`
  - `Keep-Alive`
  - `TE`
  - `Transfer-Encoding`
  - `Upgrade` など
- [MUST NOT] 送信者は、コンテンツのすべての受信者を対象とするフィールドに対応する`connection option`を
  送信してはならない
  - e.g. `Cache-Control`を`connection-option`として用いることは適切ではない
- 接続オプションは、必ずしもメッセージ内に存在するフィールドに対応するとは限らない
  - 接続固有のフィールドは、接続オプションに関連付けられたパラメータがない場合、不要になる可能性があるため
  - 接続固有のフィールドを、それに対応する接続オプションなしで受信した場合、
    通常、そのフィールドは中継者によって不適切に転送されたことを示し、受信者はそれを無視すべき
- フィールドに対応しない新しい接続オプションを定義する場合、仕様作成者は後々の衝突を避けるため、
  対応するフィールド名を予約しておくべき
  - 予約されたフィールド名はHypertext Transfer Protocol (HTTP) Field Name Registryに登録される

#### Max-Forwards
- `Max-Forwards`ヘッダフィールドは、TRACEおよびOPTIONSリクエストメソッドにおいて
  プロキシによる転送回数の上限数を明示するもの
  - クライアントが、チェーンの途中で失敗またはループしているように見えるリクエストを追跡する場合に有用
  - https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Max-Forwards
    - TRACEおよびOPTIONSメソッドで使用され、リクエストが通過するノード (通常はプロキシ) の数を制限する
    - リクエストが通過する必要があるノードの最大数を示す整数であり、各ノードでこの値が減算されて、
      次のノードに転送される
      - 宛先に到達するか、受信した`Max-Forwards`の値が0になるまで続き、その後、
        リクエストは機密性の高いヘッダを除いて200 レスポンスのボディとして返される
         - これによりクライアントは、リクエストチェーンのもう一方の端で受信されている内容 (`Via`など) を
           テストや診断のために確認できる

```
Max-Forwards = 1*DIGIT
```

- `Max-Forwards`値は、このリクエストメッセージを転送できる残り回数を示す10進整数
- [MUST] `Max-Forwards`ヘッダフィールドを含むTRACE / OPTIONSリクエストを受信した中継者は、
  リクエストを転送する前に、`Max-Forwards`の値を必ず確認・更新する
  - [MUST] 受信した値 = 0: 中継者はリクエストを転送せずに最終受信者としてレスポンスを返す
  - [MUST] 受信した値 > 0: `Max-Forwards` = `[受信した値 - 1, 中継者がサポートするMax-Forwardsの最大値].min`
- [MAY] 受信者は、TRACE / OPTIONS 以外のリクエストメソッドで受信した`Max-Forwards`ヘッダフィールドを無視してもよい

#### Via
- `Via`ヘッダフィールドは、ユーザーエージェント - サーバ間の中間プロトコルおよび中間受信者が存在することを示す
  - 電子メールの`Received`ヘッダーフィールド [RFC5322] 3.6.7 に似ている
  - `Via`は、メッセージの転送を追跡し、リクエストループを回避し、リクエスト/レスポンスチェーンにおける
    送信者のプロトコル能力を識別するために使用できる
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Via
    - フォワード / リバース両プロキシによって追加され、リクエスト / レスポンス両ヘッダに表示される
      - メッセージ転送の追跡、要求ループの回避、要求/応答チェーンに沿った送信者のプロトコル機能の識別に使用される

```
Via = #( received-protocol RWS received-by [ RWS comment ] )

received-protocol = [ protocol-name "/" ] protocol-version
                  ; 7.8 節を参照
received-by       = pseudonym [ ":" port ]
pseudonym         = token
```

- `Via`フィールド値の各要素は、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中継者は自身がそのメッセージをどのように受信したかの情報を`Via`フィールド値の末尾に追加 するため、
    最終的な`Via`の並び順は、転送経路の順序を表す
- `Via`フィールド値の各メンバは、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中継者は、自身がそのメッセージをどのように受信したかの情報をフィールド値の末尾に追加する
    最終的な`Via`の並び順は、転送経路の順序を表す
- [MUST] プロキシは転送する各メッセージにおいて、以下に説明する適切な`Via`を送信しなければならない
- [MUST] HTTP-to-HTTPゲートウェイは、各受信リクエストメッセージにおいて適切な`Via`を送信しなければならない
- [MAY] 転送されたレスポンスメッセージにおいても`Via`を送信してよい
- 各中継者において、`received-protocol`は、メッセージの上流送信者が使用したプロトコルとプロトコルバージョンを示す
  - したがって`Via`フィールド値は、リクエスト／レスポンスチェーンにおいて通知されているプロトコル能力を記録し、
    それらが下流の受信者からも可視であり続けるようにする
    - これはレスポンスや後続のリクエストにおいて、後方互換性のないどの機能が安全に使用できるかを判断するのに有用
    - 受信プロトコルがHTTPの場合、`protocol-name`は省略される
- `received-by`は通常、その後メッセージを転送した受信側サーバまたはクライアントのホストとポート番号 (オプション)
  - [MAY] 実ホストが機密情報とみなされる場合、送信者はそれを仮名に置き換えてもよい
  - [MAY] ポートが指定されていない場合、受信者は、受信プロトコルのデフォルトポートで受信したと解釈してもよい
- [MAY] 送信者は、`User-Agent`ヘッダフィールドや`Server`ヘッダフィールドと同様、
  各受信者のソフトウェアを識別するためのコメントを生成してもよい
  - [MAY] `Via`ヘッダ内のコメントはオプションであり、受信者はメッセージを転送する前にコメントを削除してもよい

```
1. クライアント -> 内部プロキシfred (HTTP/1.0)
2. 内部プロキシfred -> パブリックプロキシp.example.net (HTTP/1.1)
3. パブリックプロキシp.example.net -> オリジンサーバwww.example.com

の場合

Via: 1.0 fred, 1.1 p.example.net
```

- [SHOULD NOT] ネットワークファイアウォールのポータルとして使用される中継サーバは、明示的に有効にされていない限り
  ファイアウォール領域内のホスト名とポート番号を転送すべきではない
  - [SHOULD] 有効にされていない場合、中継サーバはファイアウォールの背後にあるホストについて、
    `received-by`のホストを、そのホストの適切な仮名に置き換えるべき
- [MAY] 中継サーバは、`Via`ヘッダフィールドリストの各エントリの`received-protocol`値が同一である場合、
  順序付けられた一連のメンバを単一のメンバに結合してもよい

```
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

-> Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

- [SHOULD NOT] 送信者は、リストのメンバすべてが同じ組織の管理下にあり、
  かつホストが既に仮名に置き換えられている場合を除き、複数のメンバを結合すべきではない
- [MUST NOT] 送信者は、異なる`received-protocol`の値を持つメンバを結合してはならない

### Message Transformations (メッセージ変換)
- 一部の中継者には、メッセージとそのコンテンツを変換する機能が備わっている
  - e.g. プロキシはキャッシュ容量を節約したり、低速なリンクのトラフィック量を削減したりするために、
    画像形式を変換することがある。
    しかし、受信コンテンツが元のコンテンツと同一であることを保証するために整合性チェックやデジタル署名が
    使用されているようなコンテンツにおいてこのような変換を行うと、運用上の問題が発生する可能性がある。
- HTTP-to-HTTPプロキシのうち、
  意味論的に重要な形でメッセージを変更するように設計または設定されているもの
  (通常のHTTP処理に必要な変更を超えて、元の送信者にとって重要、または下流の受信者にとって潜在的に重要な方法で
   メッセージを変更するもの)は変換プロキシ (transforming proxy) と呼ばれる
  - 共有アノテーションサーバ
  - マルウェアフィルタ
  - フォーマット変換
  - プライバシーフィルタ など
  - このような変換は、プロキシを選択したクライアントが希望するものとみなされる
- [MAY] プロキシが、完全修飾ドメイン名ではないホスト名を持つターゲットURIを受信した場合、リクエストを転送する際に、
  受信したホスト名に自身のドメイン名を追加してもよいものとする
  - [MUST NOT] ターゲットURIに完全修飾ドメイン名が含まれている場合、プロキシはホスト名を変更してはいけない
- [MUST NOT] プロキシは、転送プロトコルで要求されている場合やその転送プロトコルで要求されている場合を除き、
  受信したターゲットURIを次の受信サーバに転送する際に、
  受信したターゲットURIの「絶対パス」および「クエリ」部分を変更してはいけない
  - e.g. HTTP/1.1経由でオリジンサーバにリクエストを転送するプロキシは、リクエストメソッドに応じて、
    空のパスを`/` ([HTTP/1.1] 3.2.1) または`*` ([HTTP/1.1] 3.2.4) に置き換える
- [MUST NOT] プロキシは、`no-transform`キャッシュ指示子 [CACHING] 5.2.2.6 を含む
  レスポンスメッセージのコンテンツを変換してはならない
  - 転送コーディングの追加または削除 [HTTP/1.1] 7 など、内容を変更しないメッセージ変換の場合は除く
- [MAY] プロキシは、`no-transform`キャッシュ指示子を含まないメッセージのコンテンツを変換してもよい
  - 200 OK レスポンスの内容を変換するプロキシは、レスポンスステータスコードを203 Non-Authoritative Information に
    変更することで、下流の受信者に変換が適用されたことを通知することができる
- [SHOULD NOT] プロキシは、通信チェーンのエンドポイント、リソースの状態、選択された表現 (コンテンツ以外) に関する
  情報を提供するヘッダフィールドを変更すべきではない
  - 当該フィールドの定義によって明示的にそのような変更が許可されている、
    あるいはプライバシーやセキュリティのために変更が必要であると判断される場合を除く

### Upgrade
- `Upgrade`ヘッダフィールドは、同一接続において HTTP/1.1から他のプロトコルへ移行するための
  シンプルなメカニズムを提供することを目的とする
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Upgrade
    - すでに確立されたクライアント-サーバ間のプロトコルを、同じ転送プロトコルを通じて、異なるプロトコルへ
      アップグレードするために使用される
      - e.g. HTTP/1.1 -> HTTP/2、HTTPやHTTPS -> WebSocket


- [MAY] クライアントは、リクエストの`Upgrade`ヘッダフィールドにプロトコル名のリストを送信することで、
  サーバが最終レスポンスを送信する前に、指定されたプロトコルのうち1つ以上のプロトコル (優先順位の高い順) へ
  切り替えるように促す
  - [MAY] サーバは、その接続で現在のプロトコルを引き続き使用する場合、受信した`Upgrade`を無視してよい
    - `Upgrade`は、プロトコルの変更を強制するために使用することはできない

```
Upgrade = #protocol

protocol = protocol-name ["/" protocol-version]
protocol-name = token
protocol-version = token
```

- [SHOULD] プロトコル名は大文字と小文字を区別せずに登録されるが、
  受信者は各`protocol-name`とサポートされているプロトコルを照合する際、大文字と小文字を区別しない比較を行うべき
- [MUST] 101 Switching Protocols レスポンスを送信するサーバは、接続を切り替えられる新しいプロトコルを示すため、
  `Upgrade`ヘッダフィールドを送信しなければならない
- [MUST] 複数のプロトコル層を切り替える場合、送信者はプロトコルを層の昇順で列挙しなければならない
- [MUST NOT] サーバは、対応するリクエストの`Upgrade`でクライアントが示していないプロトコルに切り替えてはならない
- [MAY] サーバは、クライアントが示した優先順位を無視し、リクエストの性質やサーバーの現在の負荷など、
  他の要因に基づいて新しいプロトコルを選択することもできる
- [MUST] 426 Upgrade Required レスポンスを送信するサーバは、受け入れ可能なプロトコルを優先順位の降順で示す
  `Upgrade`ヘッダフィールドを送信しなければならない
- [MAY] サーバは、将来のリクエストに適切である場合、リストされたプロトコルへの優先順位の降順でのアップグレードを
  サポートしていることを通知するため、その他のレスポンスで`Upgrade`ヘッダフィールドを送信してもよい

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
```

- プロトコル変更後のアプリケーション層の通信の機能と性質は、選択された新しいプロトコルに完全に依存する
  - ただし101 Switching Protocols レスポンスを送信した直後のサーバは、新しいプロトコルで同等のリクエストを
    受信したかのように、元のリクエストへの応答を継続することが期待される
    (= プロトコル変更後もサーバは未処理のリクエストを処理する必要があり、
     リクエストを繰り返すことなく処理することが期待される)
    - e.g. GETリクエストで`Upgrade`を受信し、サーバがプロトコルの切り替えを決定した場合、
      サーバーはまずHTTP/1.1の101 Switching Protocols メッセージを返送し、
      その後すぐに対象リソースに対するGETレスポンスと同等の新しいプロトコルのレスポンスを送信する。
      これにより、追加のラウンドトリップによる遅延コストなしに、HTTPと同じ意味論を持つプロトコルへの接続の
      アップグレードが可能になる
- [MUST NOT] サーバは、受信したメッセージの意味論が新しいプロトコルで処理できない限り、
  プロトコルを切り替えてはならない
- OPTIONSリクエストはどのプロトコルでも処理できる

```
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

...以降、WebSocket プロトコルに切り替わり、 GET /hello に対する WebSocket 的な応答が続く...
```

- [MUST] `Upgrade`の送信者は、中継者に対してこのフィールドを転送しないよう知らせるため、
  `Connection`ヘッダフィールドに`Upgrade`接続オプションを送信しなければならない
  - [MUST] HTTP/1.0リクエストで`Upgrade`ヘッダフィールドを受信したサーバは、
    その`Upgrade`フィールドを無視しなければならない
- クライアントは、リクエストメッセージを完全に送信するまで、接続上でアップグレードされたプロトコルの使用を
  開始できない (= クライアントはメッセージの途中で送信プロトコルを変更できない)
  - [MUST] サーバが`100-continue`期待値を含む`Upgrade`ヘッダフィールドと`Expect`ヘッダフィールドの両方を
    受信した場合、サーバは101 Switching Protocols レスポンスを送信する前に
    100 Continueレスポンスを送信しなければならない
- `Upgrade`ヘッダフィールドは、既存の接続上でのプロトコル切り替えにのみ適用される
  - 基盤となるトランスポートプロトコルを切り替えるために使用することも、
  - 既存の通信を別の接続に切り替えるために使用することもできない
    - これらの目的では3xx Redirection レスポンスを使用する方が適切
- 本仕様は、HTTPバージョン規則および将来の更新で定義されるHypertext Transfer Protocolファミリーで使用される
  プロトコル名`HTTP`のみを定義している

## Representation Data and Metadata https://www.ietf.org/rfc/rfc9110.html#name-representation-data-and-met
### Representation Data

- HTTPメッセージに関連付けられる表現データ (representation data) は
  メッセージのコンテンツとして含まれるか、メッセージの意味論 + ターゲットURIによって参照される
- 表現データは、表現メタデータヘッダフィールドによって定義された形式とエンコーディングによって決定される
- 表現データのデータ型は`Content-Type`および`Content-Encoding`ヘッダフィールドによって決定される
  - これらは2層構造で順序付けられたエンコーディングモデルを定義する

```
representation-data := Content-Encoding( Content-Type( data ) )

- data                                     ... 元の表現内容 (Content-Typeが直接定義する対象)
- Content-Type( data )                     ... dataをあるメディア型としてシリアライズしたもの (バイト列)
- Content-Encoding( Content-Type( data ) ) ... Content-Type( data ) をエンコーディングしたもの (HTTPメッセージ本文)
```

```
(このメッセージの本文はJSON型として解釈されるバイト列をgzip圧縮したもの)

Content-Type: application/json
Content-Encoding: gzip
```

### Representation Metadata (表現メタデータ)
- 表現ヘッダフィールド (representation header fields) は表現に関するメタデータを提供する
- メッセージにコンテンツが含まれる場合、表現ヘッダフィールドはそのデータをどのように解釈すべきかを記述する
  - `Content-Type`
  - `Content-Encoding`
  - `Content-Language`
  - `Content-Length`
  - `Content-Location` など
- HEADリクエストに対するレスポンスにおいて、表現ヘッダフィールドは、
  同じリクエストがGETであった場合にコンテンツ内に含まれていたであろう表現データを記述する

### Content-Type
- `Content-Type`ヘッダフィールドは、関連付けられた表現のメディアタイプを示す
  - メディアタイプは、メッセージのコンテンツに含まれる表現か、またはメッセージの意味論上で選択された表現のいずれか
  - https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Type
    - コンテンツへのエンコードが適用される前の、リソースの元のメディア種別を示す
    - レスポンスにおいては、クライアントに返されたコンテンツの実際の種類を伝える
    - `Content-Encoding`とは異なり、`Content-Encoding`は受信者がもとの形にデコードする方法を得るのに役立つ
- 指定されたメディアタイプは、`Content-Encoding`で指定されたコンテンツコーディングがデコードされた後、
  受信メッセージの意味論の範囲内で、データ形式と受信者によるデータの処理方法の両方を定義する

```
Content-Type = media-type
```

```
Content-Type: text/html; charset=ISO-8859-4
```

- [SHOULD] コンテンツを含むメッセージを生成する送信者は、含まれる表現の意図されたメディアタイプが
  送信者にとって不明でない限り、そのメッセージに`Content-Type`ヘッダフィールドを生成する必要がある
- [MAY] `Content-Type`ヘッダフィールドが存在しない場合、受信者はメディアタイプが
  `application/octet-stream` [RFC2046] であると想定するか、データを調べてそのタイプを判別することができる
- 実用上リソースオーナーは、特定の表現に対して正しい`Content-Type`を提供するようオリジンサーバを適切に
  設定していない場合もある
  - 一部のユーザーエージェントはコンテンツを検査し、場合によっては受信したタイプを上書きする場合がある
    - MIME sniffing ... データについて誤った結論を導き出すリスクがあり、ユーザがセキュリティリスクにさらされる
      可能性がある。さらに、異なるメディアタイプはデータの処理方法のみが異なる共通のデータ形式を共有することが多く
      データの検査だけでは区別できない。スニッフィングを実装する場合、実装者はユーザがそれを無効化する手段を
      提供することが推奨される
- `Content-Type`はシングルトンフィールドとして定義されていますが、誤って複数回生成され、
   結果としてリストのように見える結合フィールド値が生成されてしまうことがある
  - 受信者は、リストの構文的に有効な最後のメンバーを使用してこのエラーを処理しようとすることがよくある
    - そのため、実装によってエラー処理の動作が異なる場合、相互運用性やセキュリティ上の問題が発生する可能性がある

#### Media Type
- HTTPは、`Content-Type`ヘッダフィールドおよび`Accept`ヘッダフィールドにおいて、
  メディアタイプ [RFC2046] を使用することで、オープンで拡張可能なデータの型指定と型ネゴシエーションを提供する
  - メディアタイプは、データ形式と様々な処理モデル (メッセージのコンテキストに応じたデータの処理方法) を定義する

```
media-type = type "/" subtype parameters
type       = token
subtype    = token
```

- [MAY] `type/subtype`の後には、`;`で区切られたパラメータを`名前=値`の形式で指定できる
  - パラメータの有無は、メディアタイプレジストリにおける定義次第によって、
    メディアタイプの処理にとって重要となる場合がある
    - パラメータ値が大文字・小文字を区別するかどうかは、パラメータ名の意味論に依存する

```
UTF-8文字エンコーディング方式でエンコードされたHTMLテキストデータを記述する場合、
以下のメディアタイプは同等だが、一貫性の観点から最初のメディアタイプが推奨される

text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html;charset="utf-8"
text/html;charset=UTF-8
```

- メディアタイプは、[BCP13] で定義された手順に従ってIANAに登録する必要がある

#### Charset
- HTTPは、テキスト表現の文字エンコーディング方式 [RFC6365] を示したり、ネゴシエーションのためにcharset名を使用する
  - 本文書で定義されるフィールドでは、charset名は`Content-Type`のパラメータ内、
    または`Accept-Encoding`のプレーントークンとして利用される
  - charset名は大文字と小文字を区別せずに照合される
- charset名は、[RFC2978] で定義されている手順に従い、IANAのCharacter Setsレジストリに登録する必要がある

#### Multipart Types
- multipartは一つのメッセージボディ内に一つ以上の表現をカプセル化するためのmedia-type
  - MIMEには複数のmultipartが定義されている

```
multipart/form-data
multipart/byteranges
multipart/mixed
```

- すべてのmultipartは共通の構文とboundaryパラメータを含む

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123
```

- multipartのボディは単なるバイト列ではなく、MIMEによって定義された厳密なプロトコル構文を持つ構造体

- MIMEは、複数のmultipart型 (1つのメッセージボディ内に1つ以上の表現を内包するもの) を提供する
  - すべてのmultipart型は、[RFC2046] 5.1.1 で定義されている共通の構文を共有し、
    メディアタイプ値の一部としてboundaryパラメータを含む
  - [MUST] メッセージボディ自体がプロトコル要素であるため、送信者はボディパート間の改行を表すためには
    CRLFのみを利用する
- HTTPのメッセージフレーミングでは、メッセージボディ長の指示子としてmultipartのboundaryを使用しないが、
  コンテンツを生成または処理する実装では使用される場合がある
  - e.g. `multipart/form-data`型は、リクエストでフォームデータを伝送するためによく使用される ([RFC7578])
  - e.g. `multipart/byteranges`型は、一部の206 Partial Contentレスポンスで使用するために本仕様で定義されている

### Content-Encoding
- `Content-Encoding`ヘッダフィールドは`Content-Type`が示すデータに対して適用された圧縮と、そのデコード順序を示す
  - media-typeに含まれるもの以外で、`Content-Type`に対して適用されているコンテントコーディング
  - `Content-Type`ヘッダフィールドで参照されるmedia-typeのデータを得るために適用する必要があるデコード機構
  - (`Content-Type`は復号後に得られるデータの型を示す)
- 主に、基となるmedia-typeの同一性を失うことなく、表現データを圧縮できるようにするために用いられる

```
Content-Encoding = #content-coding
```

```
Content-Encoding: gzip
```

- media-type自体が常に圧縮されているような内在的なエンコーディングを含む場合、
  そのエンコーディングは、同じアルゴリズムであっても`Content-Encoding`には再度記載されない
- オリジンサーバは同じデータの複数の表現として`Content-Type` / `Content-Encoding`の異なるデータを公開することがある
- オリジンサーバはリクエストメッセージ内の表現が受け入れ不可能なコンテントコーディングを含んでいる場合、
  415 Unsupported Media Type で応答してもよい

#### Content Codings
- content-codingは表現に対して適用される、または適用可能なエンコーディング変換
  - gzip
  - br
  - deflate など
- 圧縮・変換を可能にする、media-typeの同一性を失わないことを目的に使用される
- `Accept-Encoding`および`Content-Encoding`ヘッダフィールドで使用される

```
content-coding = token
```

- Compress Coding
  - Lempel-Ziv-Welch (LZW) 圧縮方式 (compressよって生成される)
- Deflate Coding
  - deflate圧縮データストリームを含むzlibデータ形式、Lempel-Ziv (LZ77) 圧縮アルゴリズムとハフマン符号化の組み合わせ
- Gzip Coding
  - 32ビットの巡回冗長検査 (CRC) を備えたLZ77圧縮方式 (gzipファイル圧縮プログラムによって生成される)

### Content-Language
- `Content-Language`ヘッダフィールドはその表現が想定している受信者の自然言語を示す
  - 必ずしも表現内で実際に使用されている言語と一致するとは限らない

```
Content-Language = #language-tag
```

```
(同一内容を複数言語で同時提供しているケース)

Content-Language: ja, en
```

- `Content-Language`が指定されていない場合はすべての言語の受信者を対象とする

#### Language Tags
- language-tagは人間同士の情報伝達のために話されたり、書かれたり、その他の形で用いられる自然言語を識別する

```
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

```
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

### Content-Length
- `Content-Length`ヘッダフィールドは関連付けられた表現データの長さを10進の非負整数でオクテット数として示す
- メッセージの本文が送信される場合、`Content-Length`は具体的に同封されているデータ量を指す
  - HTTP/1.1ではフレーミングを区切るためにに使われる
- メッセージの本文が送信されない場合、`Content-Length`は選択された表現の現在の長さを示す
  - 転送時間の見積もりやキャッシュ済み表現との比較などに使われる

```
Content-Length = 1*DIGIT
```

```
Content-Length: 3495
```

- 0以上の値が有効値。事前定義された上限はないため
  - 受信者は非常に大きな10進数値を想定し、整数変換時のオーバーフローや精度喪失による解析エラーを防がなければならない
- 送信者は誤っていると分かっている`Content-Length`を含むメッセージを転送してはならない
- ABNF定義に一致しない`Content-Length`を含むメッセージを転送してはならない
  - 例外として、同一の10進値がカンマ区切りで繰り返された`Content-Length`を受信した場合、
    受信者はそれを無効として拒否してもよいし、重複生成や結合の結果であると考えて、単一の値に置き換えてもよい

#### ユーザエージェントにとっての`Content-Length`
- リクエストメソッドが本文に意味を与えており、かつ`Transfer-Encoding`を送信していない場合、
  `Content-Length`を送信するべき
  - e.g. 本文が空のPOSTでも通常は`Content-Length`を送信する
  - メッセージに本文が含まれない場合は`Content-Length`を送信するべきではない

#### サーバにとっての`Content-Length`
- HEADに対するレスポンスに`Content-Length`を送信してもよい
  - 値は同じリクエストをGETで行った場合に送信されるはずの本文のオクテット数と等しくする必要がある
- 条件付きGETに対する304 Not Modified レスポンスで`Content-Length`を送信してもよい
  - 値は同じリクエストに対する200 OK レスポンスで送信されるはずの本文のオクテット数と等しくする必要がある
- 1xx または204 No Content レスポンスでは`Content-Length`を送信してはならない
- CONNECTに対する2xx レスポンスでは`Content-Length`を送信してはならない
- 上記を除き、`Transfer-Encoding`が存在せず本文サイズがヘッダ送信前に判明している場合`Content-Length`を送信するべき
  - これにより、下流の受信者は転送進捗を把握でき、メッセージの完全性を判断でき、後続リクエストのために接続を
    再利用できる可能性がある

### Content-Location
- `Content-Location`ヘッダフィールドはメッセージの本文に含まれる表現に対応するリソースを識別するためのURIを示す
  - 当該メッセージが生成された時点でそのURIに対してGETすると、当該メッセージの本文と同一の表現が200 OK になる
  - リソースの識別子ではなく、メッセージに含まれる表現の識別子
    - `Content-Location`は対象URI (どのリソースに対する操作か) の代替ではない

```
Content-Location = absolute-URI / partial-URI
```

- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` == 対象URIの場合:
  - メッセージ生成日時点における当該リソースの現在の表現を示す
  - GETやHEADの場合は`Content-Location`が省略された場合のデフォルトの意味と同じ
  - POST / PUTの場合は操作後の新しいリソースの表現を示す
- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` != 対象URIの場合:
  - GET / HEAD - コンテントネゴシエーションによって選ばれた表現の識別子
  - それ以外 - 処理の結果の表現を示す
- リクエストメッセージに含まれる`Content-Location`値は、元表現へのバックリンクを提供している
  - 当該表現の元データを (ユーザエージェントによる変更前に) 取得した元の場所
- サーバは`Content-Location`を受信したとき、その情報を表現の一部として保存されるメタデータではなく、
  一時的なリクエスト本文として扱わなければならない
  - サーバはそのコンテキストをリクエスト処理の補助や、ソースリンクやバージョン管理メタデータなどの用途に利用できる
  - 要求の意味論を変更するために用いてはならない

### Validator Fields
- 検証子フィールドは事前条件 (precondition) で使用できるvalidatorを定義する
  - `Last-Modified`、`ETag`ヘッダフィールドなど
  - 条件付きリクエスト、同時更新の衝突防止、キャッシュ検証 などに使用される
- GET / HEAD などのリクエストに対するレスポンスでは、サーバが処理の際に選択した表現を記述する
- 状態変更を伴うリクエストに対して成功を示すレスポンスでは、サーバの処理結果として新たに有効となった表現を記述する

#### Weak versus Strong
- 強い (strong) 検証子と弱い (weak) 検証子がある
  - 強い検証子:
    - GETに対する200 OK レスポンスのコンテンツにおいて、
      観測可能な表現データの変更が起きるたびに値が変化する表現メタデータ
      - 同一リソースの全履歴に対して一意
      - 表現の実データ (本文や意味的に重要なmetadata) が変化すると検証子も変わる
    - 比較に理想的だが、効率よく生成するのが非常に難しい
    - キャッシュ検証、範囲 / 部分コンテンツリクエスト、更新の取りこぼし防止などすべての条件付き要求で使用できる
  - 弱い検証子:
    - 表現データの変更があっても必ずしも値が変わらない表現メタデータ
      - 計算精度の制限がある場合、完全な一意性を保証できない場合、表現を等価なグループとして扱いたい場合
    - 生成が容易だが、比較用途では有用性が低い
    - 過去に取得した表現データとの完全一致を必要としない場合にのみ使用できる
      - サーバが検証子を変更したいタイミングで変更される

| 使用場面              | Strong | Weak |
| - | - | - |
| キャッシュ検証        | ○      | ○    |
| If-None-Match         | ○      | ○    |
| If-Match              | ○      | ×    |
| 範囲 / 部分コンテント | ○      | ×    |
| 更新の取りこぼし防止  | ○      | ×    |
| 最近更新されたか      | ○      | ○    |

#### Last-Modified
- レスポンスにおける`Last-Modified`ヘッダフィールドは、
  そのリクエストの処理完了時点で選択された表現が最後に変更されたと考える日時を示すタイムスタンプを提供する

```
Last-Modified = HTTP-date
```

```
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

- オリジンサーバは、最終更新日時が合理的かつ一貫して決定できる表現については`Last-Modified`を送信するべき
  - `Last-Modified`は条件付きリクエストやキャッシュの新鮮度評価において利用され、不要な転送を大幅に削減し、
    サービスの可用性とスケーラビリティを大きく向上させる
  - 表現は通常、リソースインターフェースの背後にある複数の要素の集合体であり、
    最終更新時刻はそれらの要素のいずれかが最後に変更された最も新しい時刻となる
  - オリジンサーバはレスポンスの`Date`フィールド値を生成する時刻にできるだけ近い時点で
    表現の`Last-Modified`値を取得することが望ましい
  - 時計を持つオリジンサーバは、メッセージ生成時刻より後の日時を`Last-Modified`として生成してはならない
  - 時計を持たないオリジンサーバは、他のシステムによってリソースに割り当てられた日時でない限り、
    `Last-Modified`を生成してはならない
- `Last-Modified`の時刻をリクエストの検証子として使用する場合、暗黙的に弱い検証子として扱われる
  - 以下のいずれかの条件を満たし、強いと推論できない場合に限る:
    - 検証子がオリジンサーバによって表現の実際の現在の検証子と比較されており、
      かつそのオリジンサーバが提示された検証子で表される1秒の間に、
      対応する表現が2回以上変更されていないことを確実に把握している場合
    - クライアントが検証子を`If-Modified-Since`、`If-Unmodified-Since`、`If-Range`ヘッダフィールドいずれかで
      使用しようとしており、当該クライアントが対応する表現のキャッシュエントリを保持しており、
      そのキャッシュエントリに含まれる`Date`の値が`Last-Modified`の値より少なくとも1秒以上後であり、
      それらが同一の時計によって生成された、または時計の同期問題が起こりにくいほど十分な差があると
      クライアントが判断できる場合
    - 検証子が中間キャッシュによって、そのキャッシュエントリに保存されている表現の検証子と比較されており、
      そのキャッシュエントリに含まれる Date の値が Last-Modified の値より少なくとも1秒以上後であり、
      それらが同一の時計によって生成された、または時計同期の問題が起こりにくいとキャッシュが判断できる場合

#### ETag
- レスポンスにおける`ETag`フィールドは、リクエスト処理の完了時点で決定された選択表現の
  現在のエンティティタグ (ETag) を提供する
  - ETagは不透明な検証子であり、同一リソースに対する複数の表現を区別するために用いられる
    - 時間経過によるリソース状態の変化やコンテントネゴシエーションによって同時に複数の表現が存在する場合を含む
  - ETagは不透明な引用文字列からなり、任意で弱いことを示す接頭辞を持つ

```
ETag       = entity-tag

entity-tag = [ weak ] opaque-tag
weak       = %s"W/"
opaque-tag = DQUOTE *etagc DQUOTE
etagc      = %x21 / %x23-7E / obs-text
           ; ダブルクオートを除く VCHAR と obs-text
```

- ETagは、状況によって更新日時よりも信頼性の高い検証子となり得る
  - 更新日時の保存が困難な場合
  - HTTP-dateの1秒単位の分解能では不十分な場合
  - 更新日時が一貫して管理されていない場合

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

- ETagはデフォルトは強い検証子
  - オリジンサーバが表現に対してETagを提供する際、その生成方法が強い検証子の特性をすべて満たさない場合、
    サーバはそのETagを弱い検証子として`"W/"`を付ける必要がある
  - 送信者は`ETag`フィールドをトレーラセクションで送信してもよい
    - ただし、トレーラーは無視されることが多い

```
ETagの基本原則:
「リソースの実装を最もよく理解しているのはサービスの作成者だけであり、
  そのリソースに対して最も正確かつ効率的な検証方法を選択できるのもその作成者である」
```

- オリジンサーバは変更の検出を合理的かつ一貫して判断できる選択表現に対し、`ETag`を送信することが推奨される
  - `ETag`は条件付きリクエストやキャッシュ鮮度評価において利用され、不要な転送を大幅に削減し、
    サービスの可用性・拡張性・信頼性を著しく向上させる
- ETagには強い比較と弱い比較がある
  - 強い比較 (Strong comparison):
    - 2つのETagがいずれも弱いタグではなく、かつ`opaque-tag`が文字単位で完全に一致する場合に等価とされる
  - 弱い比較 (Weak comparison):
    - 2つのETagエンティティタグが弱いタグかどうかに関係なく、`opaque-tag`が文字単位で完全に一致すれば等価とされる

| ETag 1  | ETag 2  | Strong Comparison | Weak Comparison |
| - | - | - | - |
| `W/"1"` | `W/"1"` | no match          | match           |
| `W/"1"` | `W/"2"` | no match          | no match        |
| `W/"1"` | `"1"`   | no match          | match           |
| `"1"`   | `"1"`   | match             | match           |

## Methods https://www.ietf.org/rfc/rfc9110.html#name-methods
- リクエストメソッドは、クライアントがリクエストを行った目的および成功した結果としての期待値を示す
- リクエスト内に特定のヘッダフィールドが存在し、かつそれらの追加的な意味論がメソッドと矛盾しない場合、
  リクエストメソッドの意味論はそれらのヘッダーフィールドによってさらに特化されることがある。

```
method = token
```

- メソッドトークンは大文字・小文字を区別する
  - 慣例として、標準化されたメソッドはすべて大文字のUS-ASCII文字で定義されている
- 一度定義された標準メソッドは、どのリソースに適用された場合でも同一の意味論を持つべき
  - それらの意味論が実装されているか、あるいは許可されているかどうかは、各リソース自身が決定する

| RFC 9110で定義されたメソッド | 意味                                                       |
| -                            | -                                                          |
| GET                          | 対象のリソースの現在の表現を取得する                       |
| HEAD                         | GETと同じ。レスポンスの本文は取得しない                    |
| POST                         | リクエスト本文を用いてリソース固有の処理を実行する         |
| PUT                          | 対象リソースの現在の表現をリクエスト本文で置き換える       |
| DELETE                       | 対象リソースの現在の表現を削除する                         |
| CONNECT                      | 対象リソースで識別されるサーバへのトンネルを確立する       |
| OPTIONS                      | 対象リソースに対する通信オプションを取得する               |
| TRACE                        | 対象リソースまでの経路に沿ってループバックテストを実行する |

- すべての汎用サーバはGETおよびHEADメソッドを必ずサポートしなければならない。それ以外のメソッドは任意。
- 対象リソースで許可されているメソッドの集合は`Allow`ヘッダーフィールドに列挙可能
  - ただし許可されるメソッドの集合は動的に変化する可能性がある
- オリジンサーバは:
  - 認識できない / 実装されていないリクエストメソッドを受信した場合、
    501 Not Implemented ステータスコードを返すことが推奨される
  - 認識および実装されてはいるが、対象リソースに対しては許可されていないリクエストメソッドを受信した場合、
    405 Method Not Allowed ステータスコードを返すことが推奨される

### Common Method Properties
#### Safe Methods
- 意味論的に読み取り専用として定義されているメソッドは安全 (safe) なメソッド
  - GET、HEAD、OPTIONS、TRACE
- クライアントは安全なメソッドを対象リソースに適用した結果として、
  オリジンサーバ上で何らかの状態変化が起こることを要求せず、期待しない
  - ただしクライアントが要求した意味論において安全であることが重要であり、実装上の副作用は問題にされない
- 安全なメソッドと安全でないメソッドを区別する目的:
  - 自動取得プロセスやキャッシュ性能最適化が、害を引き起こすことを恐れずに動作できるようにする
  - ユーザエージェントが信頼できない可能性のあるコンテンツを処理する際、
    安全でないメソッドの自動利用に対して適切な制約を適用できるようにする
- ユーザエージェントは、ユーザーに対して実行可能な操作を提示する際:
  - 安全なメソッドと安全でないメソッドを区別すべき
  - リクエストが送信される前に安全でない操作であることをユーザーが認識できるようにするべきである。
- 対象URI内のパラメータが何らかの操作を選択する効果を持つようにリソースが構成されている場合、
  リソースの所有者はその操作がリクエストメソッドの意味論と整合していることを保証する

#### Idempotent Methods
- 同一のリクエストを複数回実行しても、サーバに対する効果が毎回同じになるメソッドは冪等 (idempotent) なメソッド
  - GET、HEAD、OPTIONS、TRACE、PUT、DELETE
- ただしクライアントが要求した意味論において冪等であることが重要であり、実装上の副作用は問題にされない
- 冪等なメソッドと冪等でないメソッドを区別する目的:
  - クライアントがサーバからのレスポンスの受信に失敗した場合に、そのリクエストを自動的に再送できるようにする
  - クライアントはメソッドが冪等でない場合、原則として自動再試行を行うべきではない
    - そのリクエストの意味論が、メソッドにかかわらず実際には冪等であることを知る手段がある場合、
      あるいは元のリクエストが適用されなかったことを検出できる手段がある場合はこの限りではない
      - e.g. ユーザエージェントは、そのリクエストが当該リソースに対して安全であることを把握している場合、
        POSTリクエストを自動的に再送できる
    - プロキシは冪等でないリクエストを自動的に再試行してはならない
    - クライアントは、自動再試行に失敗したリクエストをさらに自動で再試行するべきではない

#### Methods and Caching
- HTTPにおいてレスポンスをキャッシュ可能にするかどうかは、メソッドごとに定義されたキャッシュ許可と条件に依存する
- メソッド定義がキャッシュ可能性を明示していない場合、そのメソッドのレスポンスはキャッシュできない
  - GET、HEAD、POSTについてはキャッシュの意味論が定義されている
  - 実装上はGET、HEADのみを扱うキャッシュがほとんど

### Method Definitions
#### GET
- GETメソッドは対象リソースの現在の表現の転送を要求する
  - 成功レスポンスは、対象URIが識別する同一性 (sameness) の品質を反映する
  - HTTPを介して識別可能な情報を取得することは通常、識別子 (URI) に対するGETとして行われ、成功すれば200 OK が返る
- GETは情報取得のための主要な仕組みであり、ほぼすべての性能最適化の中心となっている
- URIは必ずしもリモートシステムのファイルパス名と一致せず、表現は必ずしもそのようなファイル内容のコピーではない
  - URIと実装の対応関係はオリジンサーバのみが知っている
- クライアントはGETリクエスト内で`Range`ヘッダフィールドを送信することにより、
  GETの意味論を範囲リクエストに変更し、選択された表現の一部のみの転送を要求できる
- GETリクエストで送信される内容 (ボディ) には一般に定義された意味論はなく、
  リクエストの意味や対象を変更することもできない
  - 潜在的なリクエスト・スマグリング攻撃の危険性から、実装によってはリクエストを拒否し、接続を閉じることがある
- クライアントはGETリクエストに内容を生成するべきではない
  - そのリクエストボディに帯域内外で利用目的があり、サポートされているオリジンサーバに対して直接送信する場合を除く
- オリジンサーバは、私的な合意に依存してリクエストボディを受け取ることを前提にすべきではない
  - 通信の当事者はリクエスト経路上の中継者の存在を把握していないことが多いため
- GETリクエストに対するレスポンスはキャッシュ可能であり
  - キャッシュはそれを後続のGET / ` HEAD`リクエストを満たすために使用してよい
  - `Cache-Control`ヘッダフィールドによって別途指示がある場合はそれに従う
- ユーザ提供の情報から対象URIを構築する仕組みによって情報取得を行う (フォームからGETするなど) 場合、
  クエリにURI内での開示が不適切な、機微なデータが含まれる危険がある
  - レスポンスをキャッシュする利点がない場合にはGETの代わりにPOSTを使用し、
    対象URIではなくリクエスト内容として情報を送信する方が適切なこともある

#### HEAD
- HEADメソッドはサーバがレスポンスに内容 (ボディ) を送信してはならない点以外はGETと同じ
  - HEADは、表現データそのものを転送することなく、選択された表現に関するメタデータを取得するために使用される
  - ハイパーテキストリンクのテストや、最近の更新の有無を確認する目的で用いられることが多い
- サーバはHEADリクエストに対し、原則としてGETでの場合と同じヘッダを返すべき
  - 内容を生成する過程でのみ値が確定するヘッダフィールドについては、省略してもよい
    - レスポンスの生成過程で確定する`Content-Length`や`Vary`など

#### POST
- POSTメソッドはリクエストに含まれる表現を、対象リソース固有の意味論に従って処理することを要求する
  - HTMLフォームに入力されたフィールドなど、データのまとまりをデータ処理プロセスに提供する
  - 掲示板、ニュースグループ、メーリングリスト、ブログ、あるいはそれに類する記事群にメッセージを投稿する
  - オリジンサーバによってまだ識別されていない新しいリソースを作成する
  - 既存のリソース表現にデータを追加する など
- オリジンサーバはPOSTリクエストの処理結果に応じ、適切なステータスコードを選択することでレスポンスの意味論を示す
- POSTリクエストの処理が成功した結果としてオリジンサーバ上に1つ以上のリソースが作成された場合、
  オリジンサーバは、作成された主要リソースの識別子を示す`Location`ヘッダフィールドを含む201 Created レスポンスを
  送信することが推奨される
  - そのレスポンスには新しいリソースを参照しつつ、リクエストの状態を説明する表現を含める
- POSTリクエストに対するレスポンスは、明示的な新鮮度情報 (freshness information) と、
  POSTの対象URIと同じ値を持つ`Content-Location`ヘッダフィールドを含む場合にのみ、キャッシュ可能
    キャッシュされたPOSTレスポンスは後続のGET / HEAD リクエストを満たすために再利用できる
  - POSTリクエスト自体を、キャッシュされたPOSTレスポンスで満たすことはできない
- POSTの処理結果が既存リソースの表現と等価になる場合、オリジンサーバは303 See Other レスポンスを送信し、
  `Location`フィールドに既存リソースの識別子を指定することで、
  ユーザエージェントをそのリソースへリダイレクトしてもよい

#### PUT
- PUTメソッドはリクエストメッセージの内容に含まれる表現によって定義されたによって
  対象リソースの状態を作成または置換することを要求する
- 対象リソースに現在の表現が存在せず、PUTによって新たに作成された場合、
  オリジンサーバは201 Created レスポンスを送信してユーザエージェントに通知しなければならない
- 対象リソースに現在の表現が存在し、その表現がリクエストに含まれる表現の状態に従って正常に更新された場合、
  オリジンサーバは200 OK または204 No Content のいずれかを送信して、リクエストの成功を示さなければならない
- オリジンサーバはPUTで送信された表現と、対象リソースに設定された制約が整合していることを検証することが推奨される
  - PUT表現が対象リソースと不整合である場合は、表現を変換するまたはリソース設定を変更することで整合させるか、
    その表現が不適切である理由を十分に説明する情報を含む適切なエラーメッセージを返すことが推奨される
    - 推奨されるステータスコードは409 Conflict または415 Unsupported Media Type (`Content-Type`不整合の場合)
- HTTPはユーザエージェントの要求意図およびオリジンサーバのレスポンス意味論によって表現できる範囲を超えて、
  PUTメソッドがオリジンサーバの状態にどのような影響を与えるかを厳密には定義していない
  - HTTPはリソースを"HTTPを通じて提供されるインターフェース"とのみ定義し、
    リソース状態がどのように保存されるか、状態変更により保存方法がどのように変化するか、
    オリジンサーバがどのようにしてリソース状態を表現へ変換するかを定義していない
  - ヘッダおよびトレーラの扱いは、そのリクエストを受信したリソースに固有であるため、
    オリジンサーバはPUTリクエストで受信した認識できないヘッダやトレーラフィールドを無視するべきであり、
    それらをリソース状態の一部として保存すべきではない
- オリジンサーバはPUTが成功したレスポンスにおいて、検証子フィールド (`ETag`や`Last-Modified`など) を
  送信してはならない
  - PUTリクエストの内容とリソースの新しい表現が一致、かつ検証子値が新しい表現を正しく反映している場合を除く
    - レスポンスで受信した新しい検証子値は、将来の条件付きリクエストにおいて
      意図しない上書きを防ぐために利用できる
- POSTとPUTの根本的な違い: リクエストに含まれる表現に対する意図
  - POSTリクエストにおける表現は、対象リソースの意味論に従って処理することが意図されている
  - PUTリクエストに含まれる表現は、対象リソースの状態を置換するものとして定義されている
  - PUTの意図は冪等であり、中継者からも可視 (ただしその正確な効果はオリジンサーバのみが知っている)
  - 状態変更リクエストの受信後、クライアントに代わって適切なURIを選択するサービスは、
    PUTではなくPOSTを用いて実装されるべき
- オリジンサーバは、要求されたPUTによる状態変更を対象リソースではなく別のリソースに適用したい場合、
  適切な3xxレスポンスを送信しなければならない
  - ユーザエージェントはリダイレクトするかどうかを自ら判断する
- 対象リソースに対するPUTリクエストが他のリソースに副作用を及ぼすことがある
- 一部のオリジンサーバは、リクエスト修飾子として`Content-Range`ヘッダフィールドをサポートし、部分PUTを実行できる
- PUTメソッドに対するレスポンスはキャッシュ不可
  - 成功したPUTリクエストが、対象URIに対して1 つ以上のレスポンスを保存しているキャッシュを通過した場合、
    それらの保存済みレスポンスは無効化される

#### DELETE
- DELETEメソッドはオリジンサーバに対して、対象リソースとその現在の機能との関連付けを解除することを要求する
  - 情報そのものが削除されることを期待するのではなく、オリジンサーバ上のURIマッピングに対する削除操作を表現する
- 対象リソースに1つ以上の表現が存在する場合、それらがオリジンサーバによって破棄されるかどうか、
  あるいは関連するストレージが回収されるかどうかは、リソースの性質およびオリジンサーバによる実装に依存する
  - 一般にオリジンサーバは削除を実行する所定の仕組みを持つリソースに対してのみ、DELETEを許可するものと想定される
- DELETEメソッドが正常に適用された場合、オリジンサーバは次のいずれかを送信することが推奨される:
  - 操作は成功する見込みだが、まだ実行されていない場合: 202 Accepted
  - 操作が実行され、追加情報を提供しない場合: 204 No Content
  - 操作が実行され、レスポンスメッセージに状態を説明する表現が含まれる場合: 200 OK
- DELETEリクエストで送信される内容 (ボディ) には一般に定義された意味論はなく、
  リクエストの意味や対象を変更することもできない
  - 潜在的なリクエスト・スマグリング攻撃の危険性から、実装によってはリクエストを拒否し、接続を閉じることがある
- クライアントはDELETEリクエストに内容を生成するべきではない
  - そのリクエストボディに帯域内外で利用目的があり、サポートされているオリジンサーバに対して直接送信する場合を除く
- オリジンサーバは、私的な合意に依存してリクエストボディを受け取ることを前提にすべきではない
  - 通信の当事者はリクエスト経路上の中継者の存在を把握していないことが多いため
- DELETEメソッドに対するレスポンスはキャッシュ不可
  - 成功したDELETEリクエストが、対象URIに対して1 つ以上のレスポンスを保存しているキャッシュを通過した場合、
    それらの保存済みレスポンスは無効化される

#### CONNECT
- CONNECTメソッドは受信者に対し、リクエストターゲットで識別される宛先オリジンサーバへのトンネルを確立することを
  要求する
  - 成功した場合は以降、トンネルが閉じられるまで双方向のデータを盲目的に転送することのみに動作を制限する
  - トンネルは1つ以上のプロキシを介してend-to-endの仮想接続を作成するために一般的に用いられる
  - トンネルの接続はTLSによって保護され得る
- CONNECTは専用の形式のリクエストターゲットを使用する
  - `トンネルの宛先となるホスト名:ポート番号`
  - デフォルトのポート番号は存在せず、クライアントは必ずポート番号を送信しなければならない

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com
```

- サーバは空または無効なポート番号をターゲットとするCONNECTリクエストを拒否しなければならない
  - 通常は400 Bad Request ステータスコードで応答する
- CONNECTはHTTP 接続のリクエスト／レスポンスの性質を変更するため、HTTPのバージョンごとに
  意味論をプロトコルのワイヤ形式へどのようにマッピングするかが異なる場合がある
- CONNECTはプロキシへのリクエストとして使用されることを意図する
  - 受信者は、リクエストターゲットで識別されたサーバへ直接接続することでトンネルを確立することができる
  - 受信者は、別のプロキシを使用するよう設定されている場合、CONNECTを次の上流プロキシへ転送することもできる
  - オリジンサーバがCONNECTを受け付けることもあるが、ほとんどのオリジンサーバはCONNECTを実装していない
- CONNECTに対する2xxレスポンスは、送信者およびすべての上流プロキシが、
  レスポンスヘッダ部の直後から即座にトンネルモードへ切り替えることを示す
  - 以降に受信されるデータは、リクエストターゲットで識別されたサーバからのもの
  - 成功以外のレスポンスは、トンネルがまだ形成されていないことを示す
- トンネルは、いずれか一方が接続を閉じたことを中継者が検出した時点で閉じられる
  - 中継者は、閉じられた側から届いていた未送信データを可能な限り反対側へ送信し、
    両方の接続を閉じ、残っている未配送データを破棄しなければならない
- プロキシ認証は、トンネル作成の権限を確立するために使用されることがある

```
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

- 任意のサーバへのトンネルを確立することには重大なリスクがある
  - CONNECTをサポートするプロキシは既知のポート集合、または安全なリクエストターゲットの設定可能なリストに
    使用を制限することが推奨される
- サーバはCONNECTに対する2xxレスポンスにおいて`Transfer-Encoding`または`Content-Length`を送信してはならない
  - クライアントは受信した`Transfer-Encoding`や`Content-Length`をを無視しなければならない
- CONNECTリクエストメッセージには内容 (ボディ) は存在しない
- CONNECTリクエストのヘッダ部以降に送信されるデータの解釈は、使用されているHTTPのバージョンに依存する
- CONNECTメソッドに対するレスポンスはキャッシュ不可

#### OPTIONS
- OPTIONSメソッドはオリジンサーバまたは中継者において、対象リソースに対して利用可能な通信オプション情報を要求する
  - リソースの操作なしにリソースに関連付けられたオプションや要件、サーバの能力を確認するためのもの
- リクエスト対象が`*`の場合、サーバ全体に対する問い合わせとなり、主に疎通確認や能力検査に用いられる。
- リクエスト対象が`*`でない場合、対象リソースに対する問い合わせとなる
- OPTIONSに対して2xx レスポンスを生成するサーバは、対象リソースに適用され、かつサーバが実装している
  任意機能を示す可能性のあるすべてのヘッダ (`Allow`など) を送信することが推奨される
- サーバは、OPTIONSに対するレスポンスボディを、通信オプションを機械可読または人間可読な形式で記述してもよい
- クライアントは、OPTIONSリクエストにおいて、リクエストチェーン内の特定の受信者を対象とするために
  `Max-Forwards`ヘッダーフィールドを送信してもよい
  - プロキシは、受信したリクエストに`Max-Forwards`が含まれていない限り、リクエスト転送時にこれを生成してはならない
- クライアントがボディを含むOPTIONSリクエストを生成する際、
  その表現のメディアタイプを記述した有効な`Content-Type `ヘッダーフィールドを送信しなければならない
- OPTIONSメソッドに対するレスポンスはキャッシュ不可

#### TRACE
- TRACEメソッドはリクエストメッセージを対象として、リモート側でのアプリケーションレベルのループバックを要求する
- リクエストの最終受信者は受信したメッセージをそのまま200 OK レスポンスとして返すことが推奨される
  - 表現方法は`message/http`形式など
  - 最終受信者 = オリジンサーバ、もしくはリクエスト内の`Max-Forwards`値が0になった時点で最初に受信したサーバ
  - クライアントはTRACEリクエストにおいて、レスポンスによって漏えいする可能性のある機微なデータを含むフィールドを
    生成してはならない
    - e.g. ユーザー認証情報、Cookieなど
  - 最終受信者はレスポンスを生成する際、機微なデータを含む可能性の高いリクエストフィールドを除外することが推奨される
- TRACEはリクエストチェーンの末端で実際に何が受信されているのかをクライアントが確認できるようにし、
  その情報をテストや診断目的で利用できるようにする
  - リクエストチェーンの経路を示す痕跡としては`Via`ヘッダフィールドが重要
  - `Max-Forwards`ヘッダフィールドを使用する
  - リクエストチェーンの長さを制限し、プロキシがメッセージを無限ループで転送していないか確認する際には
    `Max-Forwards`ヘッダフィールドが有用
- クライアントはTRACEリクエストにボディを送信してはならない
- TRACEメソッドに対するレスポンスはキャッシュ不可

## Message Context https://www.ietf.org/rfc/rfc9110.html#name-message-context
### Request Context Fields
リクエストの文脈に関する追加情報を提供するヘッダフィールド群
(ユーザー、ユーザエージェント、ならびにリクエストの背後にあるリソースに関する情報など)

#### Expect
- `Expect`リクエストヘッダフィールドは、そのリクエストを正しく処理するためにサーバに期待する振る舞いを示す

```
Expect =      #expectation
expectation = token [ "=" ( token / quoted-string ) parameters ]
```

- `Expect`フィールド値は大文字・小文字を区別しない
- 仕様によって定義されている唯一の期待事項は`"100-continue"`
  - サーバは`Expect`フィールドに100-continue以外の値が含まれているリクエストを受信した場合、
    その期待に応えられないことを示すために、417 Expectation Failed ステータスコードで応答してもよい

- 100-continueの期待値
  - クライアントがこのリクエストにおいてサイズの大きなボディを送信しようとしており、
    メソッド・対象URI・ヘッダフィールドだけでは即座に成功、リダイレクト、またはエラーと判断できない場合に、
    中間レスポンスを受け取りたいという意思を受信者に伝える
    - クライアントは実際に内容を送信する価値があるかどうかの合図を待ってから送信できるため、
      データ量が非常に大きい場合や、エラーが起こりそうな場合の効率を向上させることができる
  - クライアントに対する要件:
    - ボディを含まないリクエストに100-continueの期待を生成してはならない
    - リクエストボディを送信する前に100 Continue レスポンスを待つつもりのクライアントは、
      `"100-continue"`を含む`Expect`ヘッダフィールドを送信しなければならない
    - 100-continueを送信したクライアントは、特定の時間を待つ義務はない
      - レスポンス未受信の状態でもボディの送信を開始してよい
      - 100 Continue レスポンスはHTTP/1.0の中継者を通過できないため、
        クライアントは無期限に待つべきではない
    - 100-continueを含むリクエストに対して417 Expectation Failed を受信したクライアントは、
      その`Expect`を除いた同じリクエストを再送することが推奨される
      - 417 Expectation Failed はレスポンスチェーンが`Expect`をサポートしていない場合に返される
  - サーバに対する要件:
    - HTTP/1.0リクエストで100-continueを受信したサーバは、その期待を無視しなければならない
    - サーバがすでにリクエストボディの一部または全部を受信している場合、
      あるいはフレーミングからボディが存在しないと分かる場合には、100 Continue レスポンスの送信を省略してもよい
    - 100 Continue レスポンスを送信したサーバは接続が途中で閉じられない限り、
      最終的なステータスコードを必ず送信しなければならない
    - リクエストボディをすべて読む前に最終ステータスコードを返すサーバは、接続を閉じる意図があるかどうかを示すべき
    - HTTP/1.1以降のリクエストで、100-continue の期待とボディ送信の指示を含む完全なヘッダ部を受信した
      オリジンサーバは、次のいずれかを必ず行わなければならない
      - メソッド、対象URI、ヘッダのみを見て判断できる場合は即座に最終ステータスコードで応答する
      - それ以外の場合は即座に100 Continue レスポンスを送信する
      - オリジンサーバは100 Continue を送る前にボディを待ってはならない
  - プロキシに対する要件:
    - HTTP/1.1以降の100-continue付きリクエストを受信したプロキシは、次のいずれかを行わなければならない:
      - メソッド、対象URI、ヘッダのみを見て判断できる場合は即座に最終ステータスコードで応答する
      - 対応するリクエスト行とヘッダ部を次の上流サーバへ転送する
    - 次の上流サーバがHTTP/1.0のみをサポートしていると判断した場合、
      プロキシはクライアントに対してボディの送信を促すために、即座に100 Continue レスポンスを生成してもよい

#### From
- `From`リクエストヘッダフィールドは、リクエストを送信するユーザエージェントを制御している人間のユーザーの
  インターネット電子メールアドレスを含む

```
From    = mailbox
mailbox = <mailbox, see [RFC5322], Section 3.4>
```

```
From: spider-admin@example.org
```

- `From`ヘッダフィールドは、ロボット型のユーザエージェントによって送信されることが多い
- ユーザエージェントはユーザーによる明示的な設定なしに`From`ヘッダフィールドを送信するべきではない
  - ユーザーのプライバシー上の利益や、サイトのセキュリティポリシーと衝突する可能性があるため
- ロボット型のユーザエージェントは、ロボットの挙動によりサーバ上で問題が発生した場合に、
  そのロボットの運用責任者へ連絡できるよう有効な`From`ヘッダーフィールドを送信することが推奨される
- サーバは`From`ヘッダフィールドをアクセス制御や認証の目的で使用するべきではない
  - `Fron`値はリクエストを受信または観測する誰からも見えることが想定されている
  - プライバシーが期待されない形でログファイルやエラーレポートに記録されることが多い

#### Referer
- `Referer`リクエストヘッダフィールドは、対象URI がどのリソースから取得されたかを示すURI参照を指定する
- ユーザエージェントは`Referer`フィールド値に、URI参照に含まれる`fragment`および`userinfo`を含めてはならない

```
Referer = absolute-URI / partial-URI
```

- `Referer`フィールド値は`absolute-URI`か`partial-URI`のいずれか
  - `partial-URI`の場合、参照されるURIは対象URIに対する相対URIとして解釈される
- `Referer`ヘッダフィールドによりサーバは簡易的な分析、ログ記録、キャッシュ最適化などの目的で、
  他のリソースへのバックリンクを生成したり、古くなったリンクやタイプミスされたリンクを保守のために発見できる

```
Referer: http://www.example.org/hypertext/Overview.html
```

- 参照元のURIを持たないソースから対象URIを得た場合 (e.g. ユーザーのキーボード入力や、ブックマークエントリ)
  ユーザエージェントは`Referer`ヘッダフィールドを省略するか、値として`"about:blank"`を送信しなければならない
- `Referer`ヘッダフィールド値は、参照元リソースの完全なURIを含む必要はない
  - ユーザエージェントは、参照元のオリジン以外の部分を切り詰めてもよい
- `Referer`ヘッダフィールドは、リクエストの文脈やユーザーの閲覧履歴に関する情報を漏えいさせる可能性がある
  - 多くの汎用ユーザエージェントは、参照元がローカルなfile URIやdata URI である場合`Referer`を送信しない
  - ユーザエージェントは参照元リソースがセキュアなプロトコルで取得され、かつリクエストターゲットのオリジンが
    参照元と異なる場合、参照元リソースが明示的に`Referer`の送信を許可していない限り
    `Referer`ヘッダーフィールドを送信すべきではない
  - 参照元リソースがセキュアなプロトコルで取得された場合、非セキュアなHTTPリクエストで`Referer`を送信してはならない
- 中継者は無差別に`Referer`ヘッダーフィールドを送信リクエストから削除することがある
  - `Referer`による情報開示を制限したい中継者やユーザエージェント拡張は、内部ドメイン名を仮名に置き換える、
    あるいはクエリやパスコンポーネントを切り詰めるなど、限定的な編集に変更をとどめるべき
  - 中継者は`Referer`の値が対象URI と同じスキームおよびホストを共有している場合、
    `Referer`ヘッダフィールドを変更または削除すべきではない

#### TE
- `TE`リクエストヘッダフィールドはクライアントがどの転送コーディング (Transfer Coding) を受け入れられるか、
  トレーラフィールドを破棄せずに扱えるかの対応能力を記述する
- リクエストの`TE`ヘッダに`"trailers"`が含まれる場合、クライアントがトレーラを受け取っても破棄しない意図を示す
  - ただし処理をするとは言っていない
- HTTP/1.1 においては、レスポンスで使用される転送コーディングのうち
  クライアントが受け入れ可能なものをサーバに通知する目的にも使用される
  - RFC公開時点で転送符号化を使用しているのはHTTP/1.1のみである
- `TE`フィールド値はメンバのリスト
  - 各メンバは転送コーディング名のトークン、その転送コーディングに対するクライアントの相対的な優先度を示す重み、
    転送コーディングに対する任意のパラメータを含めることもできる (`"trailers"`を除く)

```
TE                 = #t-codings
t-codings          = "trailers" / ( transfer-coding [ weight ] )
transfer-coding    = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

- `TE`を送信する側は、中継者にこのフィールドを転送しないよう通知する必要があり、
  そのため`Connection`ヘッダフィールド内に`"TE"`接続オプションを必ず送信しなければならない

#### User-Agent
- `User-Agent`ヘッダフィールドはリクエストを発信したユーザエージェントに関する情報を含む
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のユーザエージェントの制限を回避したりそれに合わせてレスポンスを調整するため
  - ブラウザやOSの利用状況に関する分析のため などの目的でサーバによって利用される
  - ユーザエージェントは特別な設定で無効化されていない限り、各リクエストに`User-Agent`を送信することが推奨される

```
User-Agent = product *( RWS ( product / comment ) )
```

- `User-Agent`フィールド値は1 つ以上の`product`識別子から構成され、それぞれに0個以上のコメントが続く
  - それらを合わせてユーザエージェントのソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例として`product`識別子は、ユーザエージェントを特定する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
product         = token ["/" product-version]
product-version = token
```

- `product`識別子に記述する内容は、製品を識別するために必要な最小限の情報に限定することが推奨される
  - `product`識別子内に広告やその他の不要な情報を生成してはならない
  - `product-version`にはバージョン識別子ではない情報を含めるべきではない

```
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

- ユーザエージェントは不必要に詳細で粒度の細かい情報を含む`User-Agent`ヘッダフィールドを生成すべきではなく、
  第三者によるサブプロダクトの追加も最小限に抑えるべき
- ユーザエージェントが他の実装との互換性を宣言する目的で他実装の`product`トークンを使用することは推奨されない
- もしユーザエージェントが別のユーザエージェントになりすましている場合、
  受信者は識別されたユーザエージェント向けに調整されたレスポンスを意図的に望んでいるものとみなしてよい

### Response Context Fields
レスポンスに関する追加情報を提供するヘッダフィールド群
(サーバに関する情報、対象リソースに関する情報、または関連リソースに関する情報など)

#### Allow
- `Allow`レスポンスヘッダフィールドは、対象リソースがサポートしているメソッドの集合を指定する
  - リソースに関連付けられた有効なリクエストメソッドを受信者に通知するために使用される

```
Allow = #method
```

```
Allow: GET, HEAD, PUT
```

- 実際に許可されるメソッドの集合は、各リクエストの時点においてオリジンサーバによって定義される
- オリジンサーバは405 Method Not Allowed レスポンスにおいて`Allow`ヘッダフィールドを生成しなければならない
  - また、それ以外のレスポンスにおいても`Allow`を生成してもよい
- `Allow`フィールド値が空である場合、そのリソースがいかなるメソッドも許可していないことを示す
  - 設定によりリソースが一時的に無効化されている場合など
- プロキシは`Allow`ヘッダフィールドを変更してはならない
  - プロキシ自身は指示されているすべてのメソッドを理解していなくても、
    一般的なメッセージ処理規則に従ってそれらを取り扱うことができるため

#### Location
- `Location`レスポンスヘッダフィールドはレスポンスに関連付けられる特定のリソースのURIを示す
  - リクエストメソッドとステータスコードの意味論の組み合わせによってその関連の意味が定義される

```
Location = URI-reference
```

- フィールド値は1つのURI参照から構成される
  - 相対参照の場合、最終的な値は対象URIを解決することでよって算出される
- 201 Created レスポンスにおける`Location`値は、そのリクエストによって作成された主要リソースを指す
- 3xx Redirection レスポンスにおける`Location`値は、リクエストを自動的にリダイレクトする際に優先される
  ターゲットリソースを指す
  - `Location`値にフラグメントコンポーネントが存在しない場合、
    ユーザエージェントは対象URIを生成するために用いられたURI参照のフラグメントコンポーネントを継承したものとして
    リダイレクトを処理しなければならない (元の参照にフラグメントが含まれていればそれを引き継ぐ)
    - `Location`値にフラグメント識別子を含めるのが適切でない状況も存在する
      - e.g. 201 Created レスポンスにおける`Location`は、作成されたリソースに固有のURIを提供することが意図である
- 注: 一部の受信者は有効なURI参照ではない`Location`ヘッダフィールドからの回復を試みることがある
  - RFCではそれを定義していないが、堅牢性の観点から許容している
- 注: `Content-Location`は`Location`とは異なり、同封されている表現に対応する最も特定されたリソースを指す
  - レスポンスには`Location`と`Content-Location`の両方が含まれる場合がある

#### Retry-After
- `Retry-After`レスポンスヘッダフィールドは次のリクエストを送るまでに待つべき時間をユーザエージェントに伝える
  - 503 Service Unavailable レスポンスとともに送信される場合は、
    そのサービスがクライアントに対して利用不能であると予想される期間を示す
  - 3xx Redirection レスポンスとともに送信される場合は、
    リダイレクトされたリクエストを発行する前に、ユーザエージェントが最低限待つべき時間を示す
- `Retry-After`フィールド値は、HTTP-dateまたはレスポンス受信後に待機すべき秒数のいずれか

```
Retry-After   = HTTP-date / delay-seconds ... delay-secondsの値は非負の10進整数。秒単位の時間を表す。
delay-seconds = 1*DIGIT
```

```
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120

...待機時間として2分が選択される
```

#### Server
- `Server`レスポンスヘッダフィールドはリクエストを処理したオリジンサーバのソフトウェア情報を示す
- リクエストを処理するためにオリジンサーバが使用しているソフトウェアに関する情報を含む。この情報は、
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のサーバ実装の制限を回避したりそれに合わせてリクエストを調整するため
  - サーバやOSの利用状況に関する分析のため などの目的でクライアントによって利用される
- オリジンサーバはレスポンスに`Server`ヘッダフィールドを生成してもよい

```
Server = product *( RWS ( product / comment ) )
```

- `Server`ヘッダフィールド値は1つ以上の`product`識別子から構成され、それぞれに0個以上のコメントが続く
  - それらを合わせてオリジンサーバソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例として`product`識別子は、オリジンサーバソフトウェアを識別する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
Server: CERN/3.0 libwww/2.17
```

- オリジンサーバは不必要に詳細で粒度の細かい情報を含む`Server`ヘッダフィールドを生成すべきではなく、
  第三者によるサブプロダクトの追加も制限すべき
- 過度に長く詳細な`Server`フィールド値はレスポンス遅延を増大させるだけでなく、内部実装の詳細を露呈し、
  既知のセキュリティホールを攻撃者が見つけて悪用することを容易にしてしまう可能性がある

## HTTP Authentication https://www.ietf.org/rfc/rfc9110.html#name-http-authentication
### Authentication Scheme
- HTTPは拡張可能なチャレンジ・レスポンス型認証スキームの集合をアクセス制御/認証のためのフレームワークとして提供する
- 認証スキームの識別には、大文字・小文字を区別しないトークンが使用される

```
auth-scheme = token
```

### Authentication Parameters
- HTTPの認証方式では、認証スキーム名 (auth-scheme) の後ろに、認証を成立させるために必要な必要な追加情報が続く
- 追加情報の表現形式:
  - カンマ区切りのパラメータ列 `name=value`
  - token68
    - 空白を含まない66個の連続した文字列
    - RFC 4648に準拠するエンコードを想定
    - base64、base64url、base32、base16の各エンコーディングを格納できる
    - パディングのために末尾に任意個の`=`を追加可能

```
token68        = 1*( ALPHA / DIGIT /
                    "-" / "." / "_" / "~" / "+" / "/" ) *"="
```

- 認証パラメータ (`auth-param`) は`名前=値`の組であり、 各パラメータ名は1つのチャレンジにつき1回だけ出現しなければならない
  - 名前トークンは大文字・小文字を区別せずに比較される
  - パラメータ値はtokenまたはquoted-stringのいずれかで表現できる
    - 認証スキームの定義は、送信者・受信者の双方において、token / quoted-string両方の表記を受け入れる必要がある
    - 後方互換性のため、認証スキームの定義は送信者側の形式をどちらかに制限してもよい

```
auth-param     = token BWS "=" BWS ( token / quoted-string )
```

### Challenge and Response
- 401 Unauthorized レスポンスは、オリジンサーバからユーザエージェントの認可を要求 (チャレンジ) する際に使用される
  - 401は要求されたリソースに適用できるチャレンジを含む`WWW-Authenticate`ヘッダフィールドを含む
- 407 Proxy Authentication Required レスポンスは、プロキシがクライアントの認可を要求するために使用される
  - 407は要求されたリソースに対してプロキシに適用可能なチャレンジを含む`Proxy-Authenticate`ヘッダフィールドを含む

```
challenge = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- オリジンサーバに対して自身を認証したい
- ユーザエージェントはオリジンサーバに対して自身を認証したい場合、
  リクエストに`Authorization`ヘッダフィールドを含めることによって認証情報を送信できる
- ユーザエージェントはプロキシに対して自身を認証したい場合、
  リクエストに Proxy-Authorization ヘッダーフィールドを含めることで認証情報を送信できる

### Credentials
- `Authorization`フィールド / `Proxy-Authorization`フィールドは過去または直前にレスポンスを受け取った
  認証チャレンジに基づくクライアント資格情報 (credentials) を送るためのもの
- ユーザエージェントは自身が理解できるものの中で最も安全だと判断した認証スキームを選択するべき
- ヘッダフィールド値として資格情報を送信することは、接続の機密性に関して重大なセキュリティ上の考慮事項を伴う

```
credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- オリジンサーバは保護されたリソースへの不正なリクエストを受信した場合、
  要求されたリソースに適用可能な1つ以上のチャレンジを含む`WWW-Authenticate`ヘッダフィールドを伴って
  401 Unauthorized レスポンスを送信することが推奨される
  - 資格情報が省略されている、無効な資格情報が含まれている、資格情報が不完全である など
  - プロキシが同様の不正なリクエストを受信した場合、
    当該プロキシが適用可能な1つ以上のチャレンジを含む`Proxy-Authenticate`ヘッダフィールドを伴って
    407 Proxy Authentication Required レスポンスを生成することが 推奨される
- サーバは受信した資格情報がアクセス権限として不十分である場合、403 Forbidden レスポンスを送信することが望ましい
- HTTPはアクセス認証をこの仕様で定義するチャレンジ・レスポンスの枠組みに限定しない
  - トランスポート層での認証、メッセージのカプセル化、追加のヘッダフィールドによって認証情報を指定するなど、
    他の仕組みを用いることもできる
  - ユーザー認証のための独自メカニズムは、認証に関連するトークンの受け渡しに
    `Set-Cookie`および`Cookie`ヘッダフィールドを使用する

### Establishing a Protection Space (Realm)
- `realm`パラメータは認証が適用される保護の範囲を示すための識別子
- **保護空間（protection space）**は、サーバのオリジン (スキーム + ホスト + ポート) + realm値によって定義される
  - realmによって同一サーバ内を複数の保護空間に分割でき、それぞれが独自の認証スキームと認可データベースを持てる
  - realm値は文字列
    - 通常はオリジンサーバによって割り当てられる
    - 認証スキーム固有の追加的な意味を持つことがある
    - 同一の認証スキームであっても異なるrealmを持つ複数のチャレンジがレスポンスに含まれる場合がある
- 保護空間は、資格情報 (credentials) を自動的に適用できる範囲を決定する
- あるリクエストがすでに認可されている場合、ユーザエージェントは、認証スキーム、パラメータ、ユーザー設定によって
  定められた一定期間、その保護空間内の他のすべてのリクエストに同じ資格情報を再利用してもよい
- 保護空間の範囲 (資格情報が自動適用され得るリクエストの範囲) は、追加情報がない限り
  クライアントにとって必ずしも既知ではない
  - 認証スキームは、保護空間の範囲を記述するパラメータを定義することがある
  - 認証スキームによって明示的に許可されない限り、そのサーバのスコープ外に保護空間が広がることない
- サーバはrealm値としてquoted-string構文のみを生成しなければならない
- クライアントはtokenとquoted-string の両方の構文をサポートする必要がある場合がある (歴史的経緯)

### Authenticating Users to Origin Servers
#### WWW-Authenticate
- `WWW-Authenticate`レスポンスヘッダフィールドは、対象リソースに適用可能な認証スキームおよびそのパラメータを示す

```
WWW-Authenticate = #challenge
```

- 401 Unauthorized レスポンスを生成するサーバは、
  1つ以上のチャレンジを含む`WWW-Authenticate`ヘッダーフィールドを送信しなければならない
- サーバは資格情報を提示することでレスポンスが変わり得ることを示すため、
  他のレスポンスメッセージにおいても`WWW-Authenticate`ヘッダフィールドを生成してよい
- レスポンスを転送するプロキシは、そのレスポンス内の`WWW-Authenticate`ヘッダフィールドを変更してはならない
- ユーザエージェントは、このフィールド値の解析に特に注意を払うことが勧告される
  - フィールド値には複数のチャレンジが含まれる可能性がある
  - 各チャレンジはカンマ区切りの認証パラメータのリストを含み得る
  - このヘッダフィールド自体が複数回出現することもある

```
同一フィールド行に複数のメンバを含むWWW-Authenticateフィールド値を送信すると、相互運用性が損なわれる可能性がある

WWW-Authenticate: Basic realm="simple",             -- Basicスキームのチャンレンジ
                  Newauth realm="apps",             -- Newauth realmスキームのチャレンジ
                  type=1, title="Login to \"apps\"" -- 追加のパラメータ
```

#### Authorization
- `Authorization`リクエストヘッダフィールドは、ユーザエージェントがオリジンサーバに対して自身を認証するもの
- 通常は401 Unauthorized レスポンスを受信した後に送信される
- フィールド値は要求されているリソースのrealmに対するユーザエージェントの認証情報を含む資格情報から構成される

```
Authorization = credentials
```

- リクエストが認証され、realmが指定されている場合、同じ資格情報はそのrealm内の他のすべてのリクエストに対して
  有効であると推定される (認証スキーム自体が別途要件を課していない場合)
- リクエストを転送するプロキシは、そのリクエスト内の`Authorization`ヘッダフィールドを変更してはならない

#### Authentication-Info
- `Authentication-Info`レスポンスフィールドヘッダはクライアントの認証情報が受理された後にサーバが返す追加情報を示す
  - サーバ認証情報を含むサーバからの最終確認メッセージなどが含まれることがある
- フィールド値は`auth-param`構文を用いたパラメータ (名前=値の組) のリスト
  - 個々のパラメータは`Authentication-Info`を使用する各認証スキーム自身によって定義される

```
Authentication-Info = #auth-param
```

- `Authentication-Info`はリクエストメソッドやステータスコードに依存せず、任意のHTTPレスポンスで使用できる
  - その意味論は対応するリクエストの`Authorization`ヘッダフィールドによって示される認証スキームによって定義される
- レスポンスを転送するプロキシは、`Authorization`値をいかなる形でも変更してはならない
- 認証スキームが明示的に許可している場合はトレーラフィールドとしても送信することができる

### Authenticating Clients to Proxies
#### Proxy-Authenticate
- `Proxy-Authenticate`はプロキシがクライアントに対して認証を要求するためのレスポンスヘッダフィールド
  - このリクエストに対してプロキシが適用可能な認証スキーム / パラメータを示す1つ以上のチャレンジから構成される
  - プロキシは自身が生成する407 Proxy Authentication Required レスポンスごとに、
    1つ以上の`Proxy-Authenticate`ヘッダフィールドを送信しなければならない

```
Proxy-Authenticate = #challenge
```

- `WWW-Authenticate`と異なり、`Proxy-Authenticate`はレスポンスチェーン上の次の外向きクライアントにのみ適用される
  - 通常は特定のプロキシを選択したクライアントだけがそのプロキシに対する認証に必要な資格情報を保持しているため
- `Proxy-Authenticate`にも`WWW-Authenticate`と同じ解析上の注意点が適用される

#### Proxy-Authorization
- `Proxy-Authorization`リクエストヘッダフィールドは、クライアントがプロキシに対して資格情報を送るためのもの
  - 認証を要求するプロキシに対してクライアントが自身を識別するために使用する
- フィールド値は要求されているリソースのプロキシとrealmに対する、クライアントの認証情報を含む資格情報から構成される

```
Proxy-Authorization = credentials
```

- `Authorization`とは異なり、`Proxy-Authorization`は
  `Proxy-Authenticate`ヘッダフィールドによって認証を要求した次の内向きプロキシにのみ適用される
- 複数のプロキシがチェーンとして使用されている場合、
  `Proxy-Authorization`は資格情報の受信を期待している最初の内向きプロキシによって消費される
- プロキシは、複数のプロキシが協調して特定のリクエストを認証する仕組みである場合に限り、
  クライアントリクエストから受け取った資格情報を次のプロキシへ中継してもよい

#### Proxy-Authentication-Info
- `Proxy-Authentication-Info`レスポンスヘッダフィールドは、プロキシ認証上`Authentication-Info`と同等の役割を持つ
  - その意味論は対応するリクエストの`Proxy-Authorization`ヘッダフィールドによって示される
    認証スキームによって定義される

```
Proxy-Authentication-Info = #auth-param
```

- `Authentication-Info`と異なり、`Proxy-Authentication-Info`は
  レスポンスチェーン上の次の外向きクライアントにのみ適用される
  - 通常は特定のプロキシを選択したクライアントだけがそのプロキシ認証に必要な資格情報を保持しているため
- 認証スキームが明示的に許可している場合はトレーラフィールドとしても送信することができる

## Content Negotiation https://www.ietf.org/rfc/rfc9110.html#name-content-negotiation
- レスポンスがボディを返す際、オリジンサーバはしばしばその情報を表現する複数の形式、言語、エンコーディングを持つ
  - ユーザーやユーザエージェントもまた、それぞれに利用可能な能力が異なる
 - そのため、HTTP には コンテンツネゴシエーションのための仕組みが用意されている
- プロトコル上可視化されるコンテンツネゴシエーションのパターン定義:
  - "proactive" negotiation ("server-driven" negotiation)
    - ユーザエージェントが明示した嗜好 (preferences) に基づいて、サーバが表現を選択する方式
  - "reactive" negotiation
    - サーバが複数の表現の一覧を提示し、その中からユーザエージェントが表現を選択する方式
  - "request content" negotiation ("agent-driven" negotiation)
    - サーバが過去のレスポンスで示した嗜好に基づき、ユーザエージェントが将来のリクエストで表現を選択する方式
  - その他のコンテンツネゴシエーションパターン
    - 条件付きコンテンツ ("conditional content")
      - 表現が複数の部分から構成され、ユーザエージェントのパラメータに基づいて選択的に描画される方式
    - アクティブコンテンツ ("active content")
      - 表現自体にスクリプトが含まれ、ユーザエージェントの特性に応じて追加のリクエストを行う方式
    - 透過的コンテンツネゴシエーション ("Transparent Content Negotiation")
      - 中継者がコンテンツ選択を行う方式
- パターンは相互に排他的ではなく、それぞれ適用可能性や実用性の面で異なるトレードオフを持つ
- HTTP自体はリソースの意味論を理解しない
- オリジンサーバが時間の経過やコンテンツネゴシエーションの様々な軸にわたり、
  どの程度一貫してレスポンスを返すか、時間を通じて観測されるリソース表現の同一性 (sameness) がどう保たれるかは、
  レスポンスを選択または生成する主体やアルゴリズムに完全に依存する

### Proactive Negotiation
- ユーザエージェントが自身のコンテンツネゴシエーションの嗜好をリクエスト内に記述して送信することにより、
  サーバが自らのアルゴリズムに準じて好ましい表現を選択する
- サーバはレスポンスとして利用可能な表現と、リクエストで提供された情報を比較する
  - リクエスト内にはネゴシエーション用リクエストヘッダフィールド、クライアントのネットワークアドレス、
    `User-Agent`フィールドの一部などが含まれる
- サーバ側で完結できるため、サーバが初回レスポンスでユーザエージェントにとって最適な表現を返すことができれば
  追加リクエストが不要
  - サーバの推測精度向上のため、ユーザエージェントは自身の嗜好を記述するリクエストヘッダフィールドを送信してよい
- Proactive Negotiationに対するレスポンスには`Vary`ヘッダフィールドが含まれることが多い
  - その表現がどのリクエスト要素に依存して選択されたかを明示するため
- ユーザエージェントがレスポンスボディについてProactive Negotiationを行うため
  `Accept`、`Accept-Charset`、`Accept-Encoding`、`Accept-Language`リクエストヘッダフィールドが利用される
  - これらは対象リソースの表現、エラー・処理状態の表現、プロトコル内に現れる付随テキスト文字列に適用される

#### Proactive Negotiationの欠点
- 特定のユーザーにとっての最適 (ユーザエージェントの特性、レスポンスの利用目的) をサーバ側で判断することが不可能
- ユーザエージェントがすべてのリクエストで自身の能力を記述することは非効率、かつ潜在的なプライバシーリスクもある
- オリジンサーバの実装やリクエストに対するレスポンス生成アルゴリズムが複雑になる
- 共有キャッシュにおけるレスポンスの再利用性を低下させる
- ユーザエージェントの嗜好が常に尊重されるわけではない
  - オリジンサーバが対象リソースに対してProactive Negotiationを実装していない場合
  - オリジンサーバが406 Not Acceptable を返すよりも嗜好に一致しないレスポンスを返す方が適切だと判断した場合

### Reactive Negotiation
- ステータスコードの種類にかかわらず、最初のレスポンスを受け取った後にユーザエージェントがコンテンツの選択を行う
  - サーバは代表的な表現を一つ返したり、代替表現への参照の一覧を返したりする
- ユーザエージェントが最初のレスポンス内容に満足しない場合、
  代替リソースの一つまたは複数に対してGETリクエストを行い、別の表現を取得できる
  - 代替表現の選択方法として、ユーザエージェントが自動的に行なったり、ユーザが手動操作で選択したりすることがある
- サーバは代替表現の一覧以外には初期表現を送信しないことにより、ユーザエージェントによるReactive Negotiationを
  優先する意図を示すことができる
  - 300 Multiple Choices や406 Not Acceptable ステータスコードを伴うレスポンスでは、
    利用可能な表現に関する情報が代替案として提示され、ユーザーまたはユーザエージェントが選択できる
- レスポンス表現が型・言語・エンコーディングなどの次元で変化し得る場合、
  オリジンサーバがリクエストからユーザエージェントの能力を判断できない場合、
  公開キャッシュを利用してサーバ負荷を分散しネットワーク使用量を削減するような場合に有利

#### Reactive Negotiationの欠点
- 代替案の一覧をユーザエージェントに送信する必要があり、それをヘッダ部で送る場合にはユーザー体感の遅延が増大する
- 別の表現を取得するために2回目のリクエストが必要になる

### Request Content Negotiation
- サーバのレスポンス内でコンテントネゴシエーションに関する嗜好を送信する
  - そのリソースに対する将来のリクエストにおいて、適切なコンテントの選択に影響を与えることを意図しているため
  - e.g `Accept`や`Accept-Encoding`ヘッダフィールドをレスポンスに含めることにより、
    そのリソースに対する将来のリクエストにおいて、推奨されるメディアタイプやコンテントコーディングを示す

### Content Negotiation Field Features
#### Absence
- リクエストがコンテントネゴシエーション用のヘッダフィールドを含まない場合、送信者は嗜好を持たないことを意味する
- リクエストはコンテントネゴシエーション用のヘッダーフィールドが含むが、
  その条件に基づいて受け入れ可能と見なせる表現が一つも存在しない場合、オリジンサーバは次のいずれかを選択できる:
  - ヘッダフィールドを尊重して、406 Not Acceptable レスポンスを送信する
  - ヘッダフィールドを無視して、そのリクエストに関しては当該ヘッダフィールドによる
    コンテントネゴシエーションの対象ではないものとしてレスポンスを生成する
    - クライアントがその表現を実際に利用できることが保証されるわけではない。

#### Quality Values
- コンテントネゴシエーション用ヘッダーフィールドは、共通のパラメータとして`q` (大文字小文字を区別しない) を用いる
  - `q`は対応するコンテント種別に対する嗜好の相対的な重みを指定する (quality value、qvalue)
  - 重みは0-1の範囲の実数に正規化される
    - 0.001が最も低く、1が最も高い
    - 0は受け入れ不可
    - 指定されていない場合、デフォルトの重みは1
    - 小数点以下3桁を超えて生成してはならない

```
weight = OWS ";" OWS "q=" qvalue
qvalue = ( "0" [ "." 0*3DIGIT ] )
       / ( "1" [ "." 0*3("0") ] )
```

#### Wildcard Values
- コンテントネゴシエーション用ヘッダフィールドの多くは、未指定の値を選択するワイルドカード値`*`を定義している
  - ワイルドカードが存在しない場合、フィールド内で明示的に記載されていない値は受け入れ不可と見なされる
  - `Vary`においてワイルドカード値は、変化が無制限であることを意味する。

### Content Negotiation Fields
#### Accept
- `Accept`リクエストヘッダフィールドは、レスポンスのメディアタイプに関する嗜好を示す
  - サーバは提案のうちの一つを選択し、それを使用してクライアントに`Content-Type`レスポンスヘッダで選択を伝える
- サーバがレスポンス内で`Accept`を送信する場合、同一リソースへの後続リクエストにおいて
  好ましいコンテントタイプを提供する

```
Accept = #( media-range [ weight ] )

media-range = ( "*/*"
                / ( type "/" "*" )
                / ( type "/" subtype )
              ) parameters
```

- `*`はメディアタイプの範囲をまとめる
  - e.g. `*/*` = すべてのメディアタイプ、`type/*` = そのtypeに属するすべてのsubtype
- `media-range`にはその範囲に適用されるメディアタイプパラメータを含める
  - 各`media-range`には任意でメディアタイプパラメータと、相対的な重みを示す任意の`q`パラメータを付与できる
  - 重みを使用する送信者は、すべての`media-range`パラメータの後ろに`q`を送るべき
    - 受信者はパラメータの順序に関わらず、`q`パラメータを重みとして処理すべき
  - 複数の`media-range`がある場合、最も具体的なものが優先される

```
Accept: audio/*; q=0.2, audio/basic

1. audio/basic (q = 1)
2. audio/* (q = 0.2)
```

```
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c

1. text/html, text/x-c (q = 1)
2. text/x-dvi (q = 0.8)
3. text/plain (q = 0.5)
```

```
Accept: text/*, text/plain, text/plain;format=flowed, */*

1. text/plain;format=flowed
2. text/plain
3. text/*
4. */*
```

#### Accept-Charset
- `Accept-Charset`リクエストヘッダフィールドは、テキスト形式のレスポンスボディにおける文字集合に関する嗜好を示す

```
Accept-Charset = #( ( token / "*" ) [ weight ] )
```

- 文字集合名は Section 8.3.2 で定義されている。
- ユーザエージェントは、各文字集合に`q`を指定することで相対的な優先度を示してもよい

```
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

- `*`はフィールド内で他に明示されていないすべての文字集合に一致する
- `Accept-Charset`は非推奨
  - UTF-8がほぼ普遍的に使用されるようになったため
  - 一般的なユーザエージェントの多くは、特別に設定されていない限り`Accept-Charset`を送信しない

#### Accept-Encoding
- `Accept-Encoding`リクエストヘッダフィールドは、レスポンスとして受け入れ可能なコンテントコーディングを示す
- サーバがレスポンス内で`Accept-Encoding`を送信する場合は、同一リソースに対する後続リクエストにおいて
  好ましいコンテントコーディングに関する情報を提供する
  - `identity`トークンは、エンコードを行わないことが望ましい場合を示すために使用される

```
Accept-Encoding  = #( codings [ weight ] )
codings          = content-coding / "identity" / "*"
```

- `codings`値に品質値 (weight) を指定できる
- `*`はフィールド内で明示されていない任意の利用可能なコンテントコーディングに一致する

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

- サーバはある表現に対するコンテントコーディングが受け入れ可能かどうかを、以下の規則で判定する:

```
1. リクエストにAccept-Encodingヘッダフィールドが存在しない場合、
   すべてのコンテントコーディングが受け入れ可能
2. 表現にコンテントコーディングが付与されていない場合、
   Accept-Encodingによって明示的に identity;q=0 または *;q=0 が示されていない限り、デフォルトで受け入れ可能
3. 表現のコンテントコーディングがAccept-Encodingに列挙されている場合
   q値が0でない限り受け入れ可能 (q=0は「受け入れ不可」を意味する)
4. コーディングが同一目的を達成する代替手段として扱われる場合、
   0でないq値の中で最も高いものが優先される
```

- `Accept-Encoding`ヘッダフィールドが存在し、かつフィールド値が空である場合、
  ユーザエージェントはレスポンスにいかなるコンテントコーディングも望んでいないことを意味する
- リクエストに空でない`Accept-Encoding`ヘッダフィールドが存在し、
  利用可能な表現がいずれも受け入れ可能なコンテントコーディングを持たない場合、
  オリジンサーバは、`identity`コーディングが受け入れ不可とされていない限り、
  コーディングなしのレスポンスを送るべき
- レスポンスに含まれている`Accept-Encoding`ヘッダーフィールドは
  そのリクエストにおいて、リソースが受け入れることを許容していたコンテントコーディングを示す
    - 評価方法はリクエストの場合と同じ
- `Accept-Encoding`の持つ情報は当該リクエストに固有であり、同一サーバ上の他のリソースでは異なる場合があり、
  時間経過やリクエストの他の要素に依存して変化し得る
- サーバが未対応のコンテントコーディングを理由にリクエストを失敗させる場合、
  415 Unsupported Media Type  ステータスで応答し、そのレスポンスに`Accept-Encoding`を含めるべき
  - これにより、クライアントはコンテントコーディングに起因する問題とメディアタイプに起因する問題を区別できる
  - コンテントコーディングと無関係な理由で415を返す場合、サーバは`Accept-Encoding`を含めてはならない
- `Accept-Encoding`の最も一般的な使用例:
  - クライアントが楽観的にコンテントコーディングを使用した結果、415 Unsupported Media Type が返される
  - 将来のやり取りを最適化する目的で、コンテントコーディングがサポートされていることをクライアントに示す利用
  - リクエスト内容が圧縮を正当化するほど大きかったにもかかわらずクライアントが圧縮を行わなかった場合、
    リソースは2xxレスポンスに`Accept-Encoding`を含めることがある

#### Accept-Language
- `Accept-Language`リクエストヘッダフィールドは、レスポンスにおける自然言語の嗜好を示す

```
Accept-Language = #( language-range [ weight ] )
language-range  = <language-range, see [RFC4647], Section 2.1>
```

- `language-range`値に品質値 (weight) を指定でき、当該言語範囲に対するユーザーの相対的な嗜好度を表す

```
Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

- 受信者は言語タグの記載順を優先度の降順として解釈することがあるが、その挙動に依存することはできない
- 多くのユーザエージェントは品質値をすべて異なる値として明示的に設定しつつ、品質の高い順に列挙する
- 言語のマッチングについては複数の方式が定義されている ([RFC4647] Section 3)
  - 実装は要件に応じて最適な方式を選択できる
- `Accept-Language`にユーザー言語嗜好を送信することにより、ユーザーのプライバシー期待に反する可能性がある
- 可読性・理解可能性はユーザー個人に大きく依存するため、
  ユーザエージェントは言語嗜好をユーザー自身が制御できる手段（を提供する必要がある
  - 制御手段を提供しないユーザエージェントは`Accept-Language`ヘッダフィールドを送信してはならない

#### Vary
- `Vary`レスポンスヘッダフィールドは、メソッドや対象URI以外で
  どのリクエスト要素がレスポンスボディの選択に影響した可能性があるかを示す

```
Vary = #( "*" / field-name )
```

- `Vary`値は、ワイルドカード`*`またはselecting header fieldsと呼ばれるリクエストヘッダフィールド名の一覧
  - メンバとして`*`を含むリストは、リクエストメッセージ構文の外的要素 (クライアントのネットワークアドレスなど) を
    含め、他の要因がレスポンス表現の選択に関与した可能性があることを示す
- プロキシは`Vary`に`*`を生成してはならない

```
Vary: accept-encoding, accept-language

(オリジンサーバがこのレスポンスボディを選択する際、
 リクエストのAccept-EncodingおよびAccept-Languageヘッダーフィールドを考慮した可能性があることを示す)
```

- `Vary`の用途:
  - キャッシュ受信者への通知
    - 列挙されたヘッダフィールドの値が元のリクエストと同一でない場合、
      このレスポンスを後続リクエストの応答として使用してはならないことを示す ([CACHING] Section 4.1)
    - オリジンサーバはキャッシュ可能なレスポンスを後続リクエストで選択的に再利用させたい場合、
      `Vary`を生成すべき (`Accept-Language`などのselecting header fieldsに基づいてレスポンスボディを調整した場合)
    - `Vary`がキャッシュ性能に与える影響の方が大きいとオリジンサーバが判断する場合、`Vary`を省略してもよい
  - ユーザエージェントへの通知
    - このレスポンスがコンテントネゴシエーションの結果であり、列挙されたヘッダフィールドに異なる値を指定した場合、
      別の表現が返され得ることを示す (Proactive Negotiation)
- `Authorization`フィールド名を`Vary`に含める必要はない
- レスポンスボディがネットワーク地域に依存して選択され、オリジンサーバが地域を越えた再利用を許可したい場合は
  その差異を`Vary`に含める必要はない

## Conditional Requests https://www.ietf.org/rfc/rfc9110.html#name-conditional-requests
- 条件付きリクエスト (conditional request) とは、ターゲットリソースに対してリクエストメソッドを適用する前に、
  評価される前提条件を示すリクエストヘッダフィールドを1つ以上含むHTTPリクエストのこと
- 条件付きGETリクエストは、HTTP キャッシュを更新するための最も効率的な仕組み
- 条件付きリクエストは、PUTやDELETEのような状態変更を伴うメソッドにも適用できる
  - 並行して動作しているクライアントの作業を別のクライアントが誤って上書きするlost update問題を防ぐために利用される

### Preconditions
- サーバはリクエストを実行するかどうかを判断する際、
  現在のターゲットリソースが、クライアントが最後に知っている状態から変わっていない場合にのみ実行したい
- 前提条件は、当該リクエストを実行してよいかどうかをサーバが判断するための条件
- 前提条件 (precondition) は、通常対象リソース全体の状態 (現在の値の集合)
  または以前に取得した表現で観測された状態 (その集合内の1つの値) に対して定義される
- リソースが複数の現在表現を持っていても、同一リクエストは安定的に同一表現に対応付けられることを前提とする
- 前提条件はターゲットリソースの過去の表現から得られた検証子集合 (`ETag`や`Last-Modified` など ) と
  選択された表現に対する現在の検証子状態を比較して評価される
- 他の仕様で拡張フィールドとして定義される前提条件は、
  すべての受信者、ターゲットリソース全般の状態、リソース群に対して条件を課す場合がある
- 前提条件は以下の場合にのみ拡張可能
  - 未知であっても安全に無視できる場合 (e.g. `If-Modified-Since`)
  - 特定のユースケースで配備が前提とできる場合
  - ターゲットリソースの別の性質によって実装が示される場合

#### If-Match
- `If-Match`リクエストヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースがクライアントの知っているままの状態であれば実行してよい」
    - フィールド値が`*`の場合に、オリジンサーバがターゲットリソースの現在表現を1以上保持している
    - フィールド値に列挙されたETagのいずれかと一致する現在表現を保持している
- オリジンサーバは`If-Match`におけるETagの比較において、強い比較 (strong comparison) 関数を使用しなければならない
  - クライアントはその前提条件を、表現データに何らかの変更があった場合にメソッド適用を防ぐ目的で用いているため

```
If-Match = "*" / #entity-tag
```

```
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
```

- `If-Match`は複数のユーザエージェントが同一リソースに対して並行して操作する可能性がある場合、
  意図しない上書きを防ぐため、POST・PUT・DELETEなどの状態変更メソッドとともに使用されることが最も多い
  - 一般には表現の選択や変更を伴う任意のメソッドにおいて、
    選択された表現の現在のETagが`If-Match`の値に含まれていない場合にリクエストを中止する目的で使用できる
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Match`が含まれている場合、
  メソッドを実行する前に、`If-Match`条件を評価しなければならない。
  - フィールド値が`*`の場合: ターゲットリソースに現在表現が存在すればtrue
  - フィールド値がETagのリストの場合: いずれかのタグが選択された表現のETagと一致すればtrue
  - それ以外の場合: false
- オリジンサーバは`If-Match`条件がfalseと評価された場合、要求されたメソッドを実行してはならない
  - 代わりに412 Precondition Failed ステータスコードで条件付きリクエストの失敗を示してもよい
  - リクエストが状態変更操作であり、かつその変更がすでに選択された表現に適用済みであるように見える場合には
    2xxステータスコードで応答してもよい
    - 変更リクエストがすでに適用済みと判断できる場合に成功レスポンスを返すことは効率的であるが、
      協調しない複数のユーザエージェントがよく似た更新を行う場合リスクがある
- クライアントはGETリクエストに`If-Match`を送信し、
  選択された表現が一致しない場合に412 Precondition Failed を受け取りたい意思を示すことができる
  - 新しい表現を望む場合には`If-Range`の方が適している
- キャッシュや中継者は`If-Match`を無視してもよい
- `*`と他の値を同一リスト内に含む`If-Match`ヘッダフィールドは構文的に無効であり、生成してはならない

#### If-None-Match
- `If-None-Match`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースがクライアントの指定したETagと同じ状態ではなければ実行してよい」
    - フィールド値が`*`の場合、受信側のキャッシュ/オリジンサーバがターゲットリソースの現在表現を保持していないこと
    - 選択された表現のETagがフィールド値に列挙されたいずれのETagとも一致しないこと
- `If-None-Match`におけるETagの比較において、受信者は弱い比較 (weak comparison) 関数を使用しなければならない
  - 表現データに変更があった場合でも、弱いETagがキャッシュ検証に使用され得るため

```
If-None-Match = "*" / #entity-tag
```

```
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
```

- `If-None-Match`は主に条件付きGETリクエストで使用され
  - 最小限の通信オーバーヘッドでキャッシュ済み情報を更新するため
- クライアントがETagを持つ1つ以上の保存済みレスポンスを更新したい場合、
  GETリクエストにおいて、それらのエンティティタグを列挙した`If-None-Match`ヘッダフィールドを生成するべき
  - このときサーバは、保存済みレスポンスのいずれかが選択された表現と一致する場合304 Not Modified を返すことができる
- `If-None-Match`は、値として`*`を用いることにより、unsafeなリクエストメソッド (e.g. PUT) が
  クライアントの想定に反して既存の表現を変更してしまうことを防ぐ目的にも使用できる
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-None-Match`が含まれている場合、
  メソッドを実行する前に、`If-None-Match`条件を評価しなければならない
  - フィールド値が`*`の場合: ターゲットリソースに現在表現が存在すればfalse
  - フィールド値がETagのリストの場合: 列挙されたいずれかのタグが、選択された表現のETagと一致すればfalse
  - それ以外の場合: 条件はtrue
- オリジンサーバは、`If-None-Match`条件がfalseと評価された場合、要求されたメソッドを実行してはならない
  - 代わりに以下のいずれかで応答しなければならない:
    - リクエストメソッドがGETまたはHEADの場合: 304 Not Modified
    - それ以外のメソッドの場合: 412 Precondition Failed
- `If-None-Match`を受信した場合のキャッシュの取り扱いに関する要件は、[CACHING] Section 4.3.2 で定義されている
- `*`と他の値を同一リスト内に含む`If-None-Match`ヘッダフィールドは構文的に無効であり、生成してはならない

#### If-Modified-Since
- `If-Modified-Since`ヘッダフィールドは、GETまたはHEADリクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースが指定した日時より新しく変更されていたら実行してよい」
    - 選択された表現の最終更新日時が、フィールド値で指定された日時より新しい場合
  - 表現データが変更されていない場合は、その転送が回避される

```
If-Modified-Since = HTTP-date
```

```
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

- サーバは以下の場合、`If-Modified-Since`を無視しなければならない
  - リクエストに`If-None-Match`が含まれている場合
    - `If-None-Match`の条件は`If-Modified-Since`よりも正確な代替と見なされる
    - 両者を併用するのは`If-None-Match`を実装していない古い中継者との相互運用のために限られる
    - フィールド値が有効なHTTP-dateでない場合
    - フィールド値に複数の値が含まれている場合
    - リクエストメソッドがGET/HEAD以外の場合
    - リソースに最終更新日時が存在しない場合
- 受信者は`If-Modified-Since`の日時をオリジンサーバの時計に基づいて解釈しなければならない
- `If-Modified-Since`の主な用途:
  - ETagを持たないキャッシュ表現を効率よく更新すること
    - キャッシュは通常、保存済みメッセージの`Last-Modified`ヘッダフィールド値を使って`If-Modified-Since`を生成する
      - この方法は時計の同期が不十分な場合や、オリジンサーバが完全一致のタイムスタンプのみを尊重する実装において
        相互運用性が高い
      - ただし`Last-Modified`がない場合などには、`Date`や、メッセージ受信時刻を基に生成されることもある
  - 最近変更されたリソースに限定してWebを巡回すること
    - ユーザエージェントは自らの時計や過去のレスポンスで受け取った`Date`ヘッダフィールドを基に
      `If-Modified-Since`を生成する
      - オリジンサーバが選択表現の`Last-Modified`による完全一致のみを採用している場合、
        指定した期間内に変更されたものだけを取得する支援はできない。
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Modified-Since`が含まれ、
  かつ`If-None-Match`が含まれていない場合、メソッド実行前に条件を評価することが望ましい
  - 選択された表現の最終更新日時がフィールド値の日時以前の場合: false
  - それ以外の場合: true
- 条件がfalseと評価された場合、オリジンサーバは要求されたメソッドを実行せず304 Not Modified レスポンスを生成すべき
  - その際、既存キャッシュの識別や更新に有用なメタデータのみを含める
- `If-Modified-Since`を受信した場合のキャッシュの扱いに関する要件は[CACHING] Section 4.3.2 に定義されている

#### If-Unmodified-Since
- `If-Unmodified-Since`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバは、そのリソースが指定した日時より新しく変更されていないなら実行してよい」
    - 選択された表現の最終更新日時がフィールド値で指定された日時以前であること
  - 表現のETagを保持していないユーザエージェントに対する`If-Match`と同等の目的を果たす

```
If-Unmodified-Since = HTTP-date
```

```
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

- サーバは以下の場合、`If-Unmodified-Since`を無視しなければならない:
  - リクエストに`If-Match`が含まれている場合
    - `If-Match`の条件の方がより正確な代替と見なされる
    - 両者を併用するのは`If-Match`を実装していない古い中継者との相互運用のために限られる
  - フィールド値が有効なHTTP-dateでない場合
  - リソースに最終更新日時が存在しない場合
- 受信者は、`If-Unmodified-Since`の日時をオリジンサーバの時計に基づいて解釈しなければならない
- `If-Unmodified-Since`は主に状態変更メソッド (e.g. POST、PUT、DELETE) とともに使用される
  - ETagを提供しないリソースに対して複数のユーザエージェントが並行して操作する際の意図しない上書きを防ぐため
- オリジンサーバが表現を選択するリクエストを受信し、そのリクエストに`If-Unmodified-Since`が含まれ、
  かつ`If-Match`が含まれていない場合、メソッド実行前に条件を評価しなければならない
  - 選択された表現の最終更新日時がフィールド値の日時以前の場合: true
  - それ以外の場合: false
- 条件がfalseと評価された場合、オリジンサーバは要求されたメソッドを実行してはならない
  - 代わりに412 Precondition Failed ステータスで条件付きリクエストの失敗を示してもよい
  - リクエストが状態変更操作であり、その変更がすでに選択された表現に適用済みであるように見える場合には、
    2xxステータスで応答してもよい
    - 変更要求がすでに適用済みと判断できる場合に成功応答を返すことは多くの場合効率的だが、
      協調しない複数のユーザエージェントが非常によく似た更新を行う場合にはリスクがある
      そのような場合オリジンサーバはunsafeメソッドに対する前提条件失敗時には常に412を返す方が望ましい
- クライアントはGETリクエストに`If-Unmodified-Since`を送信し、
  選択された表現が変更されていた場合に412を受け取りたい意思を示すこともできる
  - 新しい表現を受け取りたい場合は`If-Range`の方が適している
- キャッシュや中継者は`If-Unmodified-Since`を無視してもよい

#### If-Range
- `If-Range`ヘッダフィールドは、リクエストを条件付きにするためのもの
  - 条件:「サーバはそのリソースの表現に変更があれば`Range`で要求した部分を返し、なければ表現全体を返してほしい」
    - サーバに対し、検証子が一致しなかった場合に`Range`ヘッダフィールドを無視するよう指示する
    - その結果として412 Precondition Failed を返す代わりに、選択された新しい表現全体を転送させる
- `If-Range`の目的:
  - クライアントが表現の部分的なコピーを保持しており、最新の完全な表現を取得したい場合、
    `Range`ヘッダフィールドと条件付きGET (`If-Unmodified-Since`と`If-Match`のいずれかまたは両方) を併用できる
  - この時、表現が変更されており前提条件が満たされない場合、クライアントは現在の表現全体を取得するために
    リクエストを再送する必要がある
  - `If-Range`はこの「2回目のリクエスト」をショートカットするための仕組み

```
If-Range = entity-tag / HTTP-date

(有効な`entity-tag`と有効な`HTTP-date`は、先頭3文字が`"`かどうかで区別できる)
```

- `If-Range`の制約:
  - クライアントは`Range`ヘッダフィールドを含まないリクエストに`If-Range`を生成してはならない
  - サーバは`Range`を含まないリクエストで受信した`If-Range`を無視しなければならない
  - オリジンサーバは`Range`リクエストをサポートしないリソースに対する`If-Range`を無視しなければならない
- 検証子に関する制約:
  - クライアントは、弱いETagを含む`If-Range`を生成してはならない
  - クライアントは、対応する表現のETagを持っていない場合に限り、HTTP-dateを含む`If-Range`を生成してよい
    - その日時は強い検証子でなければならない (Section 8.8.2.2)
- サーバが`Range`リクエストで`If-Range `を受信した場合、メソッド実行前に条件を評価しなければならない:
  - HTTP-dateを含む`If-Range`の評価方法:
    - 指定されたHTTP-dateが強い検証子でない場合: false
    - 指定されたHTTP-dateが、選択された表現の`Last-Modified`フィールド値と完全一致する場合: true
    - それ以外の場合: false
  - `entity-tag`を含む`If-Range`の評価方法:
    - 指定された`entity-tag`が、強い比較関数 (Section 8.8.3.2) を用いて選択された表現のETag値と完全一致する場合: true
    - それ以外の場合: false
- `If-Range`条件がfalseと評価された場合、受信者は`Range`ヘッダーフィールドを無視しなければならない
  - 条件がtrueである場合、受信者は`Range`ヘッダーフィールドを要求どおり処理すべきである
- `If-Range`の比較は常に完全一致で行われる (HTTP-date の場合も同様)
  - この点で、指定日時以前 `<=` を判定する`If-Unmodified-Since`とは異なる

### Evaluation of Preconditions
#### When to Evaluate
- 条件付きリクエストの前提条件について、受信者 (キャッシュまたはオリジンサーバ) は
  通常のリクエスト検査を正常に完了した後~リクエスト内容を処理する直前、
  またはリクエストメソッドに関連付けられた動作を実行する直前に、受信した前提条件を評価しなければならない
  - 前提条件を含まない同一リクエストに対し、リクエスト内容を処理する前に返されるレスポンスが
    2xxまたは412 Precondition Failed 以外になる場合は受信したすべての前提条件を無視しなければならない
    - リダイレクトや重要な処理を行う前に検出できる失敗は、前提条件の評価よりも優先される
- 対象リソースのオリジンサーバではなく、そのリソースのリクエストに対してキャッシュとしても動作できないサーバは、
  本仕様で定義される条件付きリクエストヘッダフィールドを評価してはならない
  - そのようなサーバはリクエストを転送する場合、それらのヘッダフィールドを転送しなければならない
    - 生成元クライアントが、現在の表現を提供できるサーバによって評価されることを意図しているため
- CONNECT、OPTIONS、TRACE のように表現の選択や変更を伴わないリクエストメソッドで受信した場合、
  サーバは本仕様で定義される条件付きリクエストヘッダーフィールドを無視しなければならない
- プロトコル拡張は、前提条件が評価される条件やその評価結果の扱いを変更し得る
- 条件付きリクエストヘッダフィールドは、HEADメソッドでも使用可能として定義されているが、
  条件付きHEADを送る実用的な意味はほとんどない

#### Precedence of Preconditions
- 1つのリクエストに複数の条件付きリクエストヘッダフィールドが含まれる場合は優先順で評価する
  - lost update防止のための前提条件はキャッシュ検証よりも厳密な要件を持つ
  - キャッシュ検証済みのレスポンスは、部分レスポンスよりも効率的である
  - ETagは日時ベースの検証子よりも正確であると想定されている
- 受信者 (キャッシュまたはオリジンサーバ) は、本仕様で定義される前提条件を、以下の順序で評価しなければならない

1. 受信者がオリジンサーバで、`If-Match`が存在する場合
    - `If-Match`を評価する
      - trueの場合: 3に進む
      - falseの場合: 原則として412 Precondition Failed を返す
        - 状態変更リクエストがすでに成功していると判断できる場合は例外
2. 受信者がオリジンサーバで、`If-Match`が存在せず、`If-Unmodified-Since`が存在する場合
    - `If-Unmodified-Since`を評価する
      - trueの場合: 3 に進む
      - falseの場合: 原則として 412 Precondition Failed を返す
         - 状態変更リクエストがすでに成功していると判断できる場合は例外とする
3. `If-None-Match`が存在する場合
    - `If-None-Match`を評価する
      - trueの場合: 手順5 に進む
      - falseかつGET / HEAD の場合: 304 Not Modified を返す
      - falseかつその他のメソッドの場合: 412 Precondition Failed を返す
4. メソッドがGET/HEADで、`If-None-Match`が存在せず、`If-Modified-Since`が存在する場合
    - `If-Modified-Since`を評価する
      - trueの場合: 5に進む
      - falseの場合: 304 Not Modified を返す
5. メソッドがGETで、`Range`と`If-Range`の両方が存在する場合
    - `If-Range`を評価する
      - trueかつ`Range`が選択された表現に適用可能な場合: 206 Partial Content を返す
      - それ以外の場合: `Range` ヘッダーフィールドを無視して200 OK を返す
6. 上記いずれにも該当しない場合
    - 要求されたメソッドを実行しその成功または失敗に応じたレスポンスを返す

- HTTPに対する拡張仕様で新たな条件付きリクエストヘッダフィールドを定義する場合は、
  RFCで定義されている前提条件や実際に使われ得る他の条件付きフィールドとの評価順序を明確に定義すべき

## Range Requests
- 範囲リクエストはすでに取得済みの一部データを再利用して残りを取得する、
  あるいは大きな表現の一部分だけを取得するための仕組み
- 範囲リクエストの前提:
  - クライアントはリクエストのキャンセルや接続の切断によって、データ転送が途中で中断される状況にしばしば遭遇する
    - クライアントが表現の一部だけを保存している場合、その後のリクエストで表現全体を再転送するのではなく、
      残りの部分だけを取得できることが望ましい
    - 同様にローカルストレージが限られているデバイスでは、大きな表現の一部のみを要求できることが有益な場合がある
- 範囲リクエストはHTTPの任意機能であり、これを実装していない受信者であっても通常のGETリクエストとして応答できる
- 部分レスポンスは完全なレスポンスと混同されないよう、専用のステータスコードによって示される
  - 範囲機能を実装していないキャッシュが、部分レスポンスを誤って完全なレスポンスとして扱ってしまうことを防ぐため

### Range Units (範囲単位)
- 表現データは、そのコンテントコーディングやメディアタイプに固有のアドレス指定可能な構造単位が存在する場合、
  部分範囲 (range unit) へ分割できる
  - e.g. データの先頭または末尾からのオフセットを基準としたバイト範囲を分割部分として識別できる
- range unitの用途:
  - `Accept-Ranges`レスポンスヘッダフィールド: 範囲リクエストをサポートしていることを広告する
  - `Range`リクエストヘッダフィールド: 要求する表現の部分範囲を指定する
  - `Content-Range`レスポンスヘッダフィールド: 転送されている表現のどの部分であるかを記述する

```
range-unit = token
```

- すべての範囲単位名は大文字・小文字を区別しない
- 範囲単位はHTTP Range Unit Registryに登録されることが推奨される
- 範囲単位は拡張可能であることが意図されている

#### Range Specifiers (範囲指定子)
- 範囲は範囲単位 (データ構造の区切り方) と範囲指定子 (どの範囲を要求するか) の集合を組み合わせて表現される
- 範囲単位名は、その指定子に対してどの種類の`range-spec`が適用可能かを決定する
  - 各範囲単位は`int-range`、`suffix-range`、`other-range`をいつ許可するかを定義することが期待されている
- 範囲リクエストは単一の範囲または同一表現内の複数レンジの集合を指定できる

```
ranges-specifier = range-unit "=" range-set (range-unitに対して無効または未定義のrange-specを含む場合は無効)
range-set        = 1#range-spec
range-spec       = int-range
                 / suffix-range
                 / other-range
```

```
(int-range: 2つの非負整数、または 1つの非負整数から表現データの末尾までを表す範囲)

int-range  = first-pos "-" [ last-pos ]
first-pos = 1*DIGIT
last-pos  = 1*DIGIT (last-posがfirst-pos より小さい場合、そのint-rangeは無効)
```

```
(suffix-range: 指定された非負整数の最大長 (範囲単位数) を持つ、表現データの末尾部分を表す)

suffix-range  = "-" suffix-length
suffix-length = 1*DIGIT
```

```
(other-range: ほぼ無制限にアプリケーション固有、または将来のレンジ単位が追加のレンジ指定子を定義できる)

other-range = 1*( %x21-2B / %x2D-7E )
            ; カンマを除く 1*(VCHAR)
```

```
Range: bytes=0-499
Range: bytes=0-499,500-999
```

#### Byte Ranges
- バイト範囲単位は、表現データをバイト列として部分取得するための範囲単位を表現するために用いられる
- 各バイトレンジは、表現データの先頭からのオフセット`int-range`
  または末尾からのオフセット`suffix-range`として表現される
  - `int-range`における`first-pos`は、範囲内の最初のバイトのオフセットを示し、
    `last-pos`は最後のバイトのオフセットを示し、指定されるバイト位置は両端を含む
  - バイトオフセットは0から開始する
- バイトレンジでは`other-range`指定子は使用されない
- 表現データにコンテントコーディングが適用されている場合、
  各バイト範囲はデコード後のバイト列ではなくエンコード後のバイト列に対して計算される
- クライアントは表現のサイズを知らなくても要求するバイト数を制限できる
- `last-pos`が省略されている場合または現在の表現長以上の値である場合、そのバイト範囲は表現の残り全体を意味する
- クライアントは`suffix-range`を用いて、選択された表現の末尾Nバイトを指定できる
  - 表現が指定の`suffix-length`より短い場合は表現全体が用いられる
- GETリクエストにおいて有効なバイトの`range-spec`は、次のいずれかの場合に満たしうる:
  - 選択された表現の現在の長さよりも`first-pos`小さい`int-range`
  - `suffix-length`が0でない`suffix-range`
  - 選択された表現の長さが0の場合GETリクエストで満たしうる`range-spec`は`suffix-length`が0でない`suffix-range`のみ
- バイト範囲構文では`first-pos`、`last-pos`、`suffix-length`は10進数のオクテット数として表現される
- コンテンツ長に事前の上限は定義されていないため、受信者は非常に大きな10進数を想定する必要がある

### Range
- GETリクエストにおける`Range`リクエストヘッダフィールドは、選択された表現データの全体のうち、
  1つ以上の部分範囲を転送するよう要求する

```
Range = ranges-specifier
```

- サーバは`Range`ヘッダフィールドを無視してもよい
  - オリジンサーバおよび中間キャッシュは、可能な限りバイト範囲をサポートすることが望ましい
    - 部分的に失敗した転送からの効率的な回復や、大きな表現の部分取得を可能にするためである
  - サーバは、未認識あるいは範囲処理が定義されていないリクエストメソッドの`Range`を必ず無視しなければならない
    - RFCで範囲処理が定義されているのはGETのみ
  - オリジンサーバは、理解できない範囲単位を含む`Range`を必ず無視しなければならない
  - プロキシは、理解できない範囲単位を含む`Range`を破棄してもよい
  - 範囲リクエストをサポートするサーバは、以下の場合に`Range`を無視または拒否してもよい:
    - 無効な`ranges-specifier`を含む場合
    - 2つを超える重複範囲を含む場合
    - 多数の小さな範囲が昇順で列挙されていない場合
    - ... これらは、壊れたクライアントや意図的なDoS攻撃の兆候である
- クライアントは、同じデータをカバーする単一範囲より処理・転送効率が低くなる複数範囲を要求するべきではない
- 範囲リクエストをサポートするサーバは、選択された表現にコンテンツがない場合、`Range`を無視してよい
- 複数範囲を要求するクライアントは特別な理由がない限り、昇順で列挙するべき
  - 例外: 大きな表現を内部カタログに基づいて処理するユーザエージェントが、後半部分を先に必要とする場合 など
- `Range`は前提条件の評価後に評価され、かつ`Range`がない場合の結果が200 OK となる場合にのみ適用される
  - 条件付き`GET`が304 Not Modified になる場合、`Range`は無視される
  - `If-Range`ヘッダフィールドは、`Range`を適用するための前提条件として使用できる
- 以下の条件がすべて満たされる場合、サーバは206 Partial Content レスポンスを送るべき:
  - すべての前提条件がtrueである
  - サーバが対象リソースに対して`Range`をサポートしている
  - 受信した`Range`フィールド値が、対象リソースでサポートされる範囲単位を含む有効な`ranges-specifier`
  - 当該`ranges-specifier`が、選択された表現に対して満たしうる
  - ... この場合、レスポンスボディは要求された`range-spec`に対応する1つ以上の部分表現を含む
    - ただし、それは要求されたすべての範囲を必ず送信することを意味しない
    - 場合によっては最初に一部の範囲のみを送信し、残りが必要であればクライアントが後続リクエストで
      再要求することを期待する方が、可能または効率的なこともある
- 以下の条件がすべて満たされる場合、サーバは416 Range Not Satisfiable 応答を送るべき:
  - すべての前提条件がtrueである
  - サーバが対象リソースに対して`Range`をサポートしている
  - 受信した`Range`フィールド値が有効な`ranges-specifier`
  - 範囲単位が対象リソースでサポートされていない、または`ranges-specifier`が選択された表現に対して満たし得ない

### Accept-Ranges
- `Accept-Ranges`レスポンスヘッダフィールドは、
  上流サーバが対象リソースに対して範囲リクエストをサポートしているかどうかを示す
- `Accept-Ranges`は性能向上や不要なネットワーク転送の削減を目的とした助言として機能する

```
Accept-Ranges     = acceptable-ranges
acceptable-ranges = 1#range-unit
```

```
Accept-Ranges: bytes

(その対象リソースに対してバイト範囲リクエストが利用可能であることを示し、
 同一のリクエストパスに対する将来の部分リクエストでレンジの利用をクライアントに促す)
```

- クライアントは`Accept-Ranges`を受信していなくても範囲リクエストを生成してよい
  - `Accept-Ranges`を受信しても、将来の範囲リクエストが必ず部分レスポンスを返すとは限らない
    - コンテンツが変更される可能性、サーバが特定の時点や条件下でのみ範囲リクエストをサポートする可能性、
      次のリクエストが別の中継者によって処理される可能性があるため
- 対象リソースに対していかなる種類の範囲リクエストもサポートしないサーバは、
  `Accept-Ranges: none`のように送信することにより、同一のリクエストパスで範囲リクエストを試みないよう
  クライアントに助言することができる
- `Accept-Ranges`フィールドはトレーラセクションとして送信してもよいヘッダフィールドとして送信する方が望ましい
  - コンテンツ途中で失敗した大容量転送を再開する際に特に有用な情報であるため

### Content-Range
- `Content-Range`レスポンスヘッダフィールドは、当該レスポンスメッセージが元の表現のどの範囲に当たるかを示す
- `Content-Range`の目的:
  - 単一範囲の206 Partial Content レスポンスにおいて、メッセージボディとして返している表現の部分範囲を示す
  - multipart/206 レスポンスの各ボディパートにおいて、そのパートに含まれる範囲を示す
  - 416 Range Not Satisfiable レスポンスにおいて、選択された表現に関する情報を提供する

```
Content-Range       = range-unit SP
                      ( range-resp / unsatisfied-range )

range-resp          = incl-range "/" ( complete-length / "*" )
incl-range          = first-pos "-" last-pos
unsatisfied-range   = "*/" complete-length

complete-length     = 1*DIGIT
```

- 206 Partial Content レスポンスに含まれる`Content-Range`の範囲単位が、受信者にとって理解できないものであった場合、
  受信者は 保存済みの表現と再結合を試みてはならない。プロキシの場合は下流へ転送するべき
- クライアントとオリジンサーバ間の私的な合意に基づき、
  部分PUTのためのリクエスト修飾子として`Content-Range`が送信されることもある
- サーバは`Content-Range`が定義されていないメソッドのリクエストで受信した`Content-Range`ヘッダフィールドを
  無視しなければならない。
- バイト範囲の場合、送信者は範囲が切り出された元の表現の全体長 (`complete-length`) を示すことが望ましい
  - 全体長が不明または算出が困難な場合を除く
  - `complete-length`の代わりに`*`を用いた場合は、ヘッダ生成時点で表現の長さが不明であったことを示す

```
(表現の全体長が1234バイトであることを送信者が把握している場合)

Content-Range: bytes 42-1233/1234
```

```
(全体長が不明な場合)

Content-Range: bytes 42-1233/*
```

- `range-resp`において`last-pos`が`first-pos`より小さい`Content-Range`値は無効
- `complete-length`が`last-pos`以下である`Content-Range`値は無効
- 無効な`Content-Range`を受信した場合、受信者は受信した内容を保存済み表現と再結合してはならない
- バイト範囲リクエストに対して416 Range Not Satisfiable レスポンスを生成するサーバは
  ` unsatisfied-range`を含む`Content-Range`ヘッダフィールドを送信することが望ましい
  - この416レスポンスにおける`complete-length`は、選択された表現の現在の長さを示す

```
Content-Range: bytes */1234
```

- `Content-Range`は、その意味が明示的に定義されていないステータスコードに対しては意味を持たない
  - RFCにおいて`Content-Range`に意味を与えるステータスコードは206 Partial Content と416 Range Not Satisfiable のみ

```
(選択された表現の全体長が1234バイトである場合のContent-Range値の例)

(最初の500バイト)
Content-Range: bytes 0-499/1234

(次の500バイト)
Content-Range: bytes 500-999/1234

(最初の500バイトを除いた全体)
Content-Range: bytes 500-1233/1234

(最後の500バイト)
Content-Range: bytes 734-1233/1234
```

### Partial PUT
- Partial PUT = PUTリクエストに`Content-Range`を添付し、対象リソース状態を部分的に書き換えるよう要求する行為
  - HTTPの標準的なPUT仕様とは互換性がない。正式に標準化された機能ではなくサーバとクライアントの私的合意に依存する
  - オリジンサーバはPartial PUTをサポートしていない対象リソースに対してPUTリクエストで`Content-Range`を受信した場合
    400 Bad Request ステータスコードでレスポンスすることが望ましい
- Partial PUTは、PUTの本来の定義とは後方互換性がないため、現在の表現を完全に置き換える可能性がある
- リソースの一部更新は大きなリソースの一部を別のリソースとして管理する、PATCHメソッドを使うなどで実現できる

### Media Type multipart/byteranges
- 206 Partial Content レスポンスメッセージに 複数の範囲のボディが含まれる場合、
  それらはmultipartメッセージボディとして送信され、メディアタイプには`multipart/byteranges`が使用される
- `multipart/byteranges`メディアタイプは、1 つ以上のボディパートから構成され、
  各パートはそれぞれ独自の`Content-Type`および`Content-Range`ヘッダフィールドを持つ
- 必須パラメータ`boundary`は、各ボディパートを区切るために使用される境界文字列を指定する
  - ボディ内の最初の`boundary`文字列の前に追加のCRLFが存在する場合がある
  - 既存の実装の中には引用符付き`boundary`を正しく扱えないものがある
  - かつての初期ドラフトに基づき、`multipart/x-byteranges`というメディアタイプを使用して実装された
    クライアントやサーバが存在する。これは本仕様とほぼ互換だが、完全ではない
  - `multipart/byteranges`メディアタイプはバイト範囲に限定されない

## Status Codes https://www.ietf.org/rfc/rfc9110.html#name-status-codes
- レスポンスのステータスコードは3桁の整数コードであり、リクエストの結果およびレスポンスの意味論を示す
  - リクエストが成功したかどうかや、(存在する場合) どのようなボディが含まれているかが含まれる
  - 有効なステータスコードの範囲は100..599まで (両端を含む)
    - 100..599の範囲外の値は無効
    - 実装ではライブラリエラーなどを内部的に伝達するために、600..999を使用することがよくある
    - 無効なステータスコードを持つレスポンスを受信したクライアントは、そのレスポンスを5xxと同等に処理すべき
- ステータスコードの最初の1桁はレスポンスのクラスを定義し、残りの2 桁には分類上の意味はない
  - 1xx 情報: リクエストは受信され、処理が継続されている
  - 2xx 成功: リクエストは正常に受信され、理解され、受理された
  - 3xx リダイレクション: リクエストを完了するために追加の操作が必要である
  - 4xx クライアントエラー: リクエストに不正な構文が含まれている、または処理できない
  - 5xx サーバエラー: 一見すると有効なリクエストを、サーバが処理できなかった
- HTTP ステータスコードは拡張可能
- クライアントは、登録されているすべてのステータスコードの意味を理解している必要はない
- クライアントは、最初の桁によって示されるステータスコードのクラスを理解しなければならない
- クライアントは、認識できないステータスコードはそのクラスに対応する`x00`と同等として扱わなければならない
- 単一のリクエストに複数のレスポンスが関連付けられる場合がある
  - e.g. ステータスコードが1xx範囲に属する中間 (interim)レスポンスが0個以上続き、
    その後に他のいずれかの範囲のステータスコードを持つ最終 (final) レスポンスが正確に1つ送られる

### Overview of Status Codes
- RFCで定義されているステータスコードの示す理由句はあくまで推奨
  - ローカルな等価表現に置き換えたり、完全に省略したりしてもよい
- ヒューリスティックにキャッシュ可能と定義されているステータスコードが付いたレスポンスは、
  メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、
  ヒューリスティックな有効期限を用いてキャッシュにより再利用されてよい
  - e.g. 200、203、204、206、300、301、308、404、405、410、414、501
  - それ以外のステータスコードは、ヒューリスティックにキャッシュ可能ではない
- 本仕様の範囲外においても、HTTPで使用するための追加のステータスコードが定義されている
  - それらはすべて第16.2節で述べられているHypertext Transfer Protocol (HTTP) Status Code Registryに登録されるべき

### Informational 1xx
- 1xxのステータスコードは、要求された操作を完了し最終レスポンスを送信する前に、
  接続状態やリクエストの進行状況を伝達するための中間レスポンスを示す
  - HTTP/1.0では1xxステータスコードが定義されていなかったため、
    サーバはHTTP/1.0クライアントに対して1xx レスポンスを送信してはならない
- 1xxレスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない
- クライアントは最終レスポンス前に受信した1つ以上の1xxレスポンスを (想定外の受信でも) 解析できなければならない
  - ユーザエージェントは予期しない1xxレスポンスを無視してもよい
- プロキシは1xxレスポンスの生成をプロキシ自身が要求した場合を除き、1xxレスポンスを転送しなければならない
  - プロキシがリクエストを転送する際に`Expect: 100-continue`ヘッダフィールドを追加した場合、
    対応する100レスポンスを転送する必要はない

#### 100 Continue
- 100 Continue ステータスコードは、リクエストの初期部分が受信され、かつサーバによってまだ拒否されていないことを示す
  - サーバはリクエスト全体を受信して処理した後に、最終レスポンスを送信する意図を持っている
- リクエストに`Expect: 100-continue`ヘッダフィールドが含まれている場合、
  100レスポンスはサーバがリクエストのボディを受信したいと考えていることを示す
  - この場合クライアントはリクエストの送信を継続し100レスポンスは破棄すべきである
- リクエストに`Expect: 100-continue`ヘッダフィールドが含まれていない場合、クライアントはこのレスポンスを破棄可能

#### 101 Switching Protocols
- 101 Switching Protocols ステータスコードは、この接続上で使用されているアプリケーションプロトコルを変更するという
  `Upgrade`ヘッダフィールドによるクライアントの要求をサーバが理解し、かつそれに従う意思があることを示す
  - サーバはこのレスポンスの後、レスポンス内に有効となるプロトコルを示す`Upgrade`ヘッダフィールドを
    必ず生成しなければならない
- サーバは、プロトコルの切り替えが有利である場合にのみ切り替えに同意すると想定されている
  - 古いバージョンよりも新しいHTTPバージョンへ切り替えることが有利な場合や、
    リアルタイムかつ同期的な特性を用いるリソースを配信する際に
    そのような特性を持つプロトコルへ切り替えることが有利な場合など

### Successful 2xx
- 2xxのステータスコードは、クライアントのリクエストが正常に受信され、理解され、受理されたことを示す

#### 200 OK
- 200 OK ステータスコードはリクエストが成功したことを示す
- 200レスポンスで送信される内容はリクエストメソッドに依存する

| リクエストメソッド | レスポンス内容が表すもの                     |
| - | - |
| GET                | 対象リソース                                 |
| HEAD               | 対象リソース (表現データは転送されない)      |
| POST               | 処理の状態、または処理によって得られた結果   |
| PUT, DELETE        | 処理の状態                                   |
| OPTIONS            | 対象リソースに対する通信オプション           |
| TRACE              | サーバが受信したとおりのリクエストメッセージ |

- 200レスポンスにはメッセージ内容が含まれることが期待される
  - CONNECTに対するレスポンスを除く
    - CONNECTの成功の結果はトンネルの確立であり、それは200レスポンスのヘッダセクション直後から開始されるため、
      ボディは存在しない
  - メッセージのフレーミングによってボディの長さが0であることが明示されている場合を除く
    - 成功時にボディを含めないことを示す何らかの要素がリクエストに含まれている場合、
      オリジンサーバは代わりに204 No Content レスポンスを送信すべき
- 200レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- GETまたはHEADに対する200レスポンスでは、オリジンサーバは選択された表現に対し
  利用可能なすべての検証子フィールドを送信すべき
  - 特に、強いETagと`Last-Modified`日付の両方を送信することが望ましい
- 状態を変更するメソッドに対する200レスポンスにおいて、レスポンスに含まれる検証子フィールドは、
  リクエストの意味論が正常に適用された結果として生成された新しい表現に対する、現在の検証子を示す
  - PUTメソッドにはこれらの検証子を送信できない場合がある追加要件が存在する

#### 201 Created
- 201 Created ステータスコードは、リクエストが履行された結果として1つ以上の新しいリソースが作成されたことを示す
- リクエストによって作成された主要なリソースは、
  レスポンスに`Location`ヘッダフィールドが含まれている場合はそれによって、
  含まれていない場合は対象URIによって識別される
- 201レスポンスのボディは、通常作成されたリソースを記述し、それらへのリンクを含む
- レスポンスに含まれる検証子フィールドは、リクエストによって作成された新しい表現に対する現在の検証子を示す
  - PUTメソッドには、これらの検証子を送信できない場合がある追加要件が存在する

#### 202 Accepted
- 202 Accepted ステータスコードは、リクエストが受理されたものの、その処理がまだ完了していないことを示す
  - 実際に処理が行われるかどうかは未確定であり、後になって拒否される可能性もある
    - HTTP には、非同期処理の結果として後からステータスコードを再送する仕組みは存在しない
- 202レスポンスは意図的に確約を避けている
- 202レスポンスの目的は、サーバが別のプロセスのためにリクエストを受理しつつ、
  処理が完了するまでユーザエージェントとサーバとの接続を維持することを要求しないようにすること
- 202レスポンスとともに送信される表現は、リクエストの現在の状態を記述し、
  リクエストがいつ履行される見込みかを利用者に示すためのステータス監視手段を指し示すべき

#### 203 Non-Authoritative Information
- 203 Non-Authoritative Information ステータスコードは、リクエスト自体は成功したものの、
  同じリクエストに対してオリジンサーバが返す200 OK レスポンスの内容が
  変換プロキシによって変更されていることを示す
- 203レスポンスは内容に変換が適用された事実を受信者に通知するためのものであり、
  その情報は後続の意思決定に影響を与える可能性がある
  - その内容に対する将来のキャッシュ検証リクエストは、同一のリクエスト経路に沿ってのみ有効である場合がある
- 203レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 204 No Content
- 204 No Content ステータスコードは、サーバがリクエストを正常に履行した上で、
  レスポンスボディとして送信すべき追加のコンテンツが存在しないことを示す
  - レスポンスのヘッダフィールドに含まれるメタデータは、要求された操作が適用された後の対象リソース
    および選択されたその表現を参照する
  - e.g. PUTリクエストに対するレスポンスとして204レスポンスが返され、かつレスポンスに`ETag`が含まれている場合、
    そのPUTは成功しており、`ETag`の値には対象リソースの新しい表現に対するETagが含まれていることを意味する
- 204レスポンスは、対象リソースに対する操作が正常に適用されたことを示しつつ、
  ユーザエージェントが現在のドキュメント表示から遷移する必要がないことを暗黙に示す
  - サーバはユーザエージェントが自身のインターフェースに従って利用者に成功を何らかの形で通知し、
    レスポンスに含まれる新規または更新されたメタデータを、現在アクティブな表現に適用することを前提としている
  - 204ステータスコードは保存操作に対応するドキュメント編集インターフェースで一般的に用いられ、
    保存対象のドキュメントはそのまま利用者が編集可能な状態に保たれる
  - 分散バージョン管理システムのように、自動化されたデータ転送が多用されることを想定したインターフェースでも
    頻繁に使用される
- 204レスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない
- 204レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 205 Reset Content
- 205 Reset Content ステータスコードは、サーバがリクエストを履行したうえで、
  そのリクエスト送信の原因となったドキュメント表示をオリジンサーバから受信した当初の状態にリセットすることを
  ユーザエージェントに求めていることを示す
  - 一般的なデータ入力のユースケースを支援することを目的としている
    - e.g. ユーザーがデータ入力を支援するコンテンツを受け取り、その領域でデータを入力または操作し、
      その入力内容をリクエストとして送信した後、次の入力操作を容易に開始できるようにデータ入力機構をリセットする
- 205ステータスコードは追加のコンテンツが提供されないことを意味する
  - サーバは205レスポンスに内容を生成してはならない

#### 206 Partial Content
- 206 Partial Content ステータスコードは、選択された表現の一部を転送することによって、
  サーバが対象リソースに対する範囲リクエストを履行していることを示す
  - 範囲リクエストをサポートするサーバは通常、要求されたすべての範囲を満たそうとする
    (送信するデータを減らすと残りの部分を取得するためにクライアントから追加のリクエストが送られる可能性が高いため)
  - サーバ自身の都合により要求されたデータの一部のみを送信する場合もある
    - 206は自己記述的なため、部分的充足であってもクライアントは解釈可能
- クライアントは206レスポンスに含まれる`Content-Type`および`Content-Range`フィールドを検査し、
  どの部分が含まれているか、追加のリクエストが必要かどうかを判断しなければならない
- 206レスポンスを生成するサーバは、同一リクエストに対して200で送るはずだった以下のヘッダを、
  該当する場合は生成しなければならない:
  - `Date`
  - `Cache-Control`
  - `ETag`
  - `Expires`
  - `Content-Location`
  - `Vary`
  - `Content-Length` (このメッセージのボディ長)
  - `Content-Range` (各範囲が表現全体のどこに位置するか) (全長情報を含む)
- `If-Range`ヘッダフィールドを含むリクエストに対して206レスポンスを生成する送信者は、
  必須とされるもの以外の表現ヘッダフィールドを生成すべきではない
  - クライアントがすでにそれらのヘッダフィールドを含む過去のレスポンスを保持しているためである
- 206レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- Single Part:
  - 単一の部分のみが転送される場合、206レスポンスを生成するサーバは選択された表現のどの範囲が含まれているかを示す
    `Content-Range`ヘッダフィールドと、その範囲に対応する内容を生成しなければならない

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
```

- Multiple Parts:
  - 複数の部分が転送される場合、206レスポンスを生成するサーバは、`multipart/byteranges`ボディを生成し、
    そのメディアタイプおよび必須の`boundary`パラメータを含む`Content-Type`ヘッダフィールドを生成しなければならない
  - Single Partレスポンスとの混同を避けるため、
    サーバはMultiple PartsレスポンスのHTTPヘッダセクションに`Content-Range`ヘッダフィールドを生成してはならない
    - このフィールドは、代わりに各パート内で送信される。
  - 各ボディパートのヘッダ領域内では、そのパートに含まれる範囲に対応する`Content-Range`を生成しなければならない
    - 選択された表現が200 OK レスポンスにおいて`Content-Type`を持っていたであろう場合、
      サーバは各パートのヘッダ領域内でも同じ`Content-Type`ヘッダフィールドを生成すべき
  - 複数の範囲が要求された場合、サーバは要求された範囲指定の順序にかかわらず、
    重複する範囲や複数パート送信のオーバーヘッドよりも小さいギャップしか持たない範囲を結合してもよい
    - 通常、`multipart/byteranges`の各パート間のオーバーヘッドは、
      表現のメディアタイプや`boundary`の長さにもよるがおよそ80バイト程度
      - そのため、多数の小さく分断された部分を転送するよりも、表現全体を転送するほうが効率的な場合がある
  - サーバは、単一範囲のみを要求するリクエストに対して`multipart`レスポンスを生成してはならない
    - 複数パートを要求していないクライアントが`multipart`レスポンスをサポートしていない可能性があるため
      - 複数範囲が要求され、そのうち1つのみが満たされた場合や、結合の結果1つの範囲のみが残った場合には、
        単一パートのみを含む`"multipart/byteranges"`レスポンスを生成してもよい
      - `multipart/byteranges`レスポンスを処理できないクライアントは複数範囲を要求するリクエストを生成してはならない
  - サーバは、満たされなかった範囲や他の範囲に結合されたものを除き、
    `Range`ヘッダフィールドに現れた順序と同じ順序でパートを送信すべき
    - `multipart`レスポンスを受信したクライアントは各ボディパートに含まれる`Content-Range`ヘッダフィールドを検査し
      そのパートにどの範囲が含まれているかを判断しなければならない
      - クライアントは、自身が要求した範囲やその順序がそのまま返されると仮定してはならない

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
```

- Combining Parts:
  - 接続が途中で切断された場合や、1つ以上の`Range`指定を用いたリクエストの場合、
    レスポンスは表現の一部分のみを転送することがある
    - こうした転送が複数回行われると、クライアントは同一表現の複数の範囲を受信している可能性がある
    - これらの範囲は、すべてが同一の強い検証子を共有している場合にのみ、安全に結合できる
  - 対象リソースに対するGETリクエストの複数の部分レスポンスを受信したクライアントは、
    それらが同一の強い検証子を共有している場合、より大きな連続範囲に結合してもよい
  - 最新のレスポンスが不完全な200 OK レスポンスである場合、そのレスポンスのヘッダフィールドが
    結合後のレスポンスに使用され、対応する保存済みレスポンスのヘッダフィールドを置き換える
  - 最新のレスポンスが206 Partial Content であり、対応する保存済みレスポンスの少なくとも1つが200 OK である場合、
    結合後のレスポンスのヘッダフィールドは、最新の200レスポンスのものから構成される
    - 対応する保存済みレスポンスがすべて206レスポンスである場合、最も新しいヘッダフィールドを持つ
      保存済みレスポンスが、結合後のレスポンスのヘッダフィールドの元として使用される
      - クライアントは`Content-Range`を除き、新たなレスポンスで提供された他のヘッダフィールドを用いて、
        保存済みレスポンス中の対応するヘッダフィールドをすべて置き換えなければならない
  - 結合後のレスポンスボディは、新しいレスポンスおよび対応するすべての保存済みレスポンスに含まれる
    部分範囲の和集合から構成される
    - その和集合が表現全体の範囲を含む場合、クライアントは完全な長さを反映した`Content-Length`を含む、
      完全な200 OK レスポンスであるかのように結合後のレスポンスを処理しなければならない
      - そうでない場合クライアントは、連続した範囲の集合を次のいずれかとして処理しなければならない:
        - (結合後のレスポンスが表現の先頭部分である場合) 不完全な200 OK レスポンス
        - `multipart/byteranges`ボディを含む単一の206 Partial Content レスポンス
        - それぞれが`Content-Range`によって示される1つの連続範囲を持つ複数の206 Partial Content レスポンス

### Redirection 3xx
- 3xxステータスコードは、リクエストを履行するためにユーザエージェントによる追加の操作が必要であることを示す
  - 301 Moved Permanently、302 Found、307 Temporary Redirect、308 Permanent Redirect
    - 別のURIにリソースが存在する可能性を示すリダイレクション
    - `Location`ヘッダフィールドによって示されるURIにおいて利用可能である可能性を示す
  - 300 Multiple Choices
    - 同一リソースを表現しうる複数の候補から選択肢を提示するリダイレクション
  - 303 See Other
    - 間接的なレスポンスを表す別リソースへのリダイレクション
    - Location ヘッダフィールドで識別される別リソースを指すもの。
  - 304 Not Modified
    - 以前に保存された結果へのリダイレクション

```
歴史

HTTP/1.0では301 Moved Permanently および302 FoundはCERNにおける実装に合わせ、
メソッドを保持するものとして定義されていた。

一方、303 See Other はメソッドをGETに変更するリダイレクションとして定義された。

初期のユーザエージェントは、POST リクエストをリダイレクトする際に、
当時の仕様どおりPOSTのままにするか、より安全な代替としてGETに変更するかで挙動が分かれていたが、
最終的に、主流の実装はGETに変更する挙動へと収束した。

これを踏まえ、後に307 Temporary Redirect および308 Permanent Redirect が追加され、
メソッドを保持するリダイレクションであることを明確に示すようになった。
また、301 および 302 についても、POSTリクエストをGETとしてリダイレクトできるよう調整された。
```

- `Location`ヘッダフィールドが提供されている場合、ユーザエージェントはたとえそのステータスコードの詳細な意味を
  理解していなくても、`Location`フィールド値が参照するURIへ自動的にリダイレクトしてもよい
  - 「安全であると知られていない」メソッドについては、利用者がそのようなリクエストのリダイレクトを望まない可能性が
    あるため、自動リダイレクトは慎重に行う必要がある
- リダイレクトされたリクエストを自動的に追跡する場合、ユーザエージェントは以下の修正を加えたうえで、
  元のリクエストメッセージを再送信すべき:
  - 対象URIを、リダイレクトレスポンスの`Location`値が参照するURI (元の対象URIに対して相対解決したもの) に置き換える
  - 実装によって自動生成されたヘッダフィールドを削除し、新しいリクエストに適切な値で置き換える:
    - 接続固有のヘッダフィールド
    - クライアントのプロキシ設定に固有のヘッダフィールド (`Proxy-Authorization` など)
    - オリジン固有のヘッダフィールド (`Host` など)
    - 実装のキャッシュによって追加された検証用ヘッダフィールド (`If-None-Match`、`If-Modified-Since` など)
    - リソース固有のヘッダフィールド (`Referer`、`Origin`、`Authorization`、`Cookie` など)
  - セキュリティ上の影響がある場合には、実装が自動生成していないヘッダフィールドについても削除を検討する
    - `Authorization`、`Cookie`やそれ以外
  - リダイレクトを指示するステータスコードの意味論に従い、必要に応じてリクエストメソッドを変更する
  - リクエストメソッドがGETまたはHEADに変更された場合、ボディ固有のヘッダフィールドを削除する
    - `Content-Encoding`
    - `Content-Language`
    - `Content-Location`
    - `Content-Type`
    - `Content-Length`
    - `Digest`
    - `Last-Modified` など
- クライアント無限リダイレクトループを検出し、介入すべき
  - 本仕様の以前の版では、最大5回までのリダイレクションを推奨していた
  - コンテンツ開発者は、クライアントによってそのような固定上限を実装している場合があることを認識しておく必要がある

#### 300 Multiple Choices
- 300 Multiple Choices ステータスコードは、対象リソースが複数の表現を持ち、
  それぞれがより具体的な識別子を有していることを示す
  - 利用者 (またはユーザエージェント) がそれらの識別子の1つ以上へリクエストをリダイレクトすることによって
    好ましい表現を選択できるよう、代替案に関する情報が提供されていることを意味する
    - サーバはユーザエージェントがReactive Negotiationに関与し、自身の要件に最も適した表現を選択することを望む
- サーバに優先する選択肢がある場合、サーバはその優先選択肢のURI参照を含む`Location`ヘッダフィールドを生成すべき
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
- HEAD以外のリクエストメソッドに対して、サーバは利用者またはユーザエージェントが最も好ましいものを選択できるよう
  表現のメタデータおよびURI参照の一覧を含むボディを300レスポンスで生成すべき
  - ユーザエージェントは、提供されたメディアタイプを理解できる場合、その一覧から自動的に選択してもよい
    - 自動選択のための特定の形式は本仕様では定義されていない (HTTPが内容の定義から独立であることを目指しているため)
      - 実際には共有された設計やコンテンツネゴシエーションによってユーザエージェントに受け入れられると考えられる
        解析しやすい形式、一般的に受け入れられているハイパーテキスト形式で表現が提供される
- 300レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 301 Moved Permanently
- 301 Moved Permanently ステータスコードは、対象リソースに新しい恒久的なURIが割り当てられ、
  将来このリソースを参照する際には同封されているURIのいずれかを使用すべきであることを示す
  - サーバはリンク編集機能を備えたユーザエージェントであれば、対象URIへの参照を、
    サーバが送信した新しい参照のいずれかに恒久的に置き換えられることを示唆している
    - 一般的に、ユーザエージェントが実際に参照の編集を行っており、接続がセキュアで、
      かつオリジンサーバが編集対象コンテンツの信頼できる権威である場合を除いてはサーバの示唆は無視される
- サーバは新しい恒久的URIの優先候補を示す`Location`ヘッダフィールドをレスポンスに生成すべき
  - ユーザエージェントは自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、新しいURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 歴史的な理由によりユーザエージェントは、後続のリクエストにおいてリクエストメソッドをPOSTからGETへ変更してもよい
  - その挙動が望ましくない場合は、代わりに308 Permanent Redirect ステータスコードを使用できる
- 301レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる

#### 302 Found
- 302 Found ステータスコードは、対象リソースが一時的に別のURIの下に存在していることを示す
  - このリダイレクションは状況に応じて変更される可能性があるため、クライアントは将来のリクエストにおいても、
    引き続き元の対象URIを使用すべき
- サーバは、別のURIを示すURI参照を含む`Location`ヘッダフィールドをレスポンスに生成すべきである
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
    - サーバのレスポンスボディには通常、別のURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 歴史的な理由によりユーザエージェントは、後続のリクエストにおいてリクエストメソッドをPOSTからGETへ変更してもよい
  - その挙動が望ましくない場合は、代わりに307 Temporary Redirect ステータスコードを使用できる

#### 303 See Other
- 303 See Other ステータスコードは、`Location`ヘッダフィールドに示されたURIによって識別される別のリソースへ、
  ユーザエージェントをリダイレクトすることをサーバが意図していることを示す
  - 対象の別リソースは元のリクエストに対する間接的なレスポンスを提供することを目的としている
  - ユーザエージェントは、そのURIを対象とした取得リクエスト (GET / HEAD)を実行でき、
    その取得リクエストがさらにリダイレクトされる場合もある
  - 最終的に得られた結果は元のリクエストに対する回答として提示されうる
  - `Location`ヘッダフィールドに示される新しいURIは、元の対象URIと等価なものとは見なされない
- このステータスコードは、あらゆるHTTP メソッドに適用可能
  - 主な用途はPOST出力を別のリソースへユーザエージェントをリダイレクトさせること
    - POSTレスポンスに対応する情報を個別に識別可能でブックマーク可能かつキャッシュ可能なリソースとして提供するため
- GETリクエストに対する303レスポンスはオリジンサーバがHTTPを介して転送可能な対象リソースの表現を持たないことを示す
  - `Location`フィールド値が参照するリソースは対象リソースを記述するものであり、
    その別リソースに対して取得リクエストを行うことによって受信者に有用な表現が得られる可能性がある
    - それが元のターゲットリソースを表現していることを意味するわけではない
      (何が表現可能であるか、どの表現が適切か、何が有用な記述であるかといった問題はHTTPの範囲外)
- HEADリクエストに対するレスポンスを除き、303レスポンスの表現には、
  `Location`ヘッダフィールドに示されたURI参照へのハイパーリンクを含む短いハイパーテキストの注記を含めるべきである

#### 304 Not Modified
- 304 Not Modified ステータスコードは、条件付きのGETまたはHEADリクエストが受信され、
  その条件がfalseと評価されて200 OK レスポンスにはならなかったことを示す
  - その条件がなければ200 OK になっていたとしても、条件付きリクエストを行ったクライアントはすでに
    有効な表現を保持しているため、サーバが対象リソースの表現を転送する必要はない
    - サーバはクライアントに対し、保存済みの表現を200 OK レスポンスのボディであるかのように利用するよう促している
- 304レスポンスを生成するサーバは、同一リクエストに対して200 OK レスポンスで送信されていたであろう、
  以下のヘッダフィールドを生成しなければならない:
  - `Content-Location`
  - `Date`
  - `ETag`
  - `Vary`
  - `Cache-Control`および`Expires`
- 304レスポンスの目的は受信者がすでに1つ以上のキャッシュ済み表現を保持している場合に、情報転送量を最小化すること
  - そのため送信者は、上記に列挙されたフィールド以外の表現メタデータを生成すべきではない
    - ただし、キャッシュ更新を誘導する目的で必要なメタデータがある場合はこの限りではない
      - 304レスポンスを受信したキャッシュに対する要件は、［CACHING］の 4.3.4 節で定義されている。
- 条件付きリクエストが共有プロキシに対して条件付きGETを送信する独自キャッシュを持つユーザエージェントなど
  外向きのクライアントから発せられたものである場合、そのプロキシは304レスポンスを当該クライアントへ転送すべき
- 304レスポンスはヘッダセクションの終了によって完結し、ボディやトレーラを含むことはできない

#### 305 Use Proxy
- 305 Use Proxy ステータスコードは、本仕様の以前の版で定義されていたが、現在は非推奨

#### 306 (Unused)
- 306 ステータスコードは、本仕様の以前の版で定義されていたが、現在は使用されておらず、このコードは予約済み

#### 307 Temporary Redirect
- 307 Temporary Redirect ステータスコードは、対象リソースが一時的に別のURIの下に存在していることを示す
- ユーザエージェントがそのURIへ自動的にリダイレクトを行う場合、リクエストメソッドを変更してはならない
    - このリダイレクションは時間とともに変更される可能性があるため、クライアントは将来のリクエストにおいても、
      引き続き元の対象URIを使用すべき
- サーバは別のURIを示すURI 参照を含む`Location`ヘッダフィールドをレスポンスに生成
  - ユーザエージェントは、自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、別のURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる

#### 308 Permanent Redirect
- 308 Permanent Redirect ステータスコードは、対象リソースに新しい恒久的なURIが割り当てられ、
  将来このリソースを参照する際には同封されているURIのいずれかを使用すべきであることを示す
  - サーバはリンク編集機能を備えたユーザエージェントであれば、対象URIへの参照を、
    サーバが送信した新しい参照のいずれかに恒久的に置き換えられることを示唆している
    - 一般的に、ユーザエージェントが実際に参照の編集を行っており、接続がセキュアで、
      かつオリジンサーバが編集対象コンテンツの信頼できる権威である場合を除いてはサーバの示唆は無視される
- サーバは新しい恒久的URIの優先候補を示す`Location`ヘッダフィールドをレスポンスに生成すべきである
  - ユーザエージェントは自動リダイレクトのために`Location`フィールド値を使用してもよい
- サーバのレスポンスボディには通常、新しいURIへのハイパーリンクを含む短いハイパーテキストの注記が含まれる
- 308レスポンスはヒューリスティックにキャッシュ可能
  - メソッド定義または明示的なキャッシュ制御によって別途示されていない限り、キャッシュにより再利用されうる
- 308 Permanent Redirect ステータスコードは比較的新しく (2014年6月) 、環境によっては認識されない可能性がある

### Client Error 4xx
#### 400 Bad Request
#### 401 Unauthorized
#### 402 Payment Required
#### 403 Forbidden
#### 404 Not Found
#### 405 Method Not Allowed
#### 406 Not Acceptable
#### 407 Proxy Authentication Required
#### 408 Request Timeout
#### 409 Conflict
#### 410 Gone
#### 411 Length Required
#### 412 Precondition Failed
#### 413 Content Too Large
#### 414 URI Too Long
#### 415 Unsupported Media Type
#### 416 Range Not Satisfiable
#### 417 Expectation Failed
#### 418 (Unused)
#### 421 Misdirected Request
#### 422 Unprocessable Content
#### 426 Upgrade Required
### Server Error 5xx
#### 500 Internal Server Error
#### 501 Not Implemented
#### 502 Bad Gateway
#### 503 Service Unavailable
#### 504 Gateway Timeout
#### 505 HTTP Version Not Supported
