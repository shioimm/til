# RFC 9110 HTTP Semantics https://www.ietf.org/rfc/rfc9110.html
## Terminology and Core Concepts https://www.ietf.org/rfc/rfc9110.html#name-terminology-and-core-concep
- resource - リクエストの対象。URIによって識別される
- representation - リソースの状態の反映。リクエストに基づきコンテンツネゴシエーションによって選択される
- client - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- server - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- messages - 接続を介して交換される情報
- user agent - リクエストを開始するさまざまなクライアントアプリケーション (Webブラウザなど)
  - Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- origin server - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- intermediary - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
  - proxy - クライアントが利用するメッセージ転送エージェント
  - gateway (reverse proxy) - オリジンサーバが利用するメッセージ転送エージェント
  - tunnel - メッセージを変更せずにユーザーエージェント/オリジンサーバ間を中継する
- cache - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP https://www.ietf.org/rfc/rfc9110.html#name-identifiers-in-http
### URI References
- HTTPではURI Referencesの形式ごとに使用可能な場面を厳密に定義している
  - 明示がない場合URI ReferencesはターゲットURIを基準として相対的に解析される

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

### Authoritative Access
- 特定の識別子を解決して識別されたリソースへのアクセスを行う際、
  そのアクセスがリソース所有者によって制御されているとクライアントが信頼できる形で行われること
- アクセスが許可されるかどうかのプロセスはURIスキームによって定義される

#### URI Origin
- 正規化されたスキーム / ホスト / ポートの3要素からなる組。HTTPにおける名前空間と権限の境界を形成する。

#### http Origin
- URIに含まれるauthority (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバがそのURIを代表しているとみなされるオリジン (論理的な起点)

#### https Origin
- URIに含まれるhost:portではなく、そのoriginに対して有効であるとクライアントが信頼する証明書に対応する秘密鍵を持つ
  サーバに対して確立される権威 (authority) に基づくオリジン
- H1 - URI originのhostに対してTLSで保護された接続が直接確立されている場合にauthorityを認める
- H2/H3 - 証明書に含まれる複数のhostに対して接続可能であるとクライアントが信頼できる場合にauthorityを認める

#### https Certificate Verification
- httpsでURIをdereferenceする際、クライアントは接続先サービスの身元がそのURIのoriginと正しく一致していることを
  RFC6125に基づく証明書検証によって確認する

#### IP-ID Reference Identity
- httpsでホストにIPリテラルを用いる場合、参照アイデンティティはIP-ID (P Address Identity) となり、
  証明書のsubjectAltNameに含まれるiPAddressと完全一致する必要がある

## Fields https://www.ietf.org/rfc/rfc9110.html#name-fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される
-
### Field Names

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
- プロキシはConnectionヘッダフィールドにそのフィールド名が列挙されていない限り
  or 当該フィールドを遮断もしくは変換するよう明示的に設定されていない限り、
  認識できないヘッダフィールドをオリジンに転送しなければならない
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する

### Field Lines and Combined Field Value / Field Order
- フィールドは任意数のフィールド行から構成され、フィールド行はフィールド名とフィールド行値から構成される
- 同一フィールド名が複数行で現れた場合、フィールド値は各行の値を順にカンマ区切りで連結したものとして解釈される
  - 送信者は原則として複数同名フィールドを複数送信してはいけない (実務上の都合によりSet-Cookieを除く)
  - サーバはヘッダ全体を受信し終えるまで処理してはならない

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
- サーバ側では大きすぎるヘッダを受け取った場合、適切な4xxを返す
- クライアント側では大きすぎるヘッダを受け取った場合、レスポンスの意味を変えない範囲で破棄したり切り詰めても良い

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
- CR / LF / NULを含むfield valueは無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
- Singleton fields - フィールド値として単一の要素のみを想定するフィールド
- List-based fields - フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される

### Common Rules for Defining Field Values
- カンマ区切りの値の列の可読性を上げるために`#rule`ABNF拡張が定義されている

```
<n>#<m>element

最低n個~最大m個のelementをカンマ + OWS区切りで並べる

e.g.
  example-list      = 1#example-list-elmt
  example-list-elmt = token

において、

<有効>
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"

<無効>
  ""
  ","
  ",   ,"
```

- 送信者は空要素を生成してはいけない。受信者は妥当な範囲で空要素を無視する。
- token - 最も基本的な識別子。1文字以上、空白や区切り文字を含まない、可視ASCIIのうちdelimiterを除いた集合
- OWS - 任意空白。送信者は生成可能、受信者はSP1個に正規化可能
- RWS - 必須空白。送信者はSP 1個を生成推奨、受信者はSP 1個に正規化可能
- BWS - 悪い空白。送信者は生成禁止、受信者は必ず削除
- quoted-string - `"`で囲まれた空白・カンマ・特殊文字を含む値
- パラメータ構文 - フィールド値に付加情報を付ける共通形式

```
パラメータ構文

; name=value

name  ... token (大文字小文字を区別しない)
value ... token or quoted-string
= の前後に空白は禁止
```

- 日時形式はUTC (GMT) 固定。送信者はIMF-fixdateのみ生成可能、送信者はIMF-fixdate、RFC 850形式、asctime形式を受理

## Message Abstraction (HTTPメッセージの抽象データ型) https://www.ietf.org/rfc/rfc9110.html#name-message-abstraction
- メッセージの構成要素
  - Control data (制御データ) メッセージの種別・経路決定に必要な即時情報
  - Headers lookup table (ヘッダ表) 制御データを拡張し追加情報を伝えるための名前:値の組の集合
  - Content (本文ストリーム) 任意・サイズ無制限のデータ
  - Trailers lookup table (トレーラ表) 本文送信中に得られた情報を伝えるための名前:値の組の集合
- メッセージはストリームとして前方から順に処理される
  - 制御データは受信者が即座に知る必要のある事項
  - ヘッダフィールドは受信者がコンテンツ受信前に知る必要のある事項
  - コンテンツはメッセージのセマンティクスを満たすために受信者が必要とする本体
  - トレーラフィールドはコンテンツ送信前には不明であった任意のメタデータ
- メッセージはそれ自体で意味が完結することを意図 (自己記述性)
- クライアントは対応するレスポンスを解析・解釈・キャッシュする際には
  それに対応するリクエストに関する知識を保持していなければならない

### Framing and Completeness
- メッセージフレーミング = 各メッセージがどこから始まり、どこで終わるのかを示す仕組み
  - メッセージは同一の接続上を流れる他のメッセージと区別される必要がある
- メッセージデータを長さで区切る (length-delimited) 形式で送信することによって明示的フレーミングを行う
  - Content-Length
  - Transfer-Encoding: chunked
  - HTTP/2 / HTTP/3のフレーム境界
- そのフレーミングによって示されたすべてのオクテットが受信可能になった時点でそのメッセージは完了
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- リクエストメッセージの制御データ
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データ
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前: 制御データはメッセージの最初の行で送信される
- HTTP/2 / HTTP/3: 制御データは予約された名前プレフィックスを持つ疑似ヘッダフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージはバージョンを持つ
  - バージョンはメッセージ内で明示される場合やメッセージが受信された接続から推定される場合がある
  - 受信者はバージョン情報を用いて送信者との以後の通信における制約や可能性を判断する
  - メッセージが転送される場合は中継者が使うバージョンに更新される (上流のプロトコルバージョンはViaヘッダに記載)
  - クライアントは自身が準拠している中で最高の、かつサーバがサポートしている最高以下のバージョンを送信する
  - サーバは自身が準拠している中で最高の、かつ受信したリクエストの最高以下のバージョンを送信する

### Header Fields
- 本文 (Content) より前に送受信され、メッセージの意味を補足・拡張したり、追加の情報を記述するためのメタデータ
- ヘッダフィールド = ヘッダフィールド行 (フィールド名 + フィールド値) の並び

### Content
- メッセージフレーミングによって区切られたヘッダの後に送信されるバイトストリーム (フレーミングを除去した実データ)

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

#### Identifying Content
- 完全または部分的な表現がメッセージ本文として転送される場合、
  その本文がどのリソースのどの表現なのかを識別できることが望ましい

### Trailer Fields
- 本文 (Content) より後に送受信され、本文を送信し終えた後でしか確定しない情報を伝えるためのメタデータ
  - メッセージ整合性チェック
  - デジタル署名
  - 配送メトリクス
  - 後処理の結果や状態情報 など
- ヘッダセクションのフィールドとは別個に処理・保存されるべき
- 特定のヘッダフィールドの有無はメッセージ全体の扱いに影響するため、
  その場合は後からトレーラが到着しても取り消すことはできない

#### Limitations on Use of Trailers
- 使用中のHTTPバージョンが対応しており、かつ明示的なフレーミング機構によって有効化されている場合にのみ利用できる
- トレーラは中間者によって破棄される可能性がある
  - サーバはトレーラーフィールドとしてユーザーエージェントが必ず受信すべき情報を送信すべきではない
- 受信者は、対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラ値を安全に統合できる方法を
  明示的に許可・規定されいる場合を除き、トレラーフィールドをヘッダーセクションに統合してはならない
- リクエストの`TE`ヘッダに`"trailers"`が含まれる場合、クライアントがトレーラを受け取っても破棄しない意図示す
  - ただし処理をするとは言っていない

#### Processing Trailer Fields
- トレーラセクションで送信される可能性のあるフィールド名を事前に示すために`Trailer`ヘッダフィールドを利用できる
- 同じ名前を持つトレーラーフィールドは受信した順序で処理される
- 同一名のトレーラフィールド行が複数存在する場合、値はリストとして連結される

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- メッセージが生成された日時 (HTTP-date 形式)
- 時計を持つオリジンサーバは、2xx、3xx、4xx系レスポンスにおいては必ず`Date`ヘッダフィールドを生成しなければならない
- 時計を持たないオリジンサーバは、`Date`ヘッダフィールドを生成してはならない
- 時計を持つ受信者が`Date`ヘッダフィールドを含まないレスポンスを受信した場合、
  そのレスポンスを受信した時刻を記録し、そのレスポンスをキャッシュまたは下流へ転送する際には
  ヘッダセクションに対応する`Date`ヘッダフィールドを追加しなければならない

#### Trailer
- そのメッセージ内でトレーラフィールドとして送信される予定のフィールド名の一覧

## Routing HTTP Messages https://www.ietf.org/rfc/rfc9110.html#name-routing-http-messages
- リクエストメッセージのルーティングは対象リソース、クライアントのプロキシ設定、
  インバウンド接続の確立または再利用に基づいてクライアントが決定する
- 対応するレスポンスのルーティングは同じ接続経路を逆方向にたどってサーバからクライアントへ返送される

### Determining the Target Resource
- Target Resource (対象リソース) - クライアントが操作したいリソースそのもの
- Target URI (対象URI) - Target Resourceを一意に識別するために使われる絶対URI (URI参照を解決して得られる)
  - クライアントの設定 (URL、プロキシ設定、既定ホストなど) はURI参照とみなすことがでくる
  - URI参照を解決して絶対URIを取得し、フラグメントを除外することで対象URIが確定する
- クライアントは対象リソースに対する操作を行うため、受信者が同一のリソースを特定できる
  解析済みTarget URIの構成要素 (request target) を含むリクエストメッセージを送信する
  - request targetはメソッド定義に従い、メッセージの制御データおよびHostヘッダフィールドとして送信される
  - 例外1) CONNECT - request targetはトンネル先のホスト名とポート番号をコロンで連結した形式となる
  - 例外2) OPTIONS - request targetとしてアスタリスク`*`を使用できる
- サーバは受信した情報から対象URIを再構築する (再構成方法はHTTPのメジャーバージョンごとに異なる)

### Host and :authority
- リクエストにおける`Host`ヘッダフィールドは、対象URIに含まれるホストおよびポート情報を提供し、
  オリジンサーバが複数のホスト名に対するリクエストを処理する際に対象のリソースを識別できるようにする
  - HTTP/2 or 3では場合によってリクエスト制御データに含まれる`:authority`擬似ヘッダフィールドが`Host`の役割を担う
- クライアントはリクエストに`Host`ヘッダフィールドもしくは`:authority`擬似ヘッダーフィールドを必ず含める

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

### Routing Inbound Requests
- クライアントは対象URIおよびそのオリジンの確定後、
  ネットワークリクエストが必要かどうかを判断し、必要である場合にはそのリクエストをどこへ送信するかを決定する

#### To a Cache
- クライアントがキャッシュを持っており、そのキャッシュでリクエストを満たせる場合、
  キャッシュに対してリクエストが向けられる

#### To a Proxy
- キャッシュでリクエストが満たされず、設定に基づいてプロキシが適用可能と判断された場合、
  そのプロキシに対してインバウンド接続を確立 (または再利用) し、
  クライアントのTarget URIに一致するリクエストターゲットを含むHTTPリクエストメッセージを送信する
  - プロキシの設定方法は実装依存
  - 多くの場合はURIプレフィックスの一致、authorityの選択的な一致、あるいはその両方に基づいて判断される
  - プロキシ自体は通常、httpまたはhttpsのURIによって識別される

#### To the Origin
- 適用可能なプロキシが存在しない場合、対象URIのスキームに固有のハンドラ処理を起動し、
  識別されたリソースへのアクセスを試みる
  - 対象がhttpリソースの場合、識別されたオリジンサーバへのインバウンド接続を確立 (または再利用) し、
    対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する
  - 対象がhttpsリソースの場合、識別されたオリジンに対して権威を持つオリジンサーバとのセキュアなインバウンド接続を
    確立 (または再利用) し、その上で対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する

### Rejecting Misdirected Requests
- サーバがリクエストを受信し、対象URIを判定できる程度まで解析すると、サーバはそのリクエストへの対応を決定する
  - 自ら処理する
  - 別のサーバへ転送する
  - クライアントを別のリソースへリダイレクトする
  - エラーで応答する
  - 接続を切断する など
- 接続が信頼されたゲートウェイからのものでないとき、サーバは対象URIに対し、
  スキーム固有の要件が満たされていないリクエストを必ず拒否しなければならない
  - 特にhttpsリソースに対するリクエストは、対象URIのオリジンに対して有効な証明書によって
    セキュア化された接続上で受信されていない限り、拒否しなければならない
- オリジンサーバがそのリクエストを誤配送と判断して拒否する場合、ステータスコード421 Misdirected Request を返す

### Response Correlation
- 1つの接続は複数のリクエスト - レスポンス交換に使用される場合がある
- リクエストとレスポンスの組みを対応付ける仕組みはHTTPのバージョンによって異なる
- すべてのレスポンスは、ステータスコードにかかわらずリクエストの受信後であればいつでも送信できる
  - リクエストがまだ完了していない場合であっても、レスポンスが先に完了することもある
  - クライアントはレスポンスを待つために特定の時間だけ待機することを期待されてはいない
    - クライアントは、合理的な時間内にレスポンスを受信できない場合、そのリクエストを放棄することがある
  - 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に中止を示す指示を受け取らない限り、
    当該リクエストの送信を継続すべき

### Message Forwarding
- 中間者 (intermediary) はHTTP リクエストおよびレスポンスの処理においてさまざまな目的で使用される
  - 性能・可用性向上 (キャッシュ、ロードバランシング)
  - アクセス制御 (認証・認可、フィルタリング、セキュリティゲートウェイ)
- HTTPストリームはpipe-and-filter型の性質を持つため、リクエスト方向・レスポンス方向のどちらに対しても
  中間者が処理を追加・変更・干渉する際の理論的上限はない
- 中間者はプロトコル要素を認識できない場合であっても、メッセージを転送することが期待される
- トンネルとして動作していない中間者は、Connectionヘッダーフィールドを実装しなければならず、
  かつ受信側接続のみに向けられたフィールドを転送から除外しなければならない
- 中間者は、無限のリクエストループから保護されていない限り、自分自身にメッセージを転送してはならない
- 中間者は自身のサーバ名を認識し、自分自身を指す宛先へのリクエストには直接応答すべき
- HTTPメッセージは下流への逐次処理や転送のために、ストリームとして解析することができる
  - 一方送信者や受信者は、部分メッセージが逐次的に配送されることを前提にしてはならない
  - 実装によってはさまざまな理由でメッセージ転送をバッファリングまたは遅延させる場合があるため

#### Connection
- `Connection`ヘッダフィールドは、送信者が現在の接続限りで有効な制御オプションを列挙するためのもの
  - HTTPでは二種類のヘッダがあり、`Connection`ヘッダはこの区別を明示するための仕組み
    - hop-by-hop - 現在の接続の相手だけに意味があり、次の中継先へは送ってはいけない
    - end-to-end - メッセージ全体に意味を持ち、中継を越えて伝える
  - 大文字・小文字を区別しない
  - `Connection`以外のフィールドを用いて現在の接続に関する制御情報を提供する場合、
    `Connection`ヘッダフィールド内に対応するフィールド名を列挙しなければならない
    - HTTPの一部バージョンでは、そのような情報をフィールドで表現すること自体が禁止されている
- トンネルとして動作していない中間者は、メッセージを転送する前に受信した`Connection`ヘッダフィールドを必ず解析し、
  このフィールドに含まれる各オプションと同名のヘッダまたはトレーラフィールドはメッセージから削除し、
  `Connection`ヘッダフィールド自体も削除する
  - または転送されるメッセージに対する中間者自身の制御オプションに置き換える
- 中間者は、仕様としてhop-by-hopであると決まっているフィールドについては、
  それらがオプションとして列挙されているか否かにかかわらず、当該フィールドの意味論を適用した上で削除または置換すべき
  - `Proxy-Connection`, `Keep-Alive`, `TE`, `Transfer-Encoding`, `Upgrade`など
- 送信者は、コンテンツのすべての受信者を対象とするフィールドに対応するオプションを送信してはならない
  - `Cache-Control`など
- オプションは必ずしも実在するフィールドと対応する必要はない
  - `Connection`にないのに接続専用フィールドが来た場合、受信者は無視するべき

#### Max-Forwards
- `Max-Forwards`ヘッダフィールドは、TRACEおよびOPTIONSリクエストメソッドにおいて
  プロキシによる転送回数の上限 (このリクエストメッセージが今後転送され得る残り回数を示す10進整数) を明示するもの
  - `Max-Forwards`ヘッダフィールドを含むTRACE / OPTIONSリクエストを受信した中間者は、
    リクエストを転送する前に、`Max-Forwards`の値を必ず確認・更新する
    - 受信した値が0: 中間者はリクエストを転送せずに最終受信者としてレスポンスを返す
    - 受信した値が0より大きい: `Max-Forwards` = `[受信した値 - 1, 中間者がサポートするMax-Forwardsの最大値].min`
- TRACE / OPTIONS 以外のリクエストメソッドで受信した`Max-Forwards`ヘッダフィールドについては無視してもよい

#### Via
- `Via`ヘッダフィールドは、クライアント - サーバ間に存在する中間プロトコルおよび中間受信者を示すもの
- `Via`フィールド値の各要素は、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中間者は自身がそのメッセージをどのように受信したかの情報を`Via`フィールド値の末尾に追加 するため、
    最終的な`Via`の並び順は、転送経路の順序を表す
- プロキシは転送するすべてのメッセージに対して、`Via`ヘッダフィールドを必ず送信しなければならない
  - HTTP-to-HTTPゲートウェイはすべての受信リクエストに対して必ず`Via`を送信しなければならない。
    転送するレスポンスに対しては送信してもよい。

```
Via: 1.0 fred, 1.1 p.example.net

1. クライアント -> fred (HTTP/1.0)
2. fred -> p.example.net (HTTP/1.1)
3. p.example.net -> オリジンサーバへ
```

### Message Transformations
- HTTP-to-HTTPプロキシのうち、意味的に重要な形でメッセージを変更するよう設計または設定されているものは
  変換プロキシ (transforming proxy) と呼ばれる
  - 共有アノテーションサーバ
  - マルウェアフィルタ
  - フォーマット変換
  - プライバシーフィルタ
- これらの変換はそのプロキシを選択したクライアントによって意図的に望まれているものとみなされる
- プロキシが受信した対象URIのホスト名がFQDNでない場合、プロキシはリクエスト転送時に自身のドメインを付加してもよい
  - 対象URIにFQDNが含まれている場合、プロキシはホスト名を変更してはならない
  - 転送プロトコル上必要とされる場合を除き、対象URIのabsolute-pathおよびquery部分を変更してはならない
- プロキシはレスポンスメッセージのコンテンツに`no-transform`キャッシュディレクティブが含まれている場合、
  そのコンテンツを変換してはならない (コンテンツ自体を変更しない変換を除く)
  - `no-transform`が含まれていないメッセージについては、プロキシはコンテンツを変換してもよい
- プロキシが200 OK レスポンスのコンテンツを変換した場合、下流の受信者に変換が行われたことを示すために、
  レスポンスステータスコードを203 Non-Authoritative Informationに変更して通知することができる。
- プロキシは通信経路のエンドポイント、リソースの状態、または選択された表現に関する情報を提供するヘッダフィールドを
  変更すべきではない
  - そのフィールド定義が明示的に許可している場合、またはプライバシーやセキュリティ上必要と判断される場合を除く

### Upgrade
- `Upgrade`ヘッダフィールドは、同一のコネクション上でHTTP/1.1から別のプロトコルへ移行する簡易的な仕組みを提供する
- クライアントはリクエストの`Upgrade`ヘッダフィールドに プロトコル名のリストを含めて送信することで、
  サーバに対して最終レスポンスを送信する前に、列挙されたプロトコルのいずれかへ切り替えることを提案できる
  - 優先度は高い順、大文字小文字を区別しない
- サーバは現在のプロトコルを継続したい場合、`Upgrade`ヘッダフィールドを無視してもよい
- サーバは提案を受け入れる場合101 Switching Protocolsレスポンスを送信する
  - その際接続を切り替えられる新しいプロトコルを示すために`Upgrade`ヘッダフィールドを必ず送信する
  - 複数のプロトコル層が切り替えられる場合、サーバは下位層から上位層の順でプロトコルを列挙しなければならない
  - クライアントが提示していないプロトコルへ切り替えてはならない
  - クライアントが示した優先順を無視し、リクエストの性質やサーバの負荷など他の要因に基づいてプロトコルを選択できる
- サーバはリクエストに対して現在のプロトコルのままでは処理できず、プロトコルのアップグレードが必要だと判断した場合
  426 Upgrade Requiredレスポンスを送信する
  - その際接続を切り替えられる新しいプロトコルを示すために`Upgrade`ヘッダフィールドを必ず送信する
  - 複数のプロトコル層が切り替えられる場合、サーバは下位層から上位層の順でプロトコルを列挙しなければならない

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

...以降、WebSocket プロトコルに切り替わり、 GET /hello に対する WebSocket 的な応答が続く...
```

- プロトコル変更後のアプリケーションレベルの通信の性質や能力は、選択された新しいプロトコルに依存する
  - サーバは101レスポンスを送信した直後は元のリクエストに対する処理を新しいプロトコル上で継続することが期待される
    - サーバは新しいプロトコルで元のメッセージの意味論を正しく処理できない場合、プロトコルを切り替えてはならない
- `Upgrade`の送信者は、必ず`Connection`ヘッダフィールドに "Upgrade"を指定する
- サーバはHTTP/1.0のリクエストで`Upgrade`場合、その`Upgrade`フィールドを無視しなければならない
- サーバは`Upgrade`と`Expect: 100-continue`の両方を受信した場合、101を送信する前に必ず100 Continueを送信する
- クライアントはリクエスト全体を完全に送信し終えるまで、アップグレード後のプロトコルを使用してはならない
- `Upgrade`ヘッダフィールドは、既存のコネクション上でのプロトコル切り替えにのみ適用される。

## Representation Data and Metadata https://www.ietf.org/rfc/rfc9110.html#name-representation-data-and-met
### Representation Data
- HTTPメッセージに関連付けられる表現データ (representation data) は
  メッセージの本文として含まれるか、メッセージの意味論 + 対象URIによって参照される
- 表現データの形式およびエンコーディングは表現メタデータを示すヘッダフィールドによって定義される
- 表現データのデータ型は`Content-Type`および`Content-Encoding`ヘッダフィールドによって決定される

```
representation-data := Content-Encoding( Content-Type( data ) )

- data                                     ... 元の表現内容 (Content-Typeが直接定義する対象)
- Content-Type( data )                     ... dataをあるメディア型としてシリアライズしたもの (バイト列)
- Content-Encoding( Content-Type( data ) ) ... Content-Type( data ) をエンコーディングしたもの (HTTPメッセージ本文)
```

```
(このメッセージの本文はJSON型として解釈されるバイト列をgzip圧縮したもの)

Content-Type: application/json
Content-Encoding: gzip
```

### Representation Metadata
- 表現ヘッダフィールド (representation header fields) は表現に関するメタデータを提供する
- メッセージに本文が含まれる場合、表現ヘッダーフィールドはそのデータをどのように解釈すべきかを記述する
  - `Content-Type`
  - `Content-Encoding`
  - `Content-Language`
  - `Content-Length`
  - `Content-Location` など

### Content-Type
- `Content-Type`ヘッダフィールドはメッセージの本文の表現、またはメッセージの意味論上選択された表現を表す
- 指定されたメディア型は、データ形式およびそのデータを受信者がどのように処理することを意図しているかの両方を定義する
- メッセージは`Content-Encoding`が示す方式によってデコードされた後、
  受信したメッセージの意味論の範囲内で`Content-Type`が適用される

```
Content-Type = media-type
```

```
Content-Type: text/html; charset=ISO-8859-4
```

- 本文を含むメッセージを生成する送信者は、メッセージに`Content-Type`ヘッダフィールドを生成するべき
  - `Content-Type`ヘッダフィールドが存在しない場合、
    受信者はメディア型を`application/octet-stream`と仮定するかデータを調べてその型を決定してもよい
- MIME sniffing ... ユーザーエージェントが本文から`Content-Type`を推測し、受信した型を上書きすること
  - 誤判断やセキュリティリスクの可能性があるため、実装する場合は利用者が無効化できる手段を提供することが推奨される
- `Content-Type`は単一フィールドとして定義されている
  - 誤って複数回生成されて結合フィールド値になることがあるため、多くの実装は最後の有効な値を使用している

#### Media Type
- media-typeはデータ形式と、そのデータをメッセージの文脈に従ってどのように処理するかを定義する
  - HTTPでは`Content-Type`および`Accept`ヘッダフィールドにおいてmedia-typeを使用する
- media-typeはIANAで管理される

```
media-type = type "/" subtype parameters
type       = token
subtype    = token
```

```
text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
text/html;charset=UTF-8
```

#### Charset
- charsetはテキスト表現の文字エンコーディング方式を定義する
  - HTTPでは`Content-Type`のパラメータ、または`Accept-Encoding`ヘッダフィールドのトークンとしてcharsetを使用する

#### Multipart Types
- multipartは一つのメッセージボディ内に一つ以上の表現をカプセル化するためのmedia-type
  - MIMEには複数のmultipartが定義されている

```
multipart/form-data
multipart/byteranges
multipart/mixed
```

- すべてのmultipartは共通の構文とboundaryパラメータを含む

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123
```

- multipartのボディは単なるバイト列ではなく、MIMEによって定義された厳密なプロトコル構文を持つ構造体

### Content-Encoding
- `Content-Encoding`ヘッダフィールドは`Content-Type`が示すデータに対して適用された圧縮と、そのデコード順序を示す
  - media-typeに含まれるもの以外で、`Content-Type`に対して適用されているコンテンツコーディング
  - `Content-Type`ヘッダフィールドで参照されるmedia-typeのデータを得るために適用する必要があるデコード機構
  - (`Content-Type`は復号後に得られるデータの型を示す)
- 主に、基となるmedia-typeの同一性を失うことなく、表現データを圧縮できるようにするために用いられる

```
Content-Encoding = #content-coding
```

```
Content-Encoding: gzip
```

- media-type自体が常に圧縮されているような内在的なエンコーディングを含む場合、
  そのエンコーディングは、同じアルゴリズムであっても`Content-Encoding`には再度記載されない
- オリジンサーバは同じデータの複数の表現として`Content-Type` / `Content-Encoding`の異なるデータを公開することがある
- オリジンサーバはリクエストメッセージ内の表現が受け入れ不可能なコンテンツコーディングを含んでいる場合、
  415 Unsupported Media Type で応答してもよい

#### Content Codings
- content-codingは表現に対して適用される、または適用可能なエンコーディング変換
  - gzip
  - br
  - deflate など
- 圧縮・変換を可能にする、media-typeの同一性を失わないことを目的に使用される
- `Accept-Encoding`および`Content-Encoding`ヘッダフィールドで使用される

```
content-coding = token
```

- Compress Coding
  - Lempel-Ziv-Welch (LZW) 圧縮方式 (compressよって生成される)
- Deflate Coding
  - deflate圧縮データストリームを含むzlibデータ形式、Lempel-Ziv (LZ77) 圧縮アルゴリズムとハフマン符号化の組み合わせ
- Gzip Coding
  - 32ビットの巡回冗長検査 (CRC) を備えたLZ77圧縮方式 (gzipファイル圧縮プログラムによって生成される)

### Content-Language
- `Content-Language`ヘッダフィールドはその表現が想定している受信者の自然言語を示す
  - 必ずしも表現内で実際に使用されている言語と一致するとは限らない

```
Content-Language = #language-tag
```

```
(同一内容を複数言語で同時提供しているケース)

Content-Language: ja, en
```

- `Content-Language`が指定されていない場合はすべての言語の受信者を対象とする

#### Language Tags
- language-tagは人間同士の情報伝達のために話されたり、書かれたり、その他の形で用いられる自然言語を識別する

```
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

```
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

### Content-Length
- `Content-Length`ヘッダフィールドは関連付けられた表現データの長さを10進の非負整数でオクテット数として示す
- メッセージの本文が送信される場合、`Content-Length`は具体的に同封されているデータ量を指す
  - HTTP/1.1ではフレーミングを区切るためにに使われる
- メッセージの本文が送信されない場合、`Content-Length`は選択された表現の現在の長さを示す
  - 転送時間の見積もりやキャッシュ済み表現との比較などに使われる

```
Content-Length = 1*DIGIT
```

```
Content-Length: 3495
```

- 0以上の値が有効値。事前定義された上限はないため
  - 受信者は非常に大きな10進数値を想定し、整数変換時のオーバーフローや精度喪失による解析エラーを防がなければならない
- 送信者は誤っていると分かっている`Content-Length`を含むメッセージを転送してはならない
- ABNF定義に一致しない`Content-Length`を含むメッセージを転送してはならない
  - 例外として、同一の10進値がカンマ区切りで繰り返された`Content-Length`を受信した場合、
    受信者はそれを無効として拒否してもよいし、重複生成や結合の結果であると考えて、単一の値に置き換えてもよい

#### ユーザーエージェントにとっての`Content-Length`
- リクエストメソッドが本文に意味を与えており、かつ`Transfer-Encoding`を送信していない場合、
  `Content-Length`を送信するべき
  - e.g. 本文が空の`POST`でも通常は`Content-Length`を送信する
  - メッセージに本文が含まれない場合は`Content-Length`を送信するべきではない

#### サーバにとっての`Content-Length`
- `HEAD`に対するレスポンスに`Content-Length`を送信してもよい
  - 値は同じリクエストを`GET`で行った場合に送信されるはずの本文のオクテット数と等しくする必要がある
- 条件付き`GET`に対する304 Not Modified レスポンスで`Content-Length`を送信してもよい
  - 値は同じリクエストに対する200 OK レスポンスで送信されるはずの本文のオクテット数と等しくする必要がある
- 1xx または204 No Content レスポンスでは`Content-Length`を送信してはならない
- `CONNECT`に対する2xx レスポンスでは`Content-Length`を送信してはならない
- 上記を除き、`Transfer-Encoding`が存在せず本文サイズがヘッダ送信前に判明している場合`Content-Length`を送信するべき
  - これにより、下流の受信者は転送進捗を把握でき、メッセージの完全性を判断でき、後続リクエストのために接続を
    再利用できる可能性がある

### Content-Location
- `Content-Location`ヘッダフィールドはメッセージの本文に含まれる表現に対応するリソースを識別するためのURIを示す
  - 当該メッセージが生成された時点でそのURIに対して`GET`すると、当該メッセージの本文と同一の表現が200 OK になる
  - リソースの識別子ではなく、メッセージに含まれる表現の識別子
    - `Content-Location`は対象URI (どのリソースに対する操作か) の代替ではない

```
Content-Location = absolute-URI / partial-URI
```

- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` == 対象URIの場合:
  - メッセージ生成日時点における当該リソースの現在の表現を示す
  - `GET`や`HEAD`の場合は`Content-Location`が省略された場合のデフォルトの意味と同じ
  - `POST` / `PUT`の場合は操作後の新しいリソースの表現を示す
- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` != 対象URIの場合:
  - `GET` / `HEAD` - コンテントネゴシエーションによって選ばれた表現の識別子
  - それ以外 - 処理の結果の表現を示す
- リクエストメッセージに含まれる`Content-Location`値は、元表現へのバックリンクを提供している
  - 当該表現の元データを (ユーザーエージェントによる変更前に) 取得した元の場所
- サーバは`Content-Location`を受信したとき、その情報を表現の一部として保存されるメタデータではなく、
  一時的なリクエスト本文として扱わなければならない
  - サーバはそのコンテキストをリクエスト処理の補助や、ソースリンクやバージョン管理メタデータなどの用途に利用できる
  - 要求の意味論を変更するために用いてはならない

### Validator Fields
- バリデータフィールドは事前条件 (precondition) で使用できるvalidatorを定義する
  - `Last-Modified`、`ETag`ヘッダフィールドなど
  - 条件付きリクエスト、同時更新の衝突防止、キャッシュ検証 などに使用される
- `GET` / `HEAD` などのリクエストに対するレスポンスでは、サーバが処理の際に選択した表現を記述する
- 状態変更を伴うリクエストに対して成功を示すレスポンスでは、サーバの処理結果として新たに有効となった表現を記述する

#### Weak versus Strong
- 強い (strong) バリデータと弱い (weak) バリデータがある
  - 強いバリデータ:
    - `GET`に対する200 OK レスポンスのコンテンツにおいて、
      観測可能な表現データの変更が起きるたびに値が変化する表現メタデータ
      - 同一リソースの全履歴に対して一意
      - 表現の実データ (本文や意味的に重要なmetadata) が変化するとバリデータも変わる
    - 比較に理想的だが、効率よく生成するのが非常に難しい
    - キャッシュ検証、範囲 / 部分コンテンツリクエスト、更新の取りこぼし防止などすべての条件付き要求で使用できる
  - 弱いバリデータ:
    - 表現データの変更があっても必ずしも値が変わらない表現メタデータ
      - 計算精度の制限がある場合、完全な一意性を保証できない場合、表現を等価なグループとして扱いたい場合
    - 生成が容易だが、比較用途では有用性が低い
    - 過去に取得した表現データとの完全一致を必要としない場合にのみ使用できる
      - サーバがバリデータを変更したいタイミングで変更される

| 使用場面              | Strong | Weak |
| - | - | - |
| キャッシュ検証        | ○      | ○    |
| If-None-Match         | ○      | ○    |
| If-Match              | ○      | ×    |
| 範囲 / 部分コンテント | ○      | ×    |
| 更新の取りこぼし防止  | ○      | ×    |
| 最近更新されたか      | ○      | ○    |

#### Last-Modified
- レスポンスにおける`Last-Modified`ヘッダフィールドは、
  そのリクエストの処理完了時点で選択された表現が最後に変更されたと考える日時を示すタイムスタンプを提供する

```
Last-Modified = HTTP-date
```

```
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

- オリジンサーバは、最終更新日時が合理的かつ一貫して決定できる表現については`Last-Modified`を送信するべき
  - `Last-Modified`は条件付きリクエストやキャッシュの新鮮度評価において利用され、不要な転送を大幅に削減し、
    サービスの可用性とスケーラビリティを大きく向上させる
  - 表現は通常、リソースインターフェースの背後にある複数の要素の集合体であり、
    最終更新時刻はそれらの要素のいずれかが最後に変更された最も新しい時刻となる
  - オリジンサーバはレスポンスの`Date`フィールド値を生成する時刻にできるだけ近い時点で
    表現の`Last-Modified`値を取得することが望ましい
  - 時計を持つオリジンサーバは、メッセージ生成時刻より後の日時を`Last-Modified`として生成してはならない
  - 時計を持たないオリジンサーバは、他のシステムによってリソースに割り当てられた日時でない限り、
    `Last-Modified`を生成してはならない
- `Last-Modified`の時刻をリクエストのバリデータとして使用する場合、暗黙的に弱いバリデータとして扱われる
  - 以下のいずれかの条件を満たし、強いと推論できない場合に限る:
    - バリデータがオリジンサーバによって表現の実際の現在のバリデータと比較されており、
      かつそのオリジンサーバが提示されたバリデータで表される1秒の間に、
      対応する表現が2回以上変更されていないことを確実に把握している場合
    - クライアントがバリデータを`If-Modified-Since`、`If-Unmodified-Since`、`If-Range`ヘッダフィールドいずれかで
      使用しようとしており、当該クライアントが対応する表現のキャッシュエントリを保持しており、
      そのキャッシュエントリに含まれる`Date`の値が`Last-Modified`の値より少なくとも1秒以上後であり、
      それらが同一の時計によって生成された、または時計の同期問題が起こりにくいほど十分な差があると
      クライアントが判断できる場合
    - バリデータが中間キャッシュによって、そのキャッシュエントリに保存されている表現のバリデータと比較されており、
      そのキャッシュエントリに含まれる Date の値が Last-Modified の値より少なくとも1秒以上後であり、
      それらが同一の時計によって生成された、または時計同期の問題が起こりにくいとキャッシュが判断できる場合

#### ETag
- レスポンスにおける`ETag`フィールドは、リクエスト処理の完了時点で決定された選択表現の
  現在のエンティティタグ (ETag) を提供する
  - ETagは不透明なバリデータであり、同一リソースに対する複数の表現を区別するために用いられる
    - 時間経過によるリソース状態の変化やコンテントネゴシエーションによって同時に複数の表現が存在する場合を含む
  - ETagは不透明な引用文字列からなり、任意で弱いことを示す接頭辞を持つ

```
ETag       = entity-tag

entity-tag = [ weak ] opaque-tag
weak       = %s"W/"
opaque-tag = DQUOTE *etagc DQUOTE
etagc      = %x21 / %x23-7E / obs-text
           ; ダブルクオートを除く VCHAR と obs-text
```

- ETagは、状況によって更新日時よりも信頼性の高いバリデータとなり得る
  - 更新日時の保存が困難な場合
  - HTTP-dateの1秒単位の分解能では不十分な場合
  - 更新日時が一貫して管理されていない場合

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

- ETagはデフォルトは強いバリデータ
  - オリジンサーバが表現に対してETagを提供する際、その生成方法が強いバリデータの特性をすべて満たさない場合、
    サーバはそのETagを弱いバリデータとして`"W/"`を付ける必要がある
  - 送信者は`ETag`フィールドをトレーラセクションで送信してもよい
    - ただし、トレーラーは無視されることが多い

```
ETagの基本原則:
「リソースの実装を最もよく理解しているのはサービスの作成者だけであり、
  そのリソースに対して最も正確かつ効率的な検証方法を選択できるのもその作成者である」
```

- オリジンサーバは変更の検出を合理的かつ一貫して判断できる選択表現に対し、`ETag`を送信することが推奨される
  - `ETag`は条件付きリクエストやキャッシュ鮮度評価において利用され、不要な転送を大幅に削減し、
    サービスの可用性・拡張性・信頼性を著しく向上させる
- ETagには強い比較と弱い比較がある
  - 強い比較 (Strong comparison):
    - 2つのETagがいずれも弱いタグではなく、かつ`opaque-tag`が文字単位で完全に一致する場合に等価とされる
  - 弱い比較 (Weak comparison):
    - 2つのETagエンティティタグが弱いタグかどうかに関係なく、`opaque-tag`が文字単位で完全に一致すれば等価とされる

| ETag 1  | ETag 2  | Strong Comparison | Weak Comparison |
| - | - | - | - |
| `W/"1"` | `W/"1"` | no match          | match           |
| `W/"1"` | `W/"2"` | no match          | no match        |
| `W/"1"` | `"1"`   | no match          | match           |
| `"1"`   | `"1"`   | match             | match           |

## Methods https://www.ietf.org/rfc/rfc9110.html#name-methods
- リクエストメソッドは、クライアントがリクエストを行った目的および成功した結果としての期待値を示す
- リクエスト内に特定のヘッダフィールドが存在し、かつそれらの追加的な意味論がメソッドと矛盾しない場合、
  リクエストメソッドの意味論はそれらのヘッダーフィールドによってさらに特化されることがある。

```
method = token
```

- メソッドトークンは大文字・小文字を区別する
  - 慣例として、標準化されたメソッドはすべて大文字のUS-ASCII文字で定義されている
- 一度定義された標準メソッドは、どのリソースに適用された場合でも同一の意味論を持つべき
  - それらの意味論が実装されているか、あるいは許可されているかどうかは、各リソース自身が決定する

| RFC 9110で定義されたメソッド | 意味                                                       |
| -                            | -                                                          |
| `GET`                        | 対象のリソースの現在の表現を取得する                       |
| `HEAD`                       | `GET`と同じ。レスポンスの本文は取得しない                  |
| `POST`                       | リクエスト本文を用いてリソース固有の処理を実行する         |
| `PUT`                        | 対象リソースの現在の表現をリクエスト本文で置き換える       |
| `DELETE`                     | 対象リソースの現在の表現を削除する                         |
| `CONNECT`                    | 対象リソースで識別されるサーバへのトンネルを確立する       |
| `OPTIONS`                    | 対象リソースに対する通信オプションを取得する               |
| `TRACE`                      | 対象リソースまでの経路に沿ってループバックテストを実行する |

- すべての汎用サーバは`GET`および`HEAD`メソッドを必ずサポートしなければならない。それ以外のメソッドは任意。
- 対象リソースで許可されているメソッドの集合は`Allow`ヘッダーフィールドに列挙可能
  - ただし許可されるメソッドの集合は動的に変化する可能性がある
- オリジンサーバは:
  - 認識できない / 実装されていないリクエストメソッドを受信した場合、
    501 Not Implemented ステータスコードを返すことが推奨される
  - 認識および実装されてはいるが、対象リソースに対しては許可されていないリクエストメソッドを受信した場合、
    405 Method Not Allowed ステータスコードを返すことが推奨される

### Common Method Properties
#### Safe Methods
- 意味論的に読み取り専用として定義されているメソッドは安全 (safe) なメソッド
  - `GET`、`HEAD`、`OPTIONS`、`TRACE`
- クライアントは安全なメソッドを対象リソースに適用した結果として、
  オリジンサーバ上で何らかの状態変化が起こることを要求せず、期待しない
  - ただしクライアントが要求した意味論において安全であることが重要であり、実装上の副作用は問題にされない
- 安全なメソッドと安全でないメソッドを区別する目的:
  - 自動取得プロセスやキャッシュ性能最適化が、害を引き起こすことを恐れずに動作できるようにする
  - ユーザーエージェントが信頼できない可能性のあるコンテンツを処理する際、
    安全でないメソッドの自動利用に対して適切な制約を適用できるようにする
- ユーザーエージェントは、ユーザーに対して実行可能な操作を提示する際:
  - 安全なメソッドと安全でないメソッドを区別すべき
  - リクエストが送信される前に安全でない操作であることをユーザーが認識できるようにするべきである。
- 対象URI内のパラメータが何らかの操作を選択する効果を持つようにリソースが構成されている場合、
  リソースの所有者はその操作がリクエストメソッドの意味論と整合していることを保証する

#### Idempotent Methods
- 同一のリクエストを複数回実行しても、サーバに対する効果が毎回同じになるメソッドは冪等 (idempotent) なメソッド
  - `GET`、`HEAD`、`OPTIONS`、`TRACE`、`PUT`、`DELETE`
- ただしクライアントが要求した意味論において冪等であることが重要であり、実装上の副作用は問題にされない
- 冪等なメソッドと冪等でないメソッドを区別する目的:
  - クライアントがサーバからのレスポンスの受信に失敗した場合に、そのリクエストを自動的に再送できるようにする
  - クライアントはメソッドが冪等でない場合、原則として自動再試行を行うべきではない
    - そのリクエストの意味論が、メソッドにかかわらず実際には冪等であることを知る手段がある場合、
      あるいは元のリクエストが適用されなかったことを検出できる手段がある場合はこの限りではない
      - e.g. ユーザーエージェントは、そのリクエストが当該リソースに対して安全であることを把握している場合、
        `POST`リクエストを自動的に再送できる
    - プロキシは冪等でないリクエストを自動的に再試行してはならない
    - クライアントは、自動再試行に失敗したリクエストをさらに自動で再試行するべきではない

#### Methods and Caching
- HTTPにおいてレスポンスをキャッシュ可能にするかどうかは、メソッドごとに定義されたキャッシュ許可と条件に依存する
- メソッド定義がキャッシュ可能性を明示していない場合、そのメソッドのレスポンスはキャッシュできない
  - `GET`、`HEAD`、`POST`についてはキャッシュの意味論が定義されている
  - 実装上は`GET`、`HEAD`のみを扱うキャッシュがほとんど

### Method Definitions
#### GET
- `GET`メソッドは対象リソースの現在の表現の転送を要求する
  - 成功レスポンスは、対象URIが識別する同一性 (sameness) の品質を反映する
  - HTTPを介して識別可能な情報を取得することは通常、識別子 (URI) に対する`GET`として行われ、成功すれば200 OK が返る
- `GET`は情報取得のための主要な仕組みであり、ほぼすべての性能最適化の中心となっている
- URIは必ずしもリモートシステムのファイルパス名と一致せず、表現は必ずしもそのようなファイル内容のコピーではない
  - URIと実装の対応関係はオリジンサーバのみが知っている
- クライアントは`GET`リクエスト内で`Range`ヘッダフィールドを送信することにより、
  `GET`の意味論を範囲リクエストに変更し、選択された表現の一部のみの転送を要求できる
- `GET`リクエストで送信される内容 (ボディ) には一般に定義された意味論はなく、
  リクエストの意味や対象を変更することもできない
  - 潜在的なリクエスト・スマグリング攻撃の危険性から、実装によってはリクエストを拒否し、接続を閉じることがある
- クライアントは`GET`リクエストに内容を生成するべきではない
  - そのリクエストボディに帯域内外で利用目的があり、サポートされているオリジンサーバに対して直接送信する場合を除く
- オリジンサーバは、私的な合意に依存してリクエストボディを受け取ることを前提にすべきではない
  - 通信の当事者はリクエスト経路上の中間者の存在を把握していないことが多いため
- `GET`リクエストに対するレスポンスはキャッシュ可能であり
  - キャッシュはそれを後続の`GET` / ` HEAD`リクエストを満たすために使用してよい
  - `Cache-Control`ヘッダフィールドによって別途指示がある場合はそれに従う
- ユーザ提供の情報から対象URIを構築する仕組みによって情報取得を行う (フォームから`GET`するなど) 場合、
  クエリにURI内での開示が不適切な、機微なデータが含まれる危険がある
  - レスポンスをキャッシュする利点がない場合には`GET`の代わりに`POST`を使用し、
    対象URIではなくリクエスト内容として情報を送信する方が適切なこともある

#### HEAD
- `HEAD`メソッドはサーバがレスポンスに内容 (ボディ) を送信してはならない点以外は`GET`と同じ
  - `HEAD`は、表現データそのものを転送することなく、選択された表現に関するメタデータを取得するために使用される
  - ハイパーテキストリンクのテストや、最近の更新の有無を確認する目的で用いられることが多い
- サーバは`HEAD`リクエストに対し、原則として`GET`での場合と同じヘッダを返すべき
  - 内容を生成する過程でのみ値が確定するヘッダフィールドについては、省略してもよい
    - レスポンスの生成過程で確定する`Content-Length`や`Vary`など

#### POST
- `POST`メソッドはリクエストに含まれる表現を、対象リソース固有の意味論に従って処理することを要求する
  - HTMLフォームに入力されたフィールドなど、データのまとまりをデータ処理プロセスに提供する
  - 掲示板、ニュースグループ、メーリングリスト、ブログ、あるいはそれに類する記事群にメッセージを投稿する
  - オリジンサーバによってまだ識別されていない新しいリソースを作成する
  - 既存のリソース表現にデータを追加する など
- オリジンサーバは`POST`リクエストの処理結果に応じ、適切なステータスコードを選択することでレスポンスの意味論を示す
- `POST`リクエストの処理が成功した結果としてオリジンサーバ上に1つ以上のリソースが作成された場合、
  オリジンサーバは、作成された主要リソースの識別子を示す`Location`ヘッダフィールドを含む201 Created レスポンスを
  送信することが推奨される
  - そのレスポンスには新しいリソースを参照しつつ、リクエストの状態を説明する表現を含める
- `POST`リクエストに対するレスポンスは、明示的な新鮮度情報 (freshness information) と、
  `POST`の対象URIと同じ値を持つ`Content-Location`ヘッダフィールドを含む場合にのみ、キャッシュ可能
    キャッシュされた`POST`レスポンスは後続の`GET` / `HEAD` リクエストを満たすために再利用できる
  - `POST`リクエスト自体を、キャッシュされた`POST`レスポンスで満たすことはできない
- `POST`の処理結果が既存リソースの表現と等価になる場合、オリジンサーバは303 See Other レスポンスを送信し、
  `Location`フィールドに既存リソースの識別子を指定することで、
  ユーザーエージェントをそのリソースへリダイレクトしてもよい

#### PUT
- `PUT`メソッドはリクエストメッセージの内容に含まれる表現によって定義されたによって
  対象リソースの状態を作成または置換することを要求する
- 対象リソースに現在の表現が存在せず、`PUT`によって新たに作成された場合、
  オリジンサーバは201 Created レスポンスを送信してユーザーエージェントに通知しなければならない
- 対象リソースに現在の表現が存在し、その表現がリクエストに含まれる表現の状態に従って正常に更新された場合、
  オリジンサーバは200 OK または204 No Content のいずれかを送信して、リクエストの成功を示さなければならない
- オリジンサーバは`PUT`で送信された表現と、対象リソースに設定された制約が整合していることを検証することが推奨される
  - `PUT`表現が対象リソースと不整合である場合は、表現を変換するまたはリソース設定を変更することで整合させるか、
    その表現が不適切である理由を十分に説明する情報を含む適切なエラーメッセージを返すことが推奨される
    - 推奨されるステータスコードは409 Conflict または415 Unsupported Media Type (`Content-Type`不整合の場合)
- HTTPはユーザーエージェントの要求意図およびオリジンサーバのレスポンス意味論によって表現できる範囲を超えて、
  `PUT`メソッドがオリジンサーバの状態にどのような影響を与えるかを厳密には定義していない
  - HTTPはリソースを"HTTPを通じて提供されるインターフェース"とのみ定義し、
    リソース状態がどのように保存されるか、状態変更により保存方法がどのように変化するか、
    オリジンサーバがどのようにしてリソース状態を表現へ変換するかを定義していない
  - ヘッダおよびトレーラの扱いは、そのリクエストを受信したリソースに固有であるため、
    オリジンサーバは`PUT`リクエストで受信した認識できないヘッダやトレーラフィールドを無視するべきであり、
    それらをリソース状態の一部として保存すべきではない
- オリジンサーバは`PUT`が成功したレスポンスにおいて、バリデータフィールド (`ETag`や`Last-Modified`など) を
  送信してはならない
  - `PUT`リクエストの内容とリソースの新しい表現が一致、かつバリデータ値が新しい表現を正しく反映している場合を除く
    - レスポンスで受信した新しいバリデータ値は、将来の条件付きリクエストにおいて
      意図しない上書きを防ぐために利用できる
- `POST`と`PUT`の根本的な違い: リクエストに含まれる表現に対する意図
  - `POST`リクエストにおける表現は、対象リソースの意味論に従って処理することが意図されている
  - `PUT`リクエストに含まれる表現は、対象リソースの状態を置換するものとして定義されている
  - `PUT`の意図は冪等であり、中継者からも可視 (ただしその正確な効果はオリジンサーバのみが知っている)
  - 状態変更リクエストの受信後、クライアントに代わって適切なURIを選択するサービスは、
    `PUT`ではなく`POST`を用いて実装されるべき
- オリジンサーバは、要求された`PUT`による状態変更を対象リソースではなく別のリソースに適用したい場合、
  適切な3xxレスポンスを送信しなければならない
  - ユーザーエージェントはリダイレクトするかどうかを自ら判断する
- 対象リソースに対する`PUT`リクエストが他のリソースに副作用を及ぼすことがある
- 一部のオリジンサーバは、リクエスト修飾子として`Content-Range`ヘッダフィールドをサポートし、部分`PUT`を実行できる
- `PUT`メソッドに対するレスポンスはキャッシュ不可
  - 成功した`PUT`リクエストが、対象URIに対して1 つ以上のレスポンスを保存しているキャッシュを通過した場合、
    それらの保存済みレスポンスは無効化される

#### DELETE
- `DELETE`メソッドはオリジンサーバに対して、対象リソースとその現在の機能との関連付けを解除することを要求する
  - 情報そのものが削除されることを期待するのではなく、オリジンサーバ上のURIマッピングに対する削除操作を表現する
- 対象リソースに1つ以上の表現が存在する場合、それらがオリジンサーバによって破棄されるかどうか、
  あるいは関連するストレージが回収されるかどうかは、リソースの性質およびオリジンサーバによる実装に依存する
  - 一般にオリジンサーバは削除を実行する所定の仕組みを持つリソースに対してのみ、`DELETE`を許可するものと想定される
- `DELETE`メソッドが正常に適用された場合、オリジンサーバは次のいずれかを送信することが推奨される:
  - 操作は成功する見込みだが、まだ実行されていない場合: 202 Accepted
  - 操作が実行され、追加情報を提供しない場合: 204 No Content
  - 操作が実行され、レスポンスメッセージに状態を説明する表現が含まれる場合: 200 OK
- `DELETE`リクエストで送信される内容 (ボディ) には一般に定義された意味論はなく、
  リクエストの意味や対象を変更することもできない
  - 潜在的なリクエスト・スマグリング攻撃の危険性から、実装によってはリクエストを拒否し、接続を閉じることがある
- クライアントは`DELETE`リクエストに内容を生成するべきではない
  - そのリクエストボディに帯域内外で利用目的があり、サポートされているオリジンサーバに対して直接送信する場合を除く
- オリジンサーバは、私的な合意に依存してリクエストボディを受け取ることを前提にすべきではない
  - 通信の当事者はリクエスト経路上の中間者の存在を把握していないことが多いため
- `DELETE`メソッドに対するレスポンスはキャッシュ不可
  - 成功した`DELETE`リクエストが、対象URIに対して1 つ以上のレスポンスを保存しているキャッシュを通過した場合、
    それらの保存済みレスポンスは無効化される

#### CONNECT
- `CONNECT`メソッドは受信者に対し、リクエストターゲットで識別される宛先オリジンサーバへのトンネルを確立することを
  要求する
  - 成功した場合は以降、トンネルが閉じられるまで双方向のデータを盲目的に転送することのみに動作を制限する
  - トンネルは1つ以上のプロキシを介してend-to-endの仮想接続を作成するために一般的に用いられる
  - トンネルの接続はTLSによって保護され得る
- `CONNECT`は専用の形式のリクエストターゲットを使用する
  - `トンネルの宛先となるホスト名:ポート番号`
  - デフォルトのポート番号は存在せず、クライアントは必ずポート番号を送信しなければならない

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com
```

- サーバは空または無効なポート番号をターゲットとする`CONNECT`リクエストを拒否しなければならない
  - 通常は400 Bad Request ステータスコードで応答する
- `CONNECT`はHTTP 接続のリクエスト／レスポンスの性質を変更するため、HTTPのバージョンごとに
  意味論をプロトコルのワイヤ形式へどのようにマッピングするかが異なる場合がある
- `CONNECT`はプロキシへのリクエストとして使用されることを意図する
  - 受信者は、リクエストターゲットで識別されたサーバへ直接接続することでトンネルを確立することができる
  - 受信者は、別のプロキシを使用するよう設定されている場合、`CONNECT`を次の上流プロキシへ転送することもできる
  - オリジンサーバが`CONNECT`を受け付けることもあるが、ほとんどのオリジンサーバは`CONNECT`を実装していない
- `CONNECT`に対する2xxレスポンスは、送信者およびすべての上流プロキシが、
  レスポンスヘッダ部の直後から即座にトンネルモードへ切り替えることを示す
  - 以降に受信されるデータは、リクエストターゲットで識別されたサーバからのもの
  - 成功以外のレスポンスは、トンネルがまだ形成されていないことを示す
- トンネルは、いずれか一方が接続を閉じたことを中継者が検出した時点で閉じられる
  - 中継者は、閉じられた側から届いていた未送信データを可能な限り反対側へ送信し、
    両方の接続を閉じ、残っている未配送データを破棄しなければならない
- プロキシ認証は、トンネル作成の権限を確立するために使用されることがある

```
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

- 任意のサーバへのトンネルを確立することには重大なリスクがある
  - `CONNECT`をサポートするプロキシは既知のポート集合、または安全なリクエストターゲットの設定可能なリストに
    使用を制限することが推奨される
- サーバは`CONNECT`に対する2xxレスポンスにおいて`Transfer-Encoding`または`Content-Length`を送信してはならない
  - クライアントは受信した`Transfer-Encoding`や`Content-Length`をを無視しなければならない
- `CONNECT`リクエストメッセージには内容 (ボディ) は存在しない
- `CONNECT`リクエストのヘッダ部以降に送信されるデータの解釈は、使用されているHTTPのバージョンに依存する
- `CONNECT`メソッドに対するレスポンスはキャッシュ不可

#### OPTIONS
- `OPTIONS`メソッドはオリジンサーバまたは中継者において、対象リソースに対して利用可能な通信オプション情報を要求する
  - リソースの操作なしにリソースに関連付けられたオプションや要件、サーバの能力を確認するためのもの
- リクエスト対象が`*`の場合、サーバ全体に対する問い合わせとなり、主に疎通確認や能力検査に用いられる。
- リクエスト対象が`*`でない場合、対象リソースに対する問い合わせとなる
- `OPTIONS`に対して2xx レスポンスを生成するサーバは、対象リソースに適用され、かつサーバが実装している
  任意機能を示す可能性のあるすべてのヘッダ (`Allow`など) を送信することが推奨される
- サーバは、`OPTIONS`に対するレスポンスボディを、通信オプションを機械可読または人間可読な形式で記述してもよい
- クライアントは、`OPTIONS`リクエストにおいて、リクエストチェーン内の特定の受信者を対象とするために
  `Max-Forwards`ヘッダーフィールドを送信してもよい
  - プロキシは、受信したリクエストに`Max-Forwards`が含まれていない限り、リクエスト転送時にこれを生成してはならない
- クライアントがボディを含む`OPTIONS`リクエストを生成する際、
  その表現のメディアタイプを記述した有効な`Content-Type `ヘッダーフィールドを送信しなければならない
- `OPTIONS`メソッドに対するレスポンスはキャッシュ不可

#### TRACE
- `TRACE`メソッドはリクエストメッセージを対象として、リモート側でのアプリケーションレベルのループバックを要求する
- リクエストの最終受信者は受信したメッセージをそのまま200 OK レスポンスとして返すことが推奨される
  - 表現方法は`message/http`形式など
  - 最終受信者 = オリジンサーバ、もしくはリクエスト内の`Max-Forwards`値が0になった時点で最初に受信したサーバ
  - クライアントは`TRACE`リクエストにおいて、レスポンスによって漏えいする可能性のある機微なデータを含むフィールドを
    生成してはならない
    - e.g. ユーザー認証情報、Cookieなど
  - 最終受信者はレスポンスを生成する際、機微なデータを含む可能性の高いリクエストフィールドを除外することが推奨される
- `TRACE`はリクエストチェーンの末端で実際に何が受信されているのかをクライアントが確認できるようにし、
  その情報をテストや診断目的で利用できるようにする
  - リクエストチェーンの経路を示す痕跡としては`Via`ヘッダフィールドが重要
  - `Max-Forwards`ヘッダフィールドを使用する
  - リクエストチェーンの長さを制限し、プロキシがメッセージを無限ループで転送していないか確認する際には
    `Max-Forwards`ヘッダフィールドが有用
- クライアントは`TRACE`リクエストにボディを送信してはならない
- `TRACE`メソッドに対するレスポンスはキャッシュ不可

## Message Context https://www.ietf.org/rfc/rfc9110.html#name-message-context
### Request Context Fields
リクエストの文脈に関する追加情報を提供するヘッダフィールド群
(ユーザー、ユーザーエージェント、ならびにリクエストの背後にあるリソースに関する情報など)

#### Expect
- `Expect`リクエストヘッダフィールドは、そのリクエストを正しく処理するためにサーバに期待する振る舞いを示す

```
Expect =      #expectation
expectation = token [ "=" ( token / quoted-string ) parameters ]
```

- `Expect`フィールド値は大文字・小文字を区別しない
- 仕様によって定義されている唯一の期待事項は`"100-continue"`
  - サーバは`Expect`フィールドに100-continue以外の値が含まれているリクエストを受信した場合、
    その期待に応えられないことを示すために、417 Expectation Failed ステータスコードで応答してもよい

- 100-continueの期待値
  - クライアントがこのリクエストにおいてサイズの大きなボディを送信しようとしており、
    メソッド・対象URI・ヘッダフィールドだけでは即座に成功、リダイレクト、またはエラーと判断できない場合に、
    中間レスポンスを受け取りたいという意思を受信者に伝える
    - クライアントは実際に内容を送信する価値があるかどうかの合図を待ってから送信できるため、
      データ量が非常に大きい場合や、エラーが起こりそうな場合の効率を向上させることができる
  - クライアントに対する要件:
    - ボディを含まないリクエストに100-continueの期待を生成してはならない
    - リクエストボディを送信する前に100 Continue レスポンスを待つつもりのクライアントは、
      `"100-continue"`を含む`Expect`ヘッダフィールドを送信しなければならない
    - 100-continueを送信したクライアントは、特定の時間を待つ義務はない
      - レスポンス未受信の状態でもボディの送信を開始してよい
      - 100 Continue レスポンスはHTTP/1.0の中継者を通過できないため、
        クライアントは無期限に待つべきではない
    - 100-continueを含むリクエストに対して417 Expectation Failed を受信したクライアントは、
      その`Expect`を除いた同じリクエストを再送することが推奨される
      - 417 Expectation Failed はレスポンスチェーンが`Expect`をサポートしていない場合に返される
  - サーバに対する要件:
    - HTTP/1.0リクエストで100-continueを受信したサーバは、その期待を無視しなければならない
    - サーバがすでにリクエストボディの一部または全部を受信している場合、
      あるいはフレーミングからボディが存在しないと分かる場合には、100 Continue レスポンスの送信を省略してもよい
    - 100 Continue レスポンスを送信したサーバは接続が途中で閉じられない限り、
      最終的なステータスコードを必ず送信しなければならない
    - リクエストボディをすべて読む前に最終ステータスコードを返すサーバは、接続を閉じる意図があるかどうかを示すべき
    - HTTP/1.1以降のリクエストで、100-continue の期待とボディ送信の指示を含む完全なヘッダ部を受信した
      オリジンサーバは、次のいずれかを必ず行わなければならない
      - メソッド、対象URI、ヘッダのみを見て判断できる場合は即座に最終ステータスコードで応答する
      - それ以外の場合は即座に100 Continue レスポンスを送信する
      - オリジンサーバは100 Continue を送る前にボディを待ってはならない
  - プロキシに対する要件:
    - HTTP/1.1以降の100-continue付きリクエストを受信したプロキシは、次のいずれかを行わなければならない:
      - メソッド、対象URI、ヘッダのみを見て判断できる場合は即座に最終ステータスコードで応答する
      - 対応するリクエスト行とヘッダ部を次の上流サーバへ転送する
    - 次の上流サーバがHTTP/1.0のみをサポートしていると判断した場合、
      プロキシはクライアントに対してボディの送信を促すために、即座に100 Continue レスポンスを生成してもよい

#### From
- `From`リクエストヘッダフィールドは、リクエストを送信するユーザーエージェントを制御している人間のユーザーの
  インターネット電子メールアドレスを含む

```
From    = mailbox
mailbox = <mailbox, see [RFC5322], Section 3.4>
```

```
From: spider-admin@example.org
```

- `From`ヘッダフィールドは、ロボット型のユーザーエージェントによって送信されることが多い
- ユーザーエージェントはユーザーによる明示的な設定なしに`From`ヘッダフィールドを送信するべきではない
  - ユーザーのプライバシー上の利益や、サイトのセキュリティポリシーと衝突する可能性があるため
- ロボット型のユーザーエージェントは、ロボットの挙動によりサーバ上で問題が発生した場合に、
  そのロボットの運用責任者へ連絡できるよう有効な`From`ヘッダーフィールドを送信することが推奨される
- サーバは`From`ヘッダフィールドをアクセス制御や認証の目的で使用するべきではない
  - `Fron`値はリクエストを受信または観測する誰からも見えることが想定されている
  - プライバシーが期待されない形でログファイルやエラーレポートに記録されることが多い

#### Referer
- `Referer`リクエストヘッダフィールドは、対象URI がどのリソースから取得されたかを示すURI参照を指定する
- ユーザーエージェントは`Referer`フィールド値に、URI参照に含まれる`fragment`および`userinfo`を含めてはならない

```
Referer = absolute-URI / partial-URI
```

- `Referer`フィールド値は`absolute-URI`か`partial-URI`のいずれか
  - `partial-URI`の場合、参照されるURIは対象URIに対する相対URIとして解釈される
- `Referer`ヘッダフィールドによりサーバは簡易的な分析、ログ記録、キャッシュ最適化などの目的で、
  他のリソースへのバックリンクを生成したり、古くなったリンクやタイプミスされたリンクを保守のために発見できる

```
Referer: http://www.example.org/hypertext/Overview.html
```

- 参照元のURIを持たないソースから対象URIを得た場合 (e.g. ユーザーのキーボード入力や、ブックマークエントリ)
  ユーザーエージェントは`Referer`ヘッダフィールドを省略するか、値として`"about:blank"`を送信しなければならない
- `Referer`ヘッダフィールド値は、参照元リソースの完全なURIを含む必要はない
  - ユーザーエージェントは、参照元のオリジン以外の部分を切り詰めてもよい
- `Referer`ヘッダフィールドは、リクエストの文脈やユーザーの閲覧履歴に関する情報を漏えいさせる可能性がある
  - 多くの汎用ユーザーエージェントは、参照元がローカルなfile URIやdata URI である場合`Referer`を送信しない
  - ユーザーエージェントは参照元リソースがセキュアなプロトコルで取得され、かつリクエストターゲットのオリジンが
    参照元と異なる場合、参照元リソースが明示的に`Referer`の送信を許可していない限り
    `Referer`ヘッダーフィールドを送信すべきではない
  - 参照元リソースがセキュアなプロトコルで取得された場合、非セキュアなHTTPリクエストで`Referer`を送信してはならない
- 中継者は無差別に`Referer`ヘッダーフィールドを送信リクエストから削除することがある
  - `Referer`による情報開示を制限したい中継者やユーザーエージェント拡張は、内部ドメイン名を仮名に置き換える、
    あるいはクエリやパスコンポーネントを切り詰めるなど、限定的な編集に変更をとどめるべき
  - 中継者は`Referer`の値が対象URI と同じスキームおよびホストを共有している場合、
    `Referer`ヘッダフィールドを変更または削除すべきではない

#### TE
- `TE`リクエストヘッダフィールドはクライアントがどの転送コーディング (Transfer Coding) を受け入れられるか、
  トレーラフィールドを破棄せずに扱えるかの対応能力を記述する
- リクエストの`TE`ヘッダに`"trailers"`が含まれる場合、クライアントがトレーラを受け取っても破棄しない意図を示す
  - ただし処理をするとは言っていない
- HTTP/1.1 においては、レスポンスで使用される転送コーディングのうち
  クライアントが受け入れ可能なものをサーバに通知する目的にも使用される
  - RFC公開時点で転送符号化を使用しているのはHTTP/1.1のみである
- `TE`フィールド値はメンバのリスト
  - 各メンバは転送コーディング名のトークン、その転送コーディングに対するクライアントの相対的な優先度を示す重み、
    転送コーディングに対する任意のパラメータを含めることもできる (`"trailers"`を除く)

```
TE                 = #t-codings
t-codings          = "trailers" / ( transfer-coding [ weight ] )
transfer-coding    = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

- `TE`を送信する側は、中継者にこのフィールドを転送しないよう通知する必要があり、
  そのため`Connection`ヘッダフィールド内に`"TE"`接続オプションを必ず送信しなければならない

#### User-Agent
- `User-Agent`ヘッダフィールドはリクエストを発信したユーザーエージェントに関する情報を含む
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のユーザーエージェントの制限を回避したりそれに合わせてレスポンスを調整するため
  - ブラウザやOSの利用状況に関する分析のため などの目的でサーバによって利用される
  - ユーザーエージェントは特別な設定で無効化されていない限り、各リクエストに`User-Agent`を送信することが推奨される

```
User-Agent = product *( RWS ( product / comment ) )
```

- `User-Agent`フィールド値は1 つ以上の`product`識別子から構成され、それぞれに0個以上のコメントが続く
  - それらを合わせてユーザーエージェントのソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例として`product`識別子は、ユーザーエージェントを特定する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
product         = token ["/" product-version]
product-version = token
```

- `product`識別子に記述する内容は、製品を識別するために必要な最小限の情報に限定することが推奨される
  - `product`識別子内に広告やその他の不要な情報を生成してはならない
  - `product-version`にはバージョン識別子ではない情報を含めるべきではない

```
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

- ユーザーエージェントは不必要に詳細で粒度の細かい情報を含む`User-Agent`ヘッダフィールドを生成すべきではなく、
  第三者によるサブプロダクトの追加も最小限に抑えるべき
- ユーザーエージェントが他の実装との互換性を宣言する目的で他実装の`product`トークンを使用することは推奨されない
- もしユーザーエージェントが別のユーザーエージェントになりすましている場合、
  受信者は識別されたユーザーエージェント向けに調整されたレスポンスを意図的に望んでいるものとみなしてよい

### Response Context Fields
レスポンスに関する追加情報を提供するヘッダフィールド群
(サーバに関する情報、対象リソースに関する情報、または関連リソースに関する情報など)

#### Allow
- `Allow`レスポンスヘッダフィールドは、対象リソースがサポートしているメソッドの集合を指定する
  - リソースに関連付けられた有効なリクエストメソッドを受信者に通知するために使用される

```
Allow = #method
```

```
Allow: GET, HEAD, PUT
```

- 実際に許可されるメソッドの集合は、各リクエストの時点においてオリジンサーバによって定義される
- オリジンサーバは405 Method Not Allowed レスポンスにおいて`Allow`ヘッダフィールドを生成しなければならない
  - また、それ以外のレスポンスにおいても`Allow`を生成してもよい
- `Allow`フィールド値が空である場合、そのリソースがいかなるメソッドも許可していないことを示す
  - 設定によりリソースが一時的に無効化されている場合など
- プロキシは`Allow`ヘッダフィールドを変更してはならない
  - プロキシ自身は指示されているすべてのメソッドを理解していなくても、
    一般的なメッセージ処理規則に従ってそれらを取り扱うことができるため

#### Location
- `Location`レスポンスヘッダフィールドはレスポンスに関連付けられる特定のリソースのURIを示す
  - リクエストメソッドとステータスコードの意味論の組み合わせによってその関連の意味が定義される

```
Location = URI-reference
```

- フィールド値は1つのURI参照から構成される
  - 相対参照の場合、最終的な値は対象URIを解決することでよって算出される
- 201 Created レスポンスにおける`Location`値は、そのリクエストによって作成された主要リソースを指す
- 3xx Redirection レスポンスにおける`Location`値は、リクエストを自動的にリダイレクトする際に優先される
  ターゲットリソースを指す
  - `Location`値にフラグメントコンポーネントが存在しない場合、
    ユーザーエージェントは対象URIを生成するために用いられたURI参照のフラグメントコンポーネントを継承したものとして
    リダイレクトを処理しなければならない (元の参照にフラグメントが含まれていればそれを引き継ぐ)
    - `Location`値にフラグメント識別子を含めるのが適切でない状況も存在する
      - e.g. 201 Created レスポンスにおける`Location`は、作成されたリソースに固有のURIを提供することが意図である
- 注: 一部の受信者は有効なURI参照ではない`Location`ヘッダフィールドからの回復を試みることがある
  - RFCではそれを定義していないが、堅牢性の観点から許容している
- 注: `Content-Location`は`Location`とは異なり、同封されている表現に対応する最も特定されたリソースを指す
  - レスポンスには`Location`と`Content-Location`の両方が含まれる場合がある

#### Retry-After
- `Retry-After`レスポンスヘッダフィールドは次のリクエストを送るまでに待つべき時間をユーザーエージェントに伝える
  - 503 Service Unavailable レスポンスとともに送信される場合は、
    そのサービスがクライアントに対して利用不能であると予想される期間を示す
  - 3xx Redirection レスポンスとともに送信される場合は、
    リダイレクトされたリクエストを発行する前に、ユーザーエージェントが最低限待つべき時間を示す
- `Retry-After`フィールド値は、HTTP-dateまたはレスポンス受信後に待機すべき秒数のいずれか

```
Retry-After   = HTTP-date / delay-seconds ... delay-secondsの値は非負の10進整数。秒単位の時間を表す。
delay-seconds = 1*DIGIT
```

```
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120

...待機時間として2分が選択される
```

#### Server
- `Server`レスポンスヘッダフィールドはリクエストを処理したオリジンサーバのソフトウェア情報を示す
- リクエストを処理するためにオリジンサーバが使用しているソフトウェアに関する情報を含む。この情報は、
  - 相互運用性に関する問題の範囲を特定するため
  - 特定のサーバ実装の制限を回避したりそれに合わせてリクエストを調整するため
  - サーバやOSの利用状況に関する分析のため などの目的でクライアントによって利用される
- オリジンサーバはレスポンスに`Server`ヘッダフィールドを生成してもよい

```
Server = product *( RWS ( product / comment ) )
```

- `Server`ヘッダフィールド値は1つ以上の`product`識別子から構成され、それぞれに0個以上のコメントが続く
  - それらを合わせてオリジンサーバソフトウェアおよび重要なサブプロダクトを識別する
  - 慣例として`product`識別子は、オリジンサーバソフトウェアを識別する上での重要度が高い順に列挙される
  - 各`product`識別子は、名前と任意のバージョン番号から構成される

```
Server: CERN/3.0 libwww/2.17
```

- オリジンサーバは不必要に詳細で粒度の細かい情報を含む`Server`ヘッダフィールドを生成すべきではなく、
  第三者によるサブプロダクトの追加も制限すべき
- 過度に長く詳細な`Server`フィールド値はレスポンス遅延を増大させるだけでなく、内部実装の詳細を露呈し、
  既知のセキュリティホールを攻撃者が見つけて悪用することを容易にしてしまう可能性がある

## HTTP Authentication
### Authentication Scheme
- HTTPは拡張可能なチャレンジ・レスポンス型認証スキームの集合をアクセス制御/認証のためのフレームワークとして提供する
- 認証スキームの識別には、大文字・小文字を区別しないトークンが使用される

```
auth-scheme = token
```

### Authentication Parameters
- HTTPの認証方式では、認証スキーム名 (auth-scheme) の後ろに、認証を成立させるために必要な必要な追加情報が続く
- 追加情報の表現形式:
  - カンマ区切りのパラメータ列 `name=value`
  - token68
    - 空白を含まない66個の連続した文字列
    - RFC 4648に準拠するエンコードを想定
    - base64、base64url、base32、base16の各エンコーディングを格納できる
    - パディングのために末尾に任意個の`=`を追加可能

```
token68        = 1*( ALPHA / DIGIT /
                    "-" / "." / "_" / "~" / "+" / "/" ) *"="
```

- 認証パラメータは`名前=値`の組であり、 各パラメータ名は1つのチャレンジにつき1回だけ出現しなければならない
  - 名前トークンは大文字・小文字を区別せずに比較される
  - パラメータ値はtokenまたはquoted-stringのいずれかで表現できる
    - 認証スキームの定義は、送信者・受信者の双方において、token / quoted-string両方の表記を受け入れる必要がある
    - 後方互換性のため、認証スキームの定義は送信者側の形式をどちらかに制限してもよい

```
auth-param     = token BWS "=" BWS ( token / quoted-string )
```

### Challenge and Response
- 401 Unauthorized レスポンスは、オリジンサーバからユーザーエージェントの認可を要求 (チャレンジ) する際に使用される
  - 401は要求されたリソースに適用できるチャレンジを含む`WWW-Authenticate`ヘッダフィールドを含む
- 407 Proxy Authentication Required レスポンスは、プロキシがクライアントの認可を要求するために使用される
  - 407は要求されたリソースに対してプロキシに適用可能なチャレンジを含む`Proxy-Authenticate`ヘッダフィールドを含む

```
challenge = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- オリジンサーバに対して自身を認証したい
- ユーザーエージェントはオリジンサーバに対して自身を認証したい場合、
  リクエストに`Authorization`ヘッダフィールドを含めることによって認証情報を送信できる
- ユーザーエージェントはプロキシに対して自身を認証したい場合、
  リクエストに Proxy-Authorization ヘッダーフィールドを含めることで認証情報を送信できる

### Credentials
### Establishing a Protection Space (Realm)
### Authenticating Users to Origin Servers
#### WWW-Authenticate
#### Authorization
#### Authentication-Info
### Authenticating Clients to Proxies
####  Proxy-Authenticate
####  Proxy-Authorization
####  Proxy-Authentication-Info
