# RFC 9110 HTTP Semantics https://www.ietf.org/rfc/rfc9110.html
## Terminology and Core Concepts
- resource - リクエストの対象。URIによって識別される
- representation - リソースの状態の反映。リクエストに基づきコンテンツネゴシエーションによって選択される
- client - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- server - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- messages - 接続を介して交換される情報
- user agent - リクエストを開始するさまざまなクライアントアプリケーション (Webブラウザなど)
  - Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- origin server - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- intermediary - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
  - proxy - クライアントが利用するメッセージ転送エージェント
  - gateway (reverse proxy) - オリジンサーバが利用するメッセージ転送エージェント
  - tunnel - メッセージを変更せずにユーザーエージェント/オリジンサーバ間を中継する
- cache - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP
### URI References
- HTTPではURI Referencesの形式ごとに使用可能な場面を厳密に定義している
  - 明示がない場合URI ReferencesはターゲットURIを基準として相対的に解析される

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

### Authoritative Access
- 特定の識別子を解決して識別されたリソースへのアクセスを行う際、
  そのアクセスがリソース所有者によって制御されているとクライアントが信頼できる形で行われること
- アクセスが許可されるかどうかのプロセスはURIスキームによって定義される

#### URI Origin
- 正規化されたスキーム / ホスト / ポートの3要素からなる組。HTTPにおける名前空間と権限の境界を形成する。

#### http Origin
- URIに含まれるauthority (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバがそのURIを代表しているとみなされるオリジン (論理的な起点)

#### https Origin
- URIに含まれるhost:portではなく、そのoriginに対して有効であるとクライアントが信頼する証明書に対応する秘密鍵を持つ
  サーバに対して確立される権威 (authority) に基づくオリジン
- H1 - URI originのhostに対してTLSで保護された接続が直接確立されている場合にauthorityを認める
- H2/H3 - 証明書に含まれる複数のhostに対して接続可能であるとクライアントが信頼できる場合にauthorityを認める

#### https Certificate Verification
- httpsでURIをdereferenceする際、クライアントは接続先サービスの身元がそのURIのoriginと正しく一致していることを
  RFC6125に基づく証明書検証によって確認する

#### IP-ID Reference Identity
- httpsでホストにIPリテラルを用いる場合、参照アイデンティティはIP-ID (P Address Identity) となり、
  証明書のsubjectAltNameに含まれるiPAddressと完全一致する必要がある

## Fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される
-
### Field Names

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
- プロキシはConnectionヘッダフィールドにそのフィールド名が列挙されていない限り
  or 当該フィールドを遮断もしくは変換するよう明示的に設定されていない限り、
  認識できないヘッダフィールドをオリジンに転送しなければならない
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する

### Field Lines and Combined Field Value / Field Order
- フィールドは任意数のフィールド行から構成され、フィールド行はフィールド名とフィールド行値から構成される
- 同一フィールド名が複数行で現れた場合、フィールド値は各行の値を順にカンマ区切りで連結したものとして解釈される
  - 送信者は原則として複数同名フィールドを複数送信してはいけない (実務上の都合によりSet-Cookieを除く)
  - サーバはヘッダ全体を受信し終えるまで処理してはならない

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
- サーバ側では大きすぎるヘッダを受け取った場合、適切な4xxを返す
- クライアント側では大きすぎるヘッダを受け取った場合、レスポンスの意味を変えない範囲で破棄したり切り詰めても良い

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
- CR / LF / NULを含むfield valueは無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
- Singleton fields - フィールド値として単一の要素のみを想定するフィールド
- List-based fields - フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される

### Common Rules for Defining Field Values
- カンマ区切りの値の列の可読性を上げるために`#rule`ABNF拡張が定義されている

```
<n>#<m>element

最低n個~最大m個のelementをカンマ + OWS区切りで並べる

e.g.
  example-list      = 1#example-list-elmt
  example-list-elmt = token

において、

<有効>
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"

<無効>
  ""
  ","
  ",   ,"
```

- 送信者は空要素を生成してはいけない。受信者は妥当な範囲で空要素を無視する。
- token - 最も基本的な識別子。1文字以上、空白や区切り文字を含まない、可視ASCIIのうちdelimiterを除いた集合
- OWS - 任意空白。送信者は生成可能、受信者はSP1個に正規化可能
- RWS - 必須空白。送信者はSP 1個を生成推奨、受信者はSP 1個に正規化可能
- BWS - 悪い空白。送信者は生成禁止、受信者は必ず削除
- quoted-string - `"`で囲まれた空白・カンマ・特殊文字を含む値
- パラメータ構文 - フィールド値に付加情報を付ける共通形式

```
パラメータ構文

; name=value

name  ... token (大文字小文字を区別しない)
value ... token or quoted-string
= の前後に空白は禁止
```

- 日時形式はUTC (GMT) 固定。送信者はIMF-fixdateのみ生成可能、送信者はIMF-fixdate、RFC 850形式、asctime形式を受理

## Message Abstraction (HTTPメッセージの抽象データ型)
- メッセージの構成要素
  - Control data (制御データ) メッセージの種別・経路決定に必要な即時情報
  - Headers lookup table (ヘッダ表) 制御データを拡張し追加情報を伝えるための名前:値の組の集合
  - Content (本文ストリーム) 任意・サイズ無制限のデータ
  - Trailers lookup table (トレーラ表) 本文送信中に得られた情報を伝えるための名前:値の組の集合
- メッセージはストリームとして前方から順に処理される
  - 制御データは受信者が即座に知る必要のある事項
  - ヘッダフィールドは受信者がコンテンツ受信前に知る必要のある事項
  - コンテンツはメッセージのセマンティクスを満たすために受信者が必要とする本体
  - トレーラフィールドはコンテンツ送信前には不明であった任意のメタデータ
- メッセージはそれ自体で意味が完結することを意図 (自己記述性)
- クライアントは対応するレスポンスを解析・解釈・キャッシュする際には
  それに対応するリクエストに関する知識を保持していなければならない

### Framing and Completeness
- メッセージフレーミング = 各メッセージがどこから始まり、どこで終わるのかを示す仕組み
  - メッセージは同一の接続上を流れる他のメッセージと区別される必要がある
- メッセージデータを長さで区切る (length-delimited) 形式で送信することによって明示的フレーミングを行う
  - Content-Length
  - Transfer-Encoding: chunked
  - HTTP/2 / HTTP/3のフレーム境界
- そのフレーミングによって示されたすべてのオクテットが受信可能になった時点でそのメッセージは完了
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- リクエストメッセージの制御データ
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データ
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前: 制御データはメッセージの最初の行で送信される
- HTTP/2 / HTTP/3: 制御データは予約された名前プレフィックスを持つ疑似ヘッダフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージはバージョンを持つ
  - バージョンはメッセージ内で明示される場合やメッセージが受信された接続から推定される場合がある
  - 受信者はバージョン情報を用いて送信者との以後の通信における制約や可能性を判断する
  - メッセージが転送される場合は中継者が使うバージョンに更新される (上流のプロトコルバージョンはViaヘッダに記載)
  - クライアントは自身が準拠している中で最高の、かつサーバがサポートしている最高以下のバージョンを送信する
  - サーバは自身が準拠している中で最高の、かつ受信したリクエストの最高以下のバージョンを送信する

### Header Fields
- 本文 (Content) より前に送受信され、メッセージの意味を補足・拡張したり、追加の情報を記述するためのメタデータ
- ヘッダフィールド = ヘッダフィールド行 (フィールド名 + フィールド値) の並び

### Content
- メッセージフレーミングによって区切られたヘッダの後に送信されるバイトストリーム (フレーミングを除去した実データ)

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

#### Identifying Content
- 完全または部分的な表現がメッセージ本文として転送される場合、
  その本文がどのリソースのどの表現なのかを識別できることが望ましい

### Trailer Fields
- 本文 (Content) より後に送受信され、本文を送信し終えた後でしか確定しない情報を伝えるためのメタデータ
  - メッセージ整合性チェック
  - デジタル署名
  - 配送メトリクス
  - 後処理の結果や状態情報 など
- ヘッダセクションのフィールドとは別個に処理・保存されるべき
- 特定のヘッダフィールドの有無はメッセージ全体の扱いに影響するため、
  その場合は後からトレーラが到着しても取り消すことはできない

#### Limitations on Use of Trailers
- 使用中のHTTPバージョンが対応しており、かつ明示的なフレーミング機構によって有効化されている場合にのみ利用できる
- トレーラは中間者によって破棄される可能性がある
  - サーバはトレーラーフィールドとしてユーザーエージェントが必ず受信すべき情報を送信すべきではない
- 受信者は、対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラ値を安全に統合できる方法を
  明示的に許可・規定されいる場合を除き、トレラーフィールドをヘッダーセクションに統合してはならない
- リクエストの`TE`ヘッダに`trailers`が含まれる場合、クライアントがトレーラを受け取っても破棄しないという同意を示す
  - ただし処理をするとは言っていない

#### Processing Trailer Fields
- トレーラセクションで送信される可能性のあるフィールド名を事前に示すために`Trailer`ヘッダフィールドを利用できる
- 同じ名前を持つトレーラーフィールドは受信した順序で処理される
- 同一名のトレーラフィールド行が複数存在する場合、値はリストとして連結される

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- メッセージが生成された日時 (HTTP-date 形式)
- 時計を持つオリジンサーバは、2xx、3xx、4xx系レスポンスにおいては必ず`Date`ヘッダフィールドを生成しなければならない
- 時計を持たないオリジンサーバは、`Date`ヘッダフィールドを生成してはならない
- 時計を持つ受信者が`Date`ヘッダフィールドを含まないレスポンスを受信した場合、
  そのレスポンスを受信した時刻を記録し、そのレスポンスをキャッシュまたは下流へ転送する際には
  ヘッダセクションに対応する`Date`ヘッダフィールドを追加しなければならない

#### Trailer
- そのメッセージ内でトレーラフィールドとして送信される予定のフィールド名の一覧

## Routing HTTP Messages
- リクエストメッセージのルーティングは対象リソース、クライアントのプロキシ設定、
  インバウンド接続の確立または再利用に基づいてクライアントが決定する
- 対応するレスポンスのルーティングは同じ接続経路を逆方向にたどってサーバからクライアントへ返送される

### Determining the Target Resource
- Target Resource (対象リソース) - クライアントが操作したいリソースそのもの
- Target URI (対象URI) - Target Resourceを一意に識別するために使われる絶対URI (URI参照を解決して得られる)
  - クライアントの設定 (URL、プロキシ設定、既定ホストなど) はURI参照とみなすことがでくる
  - URI参照を解決して絶対URIを取得し、フラグメントを除外することで対象URIが確定する
- クライアントは対象リソースに対する操作を行うため、受信者が同一のリソースを特定できる
  解析済みTarget URIの構成要素 (request target) を含むリクエストメッセージを送信する
  - request targetはメソッド定義に従い、メッセージの制御データおよびHostヘッダフィールドとして送信される
  - 例外1) CONNECT - request targetはトンネル先のホスト名とポート番号をコロンで連結した形式となる
  - 例外2) OPTIONS - request targetとしてアスタリスク`*`を使用できる
- サーバは受信した情報から対象URIを再構築する (再構成方法はHTTPのメジャーバージョンごとに異なる)

### Host and :authority
- リクエストにおける`Host`ヘッダフィールドは、対象URIに含まれるホストおよびポート情報を提供し、
  オリジンサーバが複数のホスト名に対するリクエストを処理する際に対象のリソースを識別できるようにする
  - HTTP/2 or 3では場合によってリクエスト制御データに含まれる`:authority`擬似ヘッダフィールドが`Host`の役割を担う
- クライアントはリクエストに`Host`ヘッダフィールドもしくは`:authority`擬似ヘッダーフィールドを必ず含める

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

### Routing Inbound Requests
- クライアントは対象URIおよびそのオリジンの確定後、
  ネットワークリクエストが必要かどうかを判断し、必要である場合にはそのリクエストをどこへ送信するかを決定する

#### To a Cache
- クライアントがキャッシュを持っており、そのキャッシュでリクエストを満たせる場合、
  キャッシュに対してリクエストが向けられる

#### To a Proxy
- キャッシュでリクエストが満たされず、設定に基づいてプロキシが適用可能と判断された場合、
  そのプロキシに対してインバウンド接続を確立 (または再利用) し、
  クライアントのTarget URIに一致するリクエストターゲットを含むHTTPリクエストメッセージを送信する
  - プロキシの設定方法は実装依存
  - 多くの場合はURIプレフィックスの一致、authorityの選択的な一致、あるいはその両方に基づいて判断される
  - プロキシ自体は通常、httpまたはhttpsのURIによって識別される

#### To the Origin
- 適用可能なプロキシが存在しない場合、対象URIのスキームに固有のハンドラ処理を起動し、
  識別されたリソースへのアクセスを試みる
  - 対象がhttpリソースの場合、識別されたオリジンサーバへのインバウンド接続を確立 (または再利用) し、
    対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する
  - 対象がhttpsリソースの場合、識別されたオリジンに対して権威を持つオリジンサーバとのセキュアなインバウンド接続を
    確立 (または再利用) し、その上で対象URIに一致するリクエストターゲットを含むHTTPリクエストを送信する

### Rejecting Misdirected Requests
- サーバがリクエストを受信し、対象URIを判定できる程度まで解析すると、サーバはそのリクエストへの対応を決定する
  - 自ら処理する
  - 別のサーバへ転送する
  - クライアントを別のリソースへリダイレクトする
  - エラーで応答する
  - 接続を切断する など
- 接続が信頼されたゲートウェイからのものでないとき、サーバは対象URIに対し、
  スキーム固有の要件が満たされていないリクエストを必ず拒否しなければならない
  - 特にhttpsリソースに対するリクエストは、対象URIのオリジンに対して有効な証明書によって
    セキュア化された接続上で受信されていない限り、拒否しなければならない
- オリジンサーバがそのリクエストを誤配送と判断して拒否する場合、ステータスコード421 Misdirected Request を返す

### Response Correlation
- 1つの接続は複数のリクエスト - レスポンス交換に使用される場合がある
- リクエストとレスポンスの組みを対応付ける仕組みはHTTPのバージョンによって異なる
- すべてのレスポンスは、ステータスコードにかかわらずリクエストの受信後であればいつでも送信できる
  - リクエストがまだ完了していない場合であっても、レスポンスが先に完了することもある
  - クライアントはレスポンスを待つために特定の時間だけ待機することを期待されてはいない
    - クライアントは、合理的な時間内にレスポンスを受信できない場合、そのリクエストを放棄することがある
  - 関連するリクエストの送信中にレスポンスを受信したクライアントは、明示的に中止を示す指示を受け取らない限り、
    当該リクエストの送信を継続すべき

### Message Forwarding
- 中間者 (intermediary) はHTTP リクエストおよびレスポンスの処理においてさまざまな目的で使用される
  - 性能・可用性向上 (キャッシュ、ロードバランシング)
  - アクセス制御 (認証・認可、フィルタリング、セキュリティゲートウェイ)
- HTTPストリームはpipe-and-filter型の性質を持つため、リクエスト方向・レスポンス方向のどちらに対しても
  中間者が処理を追加・変更・干渉する際の理論的上限はない
- 中間者はプロトコル要素を認識できない場合であっても、メッセージを転送することが期待される
- トンネルとして動作していない中間者は、Connectionヘッダーフィールドを実装しなければならず、
  かつ受信側接続のみに向けられたフィールドを転送から除外しなければならない
- 中間者は、無限のリクエストループから保護されていない限り、自分自身にメッセージを転送してはならない
- 中間者は自身のサーバ名を認識し、自分自身を指す宛先へのリクエストには直接応答すべき
- HTTPメッセージは下流への逐次処理や転送のために、ストリームとして解析することができる
  - 一方送信者や受信者は、部分メッセージが逐次的に配送されることを前提にしてはならない
  - 実装によってはさまざまな理由でメッセージ転送をバッファリングまたは遅延させる場合があるため

#### Connection
- `Connection`ヘッダフィールドは、送信者が現在の接続限りで有効な制御オプションを列挙するためのもの
  - HTTPでは二種類のヘッダがあり、`Connection`ヘッダはこの区別を明示するための仕組み
    - hop-by-hop - 現在の接続の相手だけに意味があり、次の中継先へは送ってはいけない
    - end-to-end - メッセージ全体に意味を持ち、中継を越えて伝える
  - 大文字・小文字を区別しない
  - `Connection`以外のフィールドを用いて現在の接続に関する制御情報を提供する場合、
    `Connection`ヘッダフィールド内に対応するフィールド名を列挙しなければならない
    - HTTPの一部バージョンでは、そのような情報をフィールドで表現すること自体が禁止されている
- トンネルとして動作していない中間者は、メッセージを転送する前に受信した`Connection`ヘッダフィールドを必ず解析し、
  このフィールドに含まれる各オプションと同名のヘッダまたはトレーラフィールドはメッセージから削除し、
  `Connection`ヘッダフィールド自体も削除する
  - または転送されるメッセージに対する中間者自身の制御オプションに置き換える
- 中間者は、仕様としてhop-by-hopであると決まっているフィールドについては、
  それらがオプションとして列挙されているか否かにかかわらず、当該フィールドの意味論を適用した上で削除または置換すべき
  - `Proxy-Connection`, `Keep-Alive`, `TE`, `Transfer-Encoding`, `Upgrade`など
- 送信者は、コンテンツのすべての受信者を対象とするフィールドに対応するオプションを送信してはならない
  - `Cache-Control`など
- オプションは必ずしも実在するフィールドと対応する必要はない
  - `Connection`にないのに接続専用フィールドが来た場合、受信者は無視するべき

#### Max-Forwards
- `Max-Forwards`ヘッダフィールドは、TRACEおよびOPTIONSリクエストメソッドにおいて
  プロキシによる転送回数の上限 (このリクエストメッセージが今後転送され得る残り回数を示す10進整数) を明示するもの
  - `Max-Forwards`ヘッダフィールドを含むTRACE / OPTIONSリクエストを受信した中間者は、
    リクエストを転送する前に、`Max-Forwards`の値を必ず確認・更新する
    - 受信した値が0: 中間者はリクエストを転送せずに最終受信者としてレスポンスを返す
    - 受信した値が0より大きい: `Max-Forwards` = `[受信した値 - 1, 中間者がサポートするMax-Forwardsの最大値].min`
- TRACE / OPTIONS 以外のリクエストメソッドで受信した`Max-Forwards`ヘッダフィールドについては無視してもよい

#### Via
- `Via`ヘッダフィールドは、クライアント - サーバ間に存在する中間プロトコルおよび中間受信者を示すもの
- `Via`フィールド値の各要素は、そのメッセージを転送したプロキシまたはゲートウェイを表す
  - 各中間者は自身がそのメッセージをどのように受信したかの情報を`Via`フィールド値の末尾に追加 するため、
    最終的な`Via`の並び順は、転送経路の順序を表す
- プロキシは転送するすべてのメッセージに対して、`Via`ヘッダフィールドを必ず送信しなければならない
  - HTTP-to-HTTPゲートウェイはすべての受信リクエストに対して必ず`Via`を送信しなければならない。
    転送するレスポンスに対しては送信してもよい。

```
Via: 1.0 fred, 1.1 p.example.net

1. クライアント -> fred (HTTP/1.0)
2. fred -> p.example.net (HTTP/1.1)
3. p.example.net -> オリジンサーバへ
```

### Message Transformations
- HTTP-to-HTTPプロキシのうち、意味的に重要な形でメッセージを変更するよう設計または設定されているものは
  変換プロキシ (transforming proxy) と呼ばれる
  - 共有アノテーションサーバ
  - マルウェアフィルタ
  - フォーマット変換
  - プライバシーフィルタ
- これらの変換はそのプロキシを選択したクライアントによって意図的に望まれているものとみなされる
- プロキシが受信した対象URIのホスト名がFQDNでない場合、プロキシはリクエスト転送時に自身のドメインを付加してもよい
  - 対象URIにFQDNが含まれている場合、プロキシはホスト名を変更してはならない
  - 転送プロトコル上必要とされる場合を除き、対象URIのabsolute-pathおよびquery部分を変更してはならない
- プロキシはレスポンスメッセージのコンテンツに`no-transform`キャッシュディレクティブが含まれている場合、
  そのコンテンツを変換してはならない (コンテンツ自体を変更しない変換を除く)
  - `no-transform`が含まれていないメッセージについては、プロキシはコンテンツを変換してもよい
- プロキシが200 OK レスポンスのコンテンツを変換した場合、下流の受信者に変換が行われたことを示すために、
  レスポンスステータスコードを203 Non-Authoritative Informationに変更して通知することができる。
- プロキシは通信経路のエンドポイント、リソースの状態、または選択された表現に関する情報を提供するヘッダフィールドを
  変更すべきではない
  - そのフィールド定義が明示的に許可している場合、またはプライバシーやセキュリティ上必要と判断される場合を除く

### Upgrade
- `Upgrade`ヘッダフィールドは、同一のコネクション上でHTTP/1.1から別のプロトコルへ移行する簡易的な仕組みを提供する
- クライアントはリクエストの`Upgrade`ヘッダフィールドに プロトコル名のリストを含めて送信することで、
  サーバに対して最終レスポンスを送信する前に、列挙されたプロトコルのいずれかへ切り替えることを提案できる
  - 優先度は高い順、大文字小文字を区別しない
- サーバは現在のプロトコルを継続したい場合、`Upgrade`ヘッダフィールドを無視してもよい
- サーバは提案を受け入れる場合101 Switching Protocolsレスポンスを送信する
  - その際接続を切り替えられる新しいプロトコルを示すために`Upgrade`ヘッダフィールドを必ず送信する
  - 複数のプロトコル層が切り替えられる場合、サーバは下位層から上位層の順でプロトコルを列挙しなければならない
  - クライアントが提示していないプロトコルへ切り替えてはならない
  - クライアントが示した優先順を無視し、リクエストの性質やサーバの負荷など他の要因に基づいてプロトコルを選択できる
- サーバはリクエストに対して現在のプロトコルのままでは処理できず、プロトコルのアップグレードが必要だと判断した場合
  426 Upgrade Requiredレスポンスを送信する
  - その際接続を切り替えられる新しいプロトコルを示すために`Upgrade`ヘッダフィールドを必ず送信する
  - 複数のプロトコル層が切り替えられる場合、サーバは下位層から上位層の順でプロトコルを列挙しなければならない

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

...以降、WebSocket プロトコルに切り替わり、 GET /hello に対する WebSocket 的な応答が続く...
```

- プロトコル変更後のアプリケーションレベルの通信の性質や能力は、選択された新しいプロトコルに依存する
  - サーバは101レスポンスを送信した直後は元のリクエストに対する処理を新しいプロトコル上で継続することが期待される
    - サーバは新しいプロトコルで元のメッセージの意味論を正しく処理できない場合、プロトコルを切り替えてはならない
- `Upgrade`の送信者は、必ず`Connection`ヘッダフィールドに "Upgrade"を指定する
- サーバはHTTP/1.0のリクエストで`Upgrade`場合、その`Upgrade`フィールドを無視しなければならない
- サーバは`Upgrade`と`Expect: 100-continue`の両方を受信した場合、101を送信する前に必ず100 Continueを送信する
- クライアントはリクエスト全体を完全に送信し終えるまで、アップグレード後のプロトコルを使用してはならない
- `Upgrade`ヘッダフィールドは、既存のコネクション上でのプロトコル切り替えにのみ適用される。

## Representation Data and Metadata
### Representation Data
- HTTPメッセージに関連付けられる表現データ (representation data) は
  メッセージの本文として含まれるか、メッセージの意味論 + 対象URIによって参照される
- 表現データの形式およびエンコーディングは表現メタデータを示すヘッダフィールドによって定義される
- 表現データのデータ型は`Content-Type`および`Content-Encoding`ヘッダフィールドによって決定される

```
representation-data := Content-Encoding( Content-Type( data ) )

- data                                     ... 元の表現内容 (Content-Typeが直接定義する対象)
- Content-Type( data )                     ... dataをあるメディア型としてシリアライズしたもの (バイト列)
- Content-Encoding( Content-Type( data ) ) ... Content-Type( data ) をエンコーディングしたもの (HTTPメッセージ本文)
```

```
(このメッセージの本文はJSON型として解釈されるバイト列をgzip圧縮したもの)

Content-Type: application/json
Content-Encoding: gzip
```

### Representation Metadata
- 表現ヘッダフィールド (representation header fields) は表現に関するメタデータを提供する
- メッセージに本文が含まれる場合、表現ヘッダーフィールドはそのデータをどのように解釈すべきかを記述する
  - `Content-Type`
  - `Content-Encoding`
  - `Content-Language`
  - `Content-Length`
  - `Content-Location` など

### Content-Type
- `Content-Type`ヘッダフィールドはメッセージの本文の表現、またはメッセージの意味論上選択された表現を表す
- 指定されたメディア型は、データ形式およびそのデータを受信者がどのように処理することを意図しているかの両方を定義する
- メッセージは`Content-Encoding`が示す方式によってデコードされた後、
  受信したメッセージの意味論の範囲内で`Content-Type`が適用される

```
Content-Type = media-type
```

```
Content-Type: text/html; charset=ISO-8859-4
```

- 本文を含むメッセージを生成する送信者は、メッセージに`Content-Type`ヘッダフィールドを生成するべき
  - `Content-Type`ヘッダフィールドが存在しない場合、
    受信者はメディア型を`application/octet-stream`と仮定するかデータを調べてその型を決定してもよい
- MIME sniffing ... ユーザーエージェントが本文から`Content-Type`を推測し、受信した型を上書きすること
  - 誤判断やセキュリティリスクの可能性があるため、実装する場合は利用者が無効化できる手段を提供することが推奨される
- `Content-Type`は単一フィールドとして定義されている
  - 誤って複数回生成されて結合フィールド値になることがあるため、多くの実装は最後の有効な値を使用している

#### Media Type
- media-typeはデータ形式と、そのデータをメッセージの文脈に従ってどのように処理するかを定義する
  - HTTPでは`Content-Type`および`Accept`ヘッダフィールドにおいてmedia-typeを使用する
- media-typeはIANAで管理される

```
media-type = type "/" subtype parameters
type       = token
subtype    = token
```

```
text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
text/html;charset=UTF-8
```

#### Charset
- charsetはテキスト表現の文字エンコーディング方式を定義する
  - HTTPでは`Content-Type`のパラメータ、または`Accept-Encoding`ヘッダフィールドのトークンとしてcharsetを使用する

#### Multipart Types
- multipartは一つのメッセージボディ内に一つ以上の表現をカプセル化するためのmedia-type
  - MIMEには複数のmultipartが定義されている

```
multipart/form-data
multipart/byteranges
multipart/mixed
```

- すべてのmultipartは共通の構文とboundaryパラメータを含む

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123
```

- multipartのボディは単なるバイト列ではなく、MIMEによって定義された厳密なプロトコル構文を持つ構造体

### Content-Encoding
- `Content-Encoding`ヘッダフィールドは`Content-Type`が示すデータに対して適用された圧縮と、そのデコード順序を示す
  - media-typeに含まれるもの以外で、`Content-Type`に対して適用されているコンテンツコーディング
  - `Content-Type`ヘッダフィールドで参照されるmedia-typeのデータを得るために適用する必要があるデコード機構
  - (`Content-Type`は復号後に得られるデータの型を示す)
- 主に、基となるmedia-typeの同一性を失うことなく、表現データを圧縮できるようにするために用いられる

```
Content-Encoding = #content-coding
```

```
Content-Encoding: gzip
```

- media-type自体が常に圧縮されているような内在的なエンコーディングを含む場合、
  そのエンコーディングは、同じアルゴリズムであっても`Content-Encoding`には再度記載されない
- オリジンサーバは同じデータの複数の表現として`Content-Type` / `Content-Encoding`の異なるデータを公開することがある
- オリジンサーバはリクエストメッセージ内の表現が受け入れ不可能なコンテンツコーディングを含んでいる場合、
  415 Unsupported Media Type で応答してもよい

#### Content Codings
- content-codingは表現に対して適用される、または適用可能なエンコーディング変換
  - gzip
  - br
  - deflate など
- 圧縮・変換を可能にする、media-typeの同一性を失わないことを目的に使用される
- `Accept-Encoding`および`Content-Encoding`ヘッダフィールドで使用される

```
content-coding = token
```

- Compress Coding
  - Lempel-Ziv-Welch (LZW) 圧縮方式 (compressよって生成される)
- Deflate Coding
  - deflate圧縮データストリームを含むzlibデータ形式、Lempel-Ziv (LZ77) 圧縮アルゴリズムとハフマン符号化の組み合わせ
- Gzip Coding
  - 32ビットの巡回冗長検査 (CRC) を備えたLZ77圧縮方式 (gzipファイル圧縮プログラムによって生成される)

### Content-Language
- `Content-Language`ヘッダフィールドはその表現が想定している受信者の自然言語を示す
  - 必ずしも表現内で実際に使用されている言語と一致するとは限らない

```
Content-Language = #language-tag
```

```
(同一内容を複数言語で同時提供しているケース)

Content-Language: ja, en
```

- `Content-Language`が指定されていない場合はすべての言語の受信者を対象とする

#### Language Tags
- language-tagは人間同士の情報伝達のために話されたり、書かれたり、その他の形で用いられる自然言語を識別する

```
language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

```
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

### Content-Length
- `Content-Length`ヘッダフィールドは関連付けられた表現データの長さを10進の非負整数でオクテット数として示す
- メッセージの本文が送信される場合、`Content-Length`は具体的に同封されているデータ量を指す
  - HTTP/1.1ではフレーミングを区切るためにに使われる
- メッセージの本文が送信されない場合、`Content-Length`は選択された表現の現在の長さを示す
  - 転送時間の見積もりやキャッシュ済み表現との比較などに使われる

```
Content-Length = 1*DIGIT
```

```
Content-Length: 3495
```

- 0以上の値が有効値。事前定義された上限はないため
  - 受信者は非常に大きな10進数値を想定し、整数変換時のオーバーフローや精度喪失による解析エラーを防がなければならない
- 送信者は誤っていると分かっている`Content-Length`を含むメッセージを転送してはならない
- ABNF定義に一致しない`Content-Length`を含むメッセージを転送してはならない
  - 例外として、同一の10進値がカンマ区切りで繰り返された`Content-Length`を受信した場合、
    受信者はそれを無効として拒否してもよいし、重複生成や結合の結果であると考えて、単一の値に置き換えてもよい

#### ユーザーエージェントにとっての`Content-Length`
- リクエストメソッドが本文に意味を与えており、かつ`Transfer-Encoding`を送信していない場合、
  `Content-Length`を送信するべき
  - e.g. 本文が空の`POST`でも通常は`Content-Length`を送信する
  - メッセージに本文が含まれない場合は`Content-Length`を送信するべきではない

#### サーバにとっての`Content-Length`
- `HEAD`に対するレスポンスに`Content-Length`を送信してもよい
  - 値は同じリクエストを`GET`で行った場合に送信されるはずの本文のオクテット数と等しくする必要がある
- 条件付き`GET`に対する304 Not Modified レスポンスで`Content-Length`を送信してもよい
  - 値は同じリクエストに対する200 OK レスポンスで送信されるはずの本文のオクテット数と等しくする必要がある
- 1xx または204 No Content レスポンスでは`Content-Length`を送信してはならない
- `CONNECT`に対する2xx レスポンスでは`Content-Length`を送信してはならない
- 上記を除き、`Transfer-Encoding`が存在せず本文サイズがヘッダ送信前に判明している場合`Content-Length`を送信するべき
  - これにより、下流の受信者は転送進捗を把握でき、メッセージの完全性を判断でき、後続リクエストのために接続を
    再利用できる可能性がある

### Content-Location
- `Content-Location`ヘッダフィールドはメッセージの本文に含まれる表現に対応するリソースを識別するためのURIを示す
  - 当該メッセージが生成された時点でそのURIに対して`GET`すると、当該メッセージの本文と同一の表現が200 OK になる
  - リソースの識別子ではなく、メッセージに含まれる表現の識別子
    - `Content-Location`は対象URI (どのリソースに対する操作か) の代替ではない

```
Content-Location = absolute-URI / partial-URI
```

- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` == 対象URIの場合:
  - メッセージ生成日時点における当該リソースの現在の表現を示す
  - `GET`や`HEAD`の場合は`Content-Location`が省略された場合のデフォルトの意味と同じ
  - `POST` / `PUT`の場合は操作後の新しいリソースの表現を示す
- 2xx レスポンスに`Content-Location`が含まれ、`Content-Location` != 対象URIの場合:
  - `GET` / `HEAD` - コンテントネゴシエーションによって選ばれた表現の識別子
  - それ以外 - 処理の結果の表現を示す
- リクエストメッセージに含まれる`Content-Location`値は、元表現へのバックリンクを提供している
  - 当該表現の元データを (ユーザーエージェントによる変更前に) 取得した元の場所
- サーバは`Content-Location`を受信したとき、その情報を表現の一部として保存されるメタデータではなく、
  一時的なリクエスト本文として扱わなければならない
  - サーバはそのコンテキストをリクエスト処理の補助や、ソースリンクやバージョン管理メタデータなどの用途に利用できる
  - 要求の意味論を変更するために用いてはならない

### Validator Fields
- バリデータヘッダフィールドは事前条件 (precondition) で使用できるvalidatorを定義する
  - `Last-Modified`、`ETag`など
  - 条件付きリクエスト、同時更新の衝突防止、キャッシュ検証 などに使用される
- `GET` / `HEAD` などのリクエストに対するレスポンスでは、サーバが処理の際に選択した表現を記述する
- 状態変更を伴うリクエストに対して成功を示すレスポンスでは、サーバの処理結果として新たに有効となった表現を記述する

#### Weak versus Strong
#### Last-Modified
##### Generation
##### Comparison
#### ETag
##### Generation
##### Comparison
##### Example: Entity Tags Varying on Content-Negotiated Resources
