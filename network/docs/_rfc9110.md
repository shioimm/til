# RFC 9110 HTTP Semantics
## Terminology and Core Concepts
- resource - リクエストの対象。URIによって識別される
- representation - リソースの状態の反映。リクエストに基づきコンテンツネゴシエーションによって選択される
- client - 1つ以上のHTTPリクエストを送信する目的でサーバとの接続を確立するプログラム
- server - クライアントからの接続を受け入れ、HTTPリクエストを処理し、HTTPレスポンスを送信するプログラム
- messages - 接続を介して交換される情報
- user agent - リクエストを開始するさまざまなクライアントアプリケーション (Webブラウザなど)
  - Webブラウザ、CLI、デジタルサイネージスクリーン、家電製品、ファームウェア更新スクリプト、モバイルアプリなど
- origin server - 特定のターゲットリソースに対して権威あるレスポンスを生成できるプログラム
  - 公開Webサイト、ネットワーク機器、オフィス機器、自律型ロボット、モバイルアプリなど
- intermediary - オリジンサーバ - UA間を中継しリクエストを実現するためのプログラム
  - proxy - クライアントが利用するメッセージ転送エージェント
  - gateway (reverse proxy) - オリジンサーバが利用するメッセージ転送エージェント
  - tunnel - メッセージを変更せずにユーザーエージェント/オリジンサーバ間を中継する
- cache - 過去のレスポンスメッセージを保持するローカルストアと、そのメッセージの保存・取得・削除を制御するシステム

## Identifiers in HTTP
### URI References
- HTTPではURI Referencesの形式ごとに使用可能な場面を厳密に定義している
  - 明示がない場合URI ReferencesはターゲットURIを基準として相対的に解析される

```
URI-reference = リソースを指す文字列の総称
absolute-URI  = スキームを含む完全なURI
relative-part = 相対パス。ベースURIと結合して解決される
partial-URI   = relative-part [ "?" query ]
authority     = ネットワーク上の接続先 [ userinfo "@" ] host [ ":" port ]
uri-host      = ホスト名またはIPアドレス
port          = TCP/UDPのポート番号
path-abempty  = 空文字列または / で始まるパス。authority を伴うURIで使用される
segment       = パスを / で区切った最小単位
query         = ? 以降の付加情報
absolute-path = /から始まるパス形式
```

### HTTP-Related URI Schemes
- URIの存在はサーバの存在や有効性を保証しない
- URI名前空間は委任に基づく分散的な仕組みとして成り立っている
- `http-URI = "http://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は80
  - authorityによってオリジンが定まり、空のホスト識別子を持つURIは無効とされる
- `https-URI = "https://" + authority + path-abempty [ + "?" + query ]`
  - ポートの規定値は443
  - https / httpは別個のオリジン
- http(s) URIは仕様に基づく正規化によって同一性を判断される
  - 既定ポート、大文字小文字、パーセントエンコードなどが考慮される
  - 正規化の結果等価であるURIは同一リソースを指すとみなされる
- http(s) URIにuserinfoを含めることは非推奨
- フラグメント識別子 (`#`) はURIスキームとは独立した要素であり、使用可否は各プロトコル要素のABNF 規則で定まる

### Authoritative Access
- 特定の識別子を解決して識別されたリソースへのアクセスを行う際、
  そのアクセスがリソース所有者によって制御されているとクライアントが信頼できる形で行われること
- アクセスが許可されるかどうかのプロセスはURIスキームによって定義される

#### URI Origin
- 正規化されたスキーム / ホスト / ポートの3要素からなる組。HTTPにおける名前空間と権限の境界を形成する。

#### http Origin
- URIに含まれるauthority (host:port) によって特定され、
  そのhost:portでTCP接続を受け付けるサーバがそのURIを代表しているとみなされるオリジン (論理的な起点)

#### https Origin
- URIに含まれるhost:portではなく、そのoriginに対して有効であるとクライアントが信頼する証明書に対応する秘密鍵を持つ
  サーバに対して確立される権威 (authority) に基づくオリジン
- H1 - URI originのhostに対してTLSで保護された接続が直接確立されている場合にauthorityを認める
- H2/H3 - 証明書に含まれる複数のhostに対して接続可能であるとクライアントが信頼できる場合にauthorityを認める

#### https Certificate Verification
- httpsでURIをdereferenceする際、クライアントは接続先サービスの身元がそのURIのoriginと正しく一致していることを
  RFC6125に基づく証明書検証によって確認する

#### IP-ID Reference Identity
- httpsでホストにIPリテラルを用いる場合、参照アイデンティティはIP-ID (P Address Identity) となり、
  証明書のsubjectAltNameに含まれるiPAddressと完全一致する必要がある

## Fields
- フィールドはメッセージのヘッダおよびトレーラにおいて送受信される
-
### Field Names

```
field-name     = token
```

- フィールド名は大文字・小文字を区別しない
- フィールドの解釈は同一のHTTPメジャーバージョン内のマイナーバージョン間で変化しない
- プロキシはConnectionヘッダフィールドにそのフィールド名が列挙されていない限り
  or 当該フィールドを遮断もしくは変換するよう明示的に設定されていない限り、
  認識できないヘッダフィールドをオリジンに転送しなければならない
- プロキシ以外の受信者は認識できないヘッダフィールドおよびトレーラフィールドを無視する

### Field Lines and Combined Field Value / Field Order
- フィールドは任意数のフィールド行から構成され、フィールド行はフィールド名とフィールド行値から構成される
- 同一フィールド名が複数行で現れた場合、フィールド値は各行の値を順にカンマ区切りで連結したものとして解釈される
  - 送信者は原則として複数同名フィールドを複数送信してはいけない (実務上の都合によりSet-Cookieを除く)
  - サーバはヘッダ全体を受信し終えるまで処理してはならない

### Field Limits
- ヘッダ行・ヘッダ値・ヘッダ / トレーラ全体の長さに、明確な上限値はない
- サーバ側では大きすぎるヘッダを受け取った場合、適切な4xxを返す
- クライアント側では大きすぎるヘッダを受け取った場合、レスポンスの意味を変えない範囲で破棄したり切り詰めても良い

### Field Values
- フィールド値は当該フィールドの文法 (ABNF) によって定義された形式を持つ文字列の並び

```
field-value   = *field-content
field-content = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
field-vchar   = VCHAR (可視文字) / obs-text
obs-text      = %x80-FF

(VCHAR ... 可視文字)
(SP    ... 空白)
(HTAB  ... 空白)
```

- フィールド値は原則US-ASCII、拡張が必要な場合はエンコーディング (RFC 8187) を明示する
- CR / LF / NULを含むfield valueは無効、その他のCTL文字も原則無効 (安全な文脈においてのみ互換性のために保持できる)
- Singleton fields - フィールド値として単一の要素のみを想定するフィールド
- List-based fields - フィールド値として複数の要素を許容するフィールド
- フィールド値の要素間の区切りにはカンマを使用する
- フィールド値として指定されるパラメータ値 (name=value形式) としては
  非引用形式tokenと引用形式quoted-string (二重引用符で囲み、空白や特殊文字を含められる値) の両方が許容される

### Common Rules for Defining Field Values
- カンマ区切りの値の列の可読性を上げるために`#rule`ABNF拡張が定義されている

```
<n>#<m>element

最低n個~最大m個のelementをカンマ + OWS区切りで並べる

e.g.
  example-list      = 1#example-list-elmt
  example-list-elmt = token

において、

<有効>
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"

<無効>
  ""
  ","
  ",   ,"
```

- 送信者は空要素を生成してはいけない。受信者は妥当な範囲で空要素を無視する。
- token - 最も基本的な識別子。1文字以上、空白や区切り文字を含まない、可視ASCIIのうちdelimiterを除いた集合
- OWS - 任意空白。送信者は生成可能、受信者はSP1個に正規化可能
- RWS - 必須空白。送信者はSP 1個を生成推奨、受信者はSP 1個に正規化可能
- BWS - 悪い空白。送信者は生成禁止、受信者は必ず削除
- quoted-string - `"`で囲まれた空白・カンマ・特殊文字を含む値
- パラメータ構文 - フィールド値に付加情報を付ける共通形式

```
パラメータ構文

; name=value

name  ... token (大文字小文字を区別しない)
value ... token or quoted-string
= の前後に空白は禁止
```

- 日時形式はUTC (GMT) 固定。送信者はIMF-fixdateのみ生成可能、送信者はIMF-fixdate、RFC 850形式、asctime形式を受理

## Message Abstraction (HTTPメッセージの抽象データ型)
- メッセージの構成要素
  - Control data (制御データ) メッセージの種別・経路決定に必要な即時情報
  - Headers lookup table (ヘッダ表) 制御データを拡張し追加情報を伝えるための名前:値の組の集合
  - Content (本文ストリーム) 任意・サイズ無制限のデータ
  - Trailers lookup table (トレーラ表) 本文送信中に得られた情報を伝えるための名前:値の組の集合
- メッセージはストリームとして前方から順に処理される
  - 制御データは受信者が即座に知る必要のある事項
  - ヘッダフィールドは受信者がコンテンツ受信前に知る必要のある事項
  - コンテンツはメッセージのセマンティクスを満たすために受信者が必要とする本体
  - トレーラフィールドはコンテンツ送信前には不明であった任意のメタデータ
- メッセージはそれ自体で意味が完結することを意図 (自己記述性)
- クライアントは対応するレスポンスを解析・解釈・キャッシュする際には
  それに対応するリクエストに関する知識を保持していなければならない

### Framing and Completeness
- メッセージフレーミング = 各メッセージがどこから始まり、どこで終わるのかを示す仕組み
  - メッセージは同一の接続上を流れる他のメッセージと区別される必要がある
- メッセージデータを長さで区切る (length-delimited) 形式で送信することによって明示的フレーミングを行う
  - Content-Length
  - Transfer-Encoding: chunked
  - HTTP/2 / HTTP/3のフレーム境界
- そのフレーミングによって示されたすべてのオクテットが受信可能になった時点でそのメッセージは完了
- 明示的なフレーミングがない場合、下位接続のクローズによって終了したレスポンスメッセージは、
  トランスポートレベルのエラーが示されない限り完全なメッセージとして扱われる

### Control Data
- リクエストメッセージの制御データ
  - リクエストメソッド
  - リクエストターゲット
  - プロトコルバージョン
- レスポンスメッセージの制御データ
  - ステータスコード
  - (任意) 理由
  - プロトコルバージョン
- HTTP/1.1以前: 制御データはメッセージの最初の行で送信される
- HTTP/2 / HTTP/3: 制御データは予約された名前プレフィックスを持つ疑似ヘッダフィールドとして送信される
  - `:method`, `:path`, `:authority`, `:status`
- すべてのHTTPメッセージはバージョンを持つ
  - バージョンはメッセージ内で明示される場合やメッセージが受信された接続から推定される場合がある
  - 受信者はバージョン情報を用いて送信者との以後の通信における制約や可能性を判断する
  - メッセージが転送される場合は中継者が使うバージョンに更新される (上流のプロトコルバージョンはViaヘッダに記載)
  - クライアントは自身が準拠している中で最高の、かつサーバがサポートしている最高以下のバージョンを送信する
  - サーバは自身が準拠している中で最高の、かつ受信したリクエストの最高以下のバージョンを送信する

### Header Fields
- 本文 (Content) より前に送受信され、メッセージの意味を補足・拡張したり、追加の情報を記述するためのメタデータ
- ヘッダフィールド = ヘッダフィールド行 (フィールド名 + フィールド値) の並び

### Content
- メッセージフレーミングによって区切られたヘッダの後に送信されるバイトストリーム (フレーミングを除去した実データ)

#### Content Semantics
- リクエストにおける本文の目的は、リクエストメソッドの意味論によって定義される
- レスポンスにおける本文の目的は、リクエストメソッド、レスポンスステータスコード、
  その本文を説明するレスポンスフィールドによって定義される
  - 1xx、204、304レスポンスには本文は含まれない

#### Identifying Content
- 完全または部分的な表現がメッセージ本文として転送される場合、
  その本文がどのリソースのどの表現なのかを識別できることが望ましい

### Trailer Fields
- 本文 (Content) より後に送受信され、本文を送信し終えた後でしか確定しない情報を伝えるためのメタデータ
  - メッセージ整合性チェック
  - デジタル署名
  - 配送メトリクス
  - 後処理の結果や状態情報 など
- ヘッダセクションのフィールドとは別個に処理・保存されるべき
- 特定のヘッダフィールドの有無はメッセージ全体の扱いに影響するため、
  その場合は後からトレーラが到着しても取り消すことはできない

#### Limitations on Use of Trailers
- 使用中のHTTPバージョンが対応しており、かつ明示的なフレーミング機構によって有効化されている場合にのみ利用できる
- トレーラは中間者によって破棄される可能性がある
  - サーバはトレーラーフィールドとしてユーザーエージェントが必ず受信すべき情報を送信すべきではない
- 受信者は、対応するヘッダフィールドの定義を理解しており、かつその定義がトレーラ値を安全に統合できる方法を
  明示的に許可・規定されいる場合を除き、トレラーフィールドをヘッダーセクションに統合してはならない
- リクエストの`TE`ヘッダに`trailers`が含まれる場合、クライアントがトレーラを受け取っても破棄しないという同意を示す
  - ただし処理をするとは言っていない

#### Processing Trailer Fields
- トレーラセクションで送信される可能性のあるフィールド名を事前に示すために`Trailer`ヘッダフィールドを利用できる
- 同じ名前を持つトレーラーフィールドは受信した順序で処理される
- 同一名のトレーラフィールド行が複数存在する場合、値はリストとして連結される

### Message Metadata
- リクエスト / レスポンスには、メッセージがいつどのように生成されたかを記述するフィールドを含めることができる

#### Date
- メッセージが生成された日時 (HTTP-date 形式)
- 時計を持つオリジンサーバは、2xx、3xx、4xx系レスポンスにおいては必ず`Date`ヘッダフィールドを生成しなければならない
- 時計を持たないオリジンサーバは、`Date`ヘッダフィールドを生成してはならない
- 時計を持つ受信者が`Date`ヘッダフィールドを含まないレスポンスを受信した場合、
  そのレスポンスを受信した時刻を記録し、そのレスポンスをキャッシュまたは下流へ転送する際には
  ヘッダセクションに対応する`Date`ヘッダフィールドを追加しなければならない

#### Trailer
- そのメッセージ内でトレーラフィールドとして送信される予定のフィールド名の一覧
