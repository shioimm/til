# yacc
- パーサジェネレータ
- 文法ファイルから構文規則を入力し、それに基づくLALR構文解析器になるCのソースプログラムを出力する
- 文法ファイルはBNF (Backus-Naur Form) によって記述する
- yaccで作ったパーサはLALR機能を持つ
  - シフトや還元をする前に次の記号を見てどうするかを判断する

#### 終端記号
- スキャナから送られてくる記号

#### 非終端記号
- スキャナから送られて来ず、パーサの中でしか使用されない記号

## 動作フロー
1. 文法ファイル (`*`.y) をyaccにかけ、構文解析器ソースプログラム (y.tab.c) を出力する
    - `$ yacc FILENAME.y`
    - 出力したプログラムはLALR解析テーブルおよびドライバルーチンを含む
2. 構文解析器ソースプログラムをgccでコンパイルし、実行ファイルを生成する
    - Lexも利用している場合はLexの出力ファイル (lex.yy.c）もコンパイラに与える
3. 生成されたファイルの実行時に標準入力から変換するファイルを読み込み、
   スキャナから送られる記号とその値をパーサ内のスタック (セマンティックスタック) にプッシュ (シフト) していく
    - シフトされた記号は随時定義した文法によって還元される
    - 記号の値はyylvalグローバル変数によって`yyparse()`関数に渡される
    - 記号の値の型はYYSTYPE型 (文法ファイルの定義部にて`%union`命令で指定した共用体)
    - `yylex()`関数 - スキャナ
    - `yyparse()`関数 - セマンティックスタックにプッシュされた記号の還元
4. 還元にフックして文法規則ごとに定義してあるアクションが実行される
    - アクションの実行時には文法規則の右辺に対応する記号の値がアクションに渡される

## 文法ファイル
#### 定義部
- いろいろな定義や前準備を記述する

#### 規則部
- どんな文法をパースしたいかを記述する
- `yyparse()`関数 (狭義のパーサ関数) に変換される

#### ユーザ定義部
- yaccに解釈をさせず、そのまま実行したい処理を記述する

## 参照
- [yacc](https://ja.wikipedia.org/wiki/Yacc)
- [第9章 速習yacc](https://i.loveruby.net/ja/rhg/book/yacc.html)
