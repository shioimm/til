# 動作フロー
1. 文法ファイル`<FileName>`.yを作成する
    - Lexを利用している場合はLexの出力ファイル (lex.yy.c）を文法ファイルにincludeする
2. 文法ファイル`<FileName>`.yをyaccにかける -> 構文解析器ソースプログラムy.tab.cが出力される
    - `$ yacc <FileName>.y`
    - 出力したy.tab.cはLALR解析テーブルおよびドライバルーチンを含む
2. y.tab.cをgccでコンパイルし、実行ファイル`<FileName>.o`を生成する
    - パーサとなる`yyparse()`が生成される
3. `yyparse()`にアプリケーションのソースプログラムを渡して (標準入力) 実行すると、
   `yyparse()`はスキャナ`yylex()`を呼び出す
4. ソースプログラムが`yylex()`の入力バッファに格納される
5. 入力バッファに格納されたデータが1バイトずつトークンバッファに読み込まれる
    - トークンバッファはトークンが一つ切り出せるまで文字列を保管する
6. `yylex()`はトークンバッファからトークン (終端記号) と
   グローバル変数`yylval`に格納されたトークンの値を切り出し、
   パーサ`yyparse()`内のスタック (セマンティックスタック) にプッシュ (シフト) する
    - シフトされた記号は随時定義した文法によって還元される
    - 還元にフックして文法規則に定義されているアクションが実行される -> 構文木がつくられる
    - アクションが実行される際に記号の値がアクションに渡される

#### `yyparse()`
- 狭義のパーサ・構文木を生成するために呼び出される関数
- トークンを読み込み、アクションを実行し、入力ファイルのEOFに達するか構文エラーに達して終了する
- `yyparse()`関数は字句解析を行わないため、ユーザーは別途字句解析関数`yylex()`関数を用意する必要がある
  - `yyparse()`関数は入力からトークンを入手する必要が生じるたびに`yylex()`関数を呼び出す
  - `yyparse()`関数の呼び出しが成功した場合は0、解析エラーを発見した場合は1を返す

#### `yylex()`
- スキャナ (レキサ)
- Lexを使用している場合、lex.yy.cをコンパイルすることで使用できるようになる
- `yyparse()`から呼び出された際に入力からトークンを切り出し、`yyparse()`に返す

#### シンボル (終端記号 + 非終端記号) の値
- 全てのシンボルは値 ($n) を持ち、アクションの中で操作することができる
- スキャナから送られるトークン (終端記号) の値は`yylval`変数に格納された状態で
  `yyparse()`のセマンティックスタックにプッシュされる
- アクション内で$$に値を代入することで左辺のシンボルが持つ値を設定することができる
- 記号の値の型はYYSTYPE型 (`%union`で定義された共用体型) (指定がない場合はint型)

```
%token S
%%
stmts   : S
        | stmts S
```

```
/* e.g. */

        stmts  S      /* 還元直前のスタック */
        値1    値2
         ↓     ↓
stmts:  stmts  S      /* 右辺が末尾にマッチした規則 */
   ↑     ↓     ↓
{ $$  = $1  +  $2; }  /* そのアクション */

        stmts         /* 還元後のスタック */
        (値1 + 値2)
```

## 参照
- [yacc](https://ja.wikipedia.org/wiki/Yacc)
- [第9章 速習yacc](https://i.loveruby.net/ja/rhg/book/yacc.html)
- [第10章 パーサ](https://i.loveruby.net/ja/rhg/book/parser.html)
- コンパイラ入門 構文解析の原理とlex/yacc, C言語による実装
