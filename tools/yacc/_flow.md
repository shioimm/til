# 動作フロー
1. 文法ファイル`*`.yをyaccにかける -> 構文解析器ソースプログラムy.tab.cが出力される
    - `$ yacc FILENAME.y`
    - 出力したy.tab.cはLALR解析テーブルおよびドライバルーチンを含む
2. y.tab.cをgccでコンパイルし、実行ファイル`*.o`を生成する
    - パーサとなる`yyparse()`が生成される
    - Lexも利用している場合はLexの出力ファイル (lex.yy.c）もコンパイラに与える
3. `yyparse()`にアプリケーションのソースプログラムを渡して (標準入力) 実行すると、
   `yyparse()`はスキャナ`yylex()`を呼び出す
4. ソースプログラムが`yylex()`の入力バッファに格納される
5. 入力バッファに格納されたデータが1バイトずつトークンバッファに読み込まれる
    - トークンバッファはトークンが一つ切り出せるまで文字列を保管する
6. `yylex()は`トークンバッファからトークン (終端記号とその値) をグローバル変数`yylval`に格納し、
   パーサ`yyparse()`内のスタック (セマンティックスタック) にプッシュ (シフト) する
    - シフトされた記号は随時定義した文法によって還元される
    - 還元にフックして文法規則に定義されているアクションが実行される -> 構文木がつくられる
    - アクションが実行される際に記号の値がアクションに渡される
    - 記号の値の型はYYSTYPE型 (`%union`命令で指定した共用体のtypedef) で定義する

#### `yyparse()`
- 狭義のパーサ・構文木を生成するために呼び出される関数
- トークンを読み込み、アクションを実行し、入力ファイルのEOFに達するか構文エラーに達して終了する
- `yyparse()`関数は字句解析を行わないため、ユーザーは別途字句解析関数`yylex()`関数を用意する必要がある
  - `yyparse()`関数は入力からトークンを入手する必要が生じるたびに`yylex()`関数を呼び出す
  - `yyparse()`関数の呼び出しが成功した場合は0、解析エラーを発見した場合は1を返す

#### `yylex()`
- スキャナ (レキサ)
- `yyparse()`から呼び出された際に入力からトークンを切り出し、`yyparse()`に返す

## 参照
- [yacc](https://ja.wikipedia.org/wiki/Yacc)
- [第9章 速習yacc](https://i.loveruby.net/ja/rhg/book/yacc.html)
- [第10章 パーサ](https://i.loveruby.net/ja/rhg/book/parser.html)
- コンパイラ入門 構文解析の原理とlex/yacc, C言語による実装
