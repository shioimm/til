# 動作フロー
1. 文法ファイル`*`.yをyaccにかける -> 構文解析器ソースプログラムy.tab.cが出力される
    - `$ yacc FILENAME.y`
    - 出力したプログラムはLALR解析テーブルおよびドライバルーチンを含む
2. y.tab.cをgccでコンパイルし、実行ファイルparse.oを生成する
    - Lexも利用している場合はLexの出力ファイル (lex.yy.c）もコンパイラに与える
3. parse.oにアプリケーションのソースプログラムを渡して (標準入力) 実行すると、
   ソースプログラムがスキャナの入力バッファに格納される
    - `yylex()`関数 - スキャナとして動作する
4. 入力バッファに格納されたデータは1バイトずつトークンバッファに読み込まれる
    - トークンバッファはトークンが一つ切り出せるまで文字列を保管する
5. トークンバッファに読み込まれたデータからトークン (記号とその値) ごとに
   パーサ内のスタック (セマンティックスタック) にプッシュ (シフト) される
    - シフトされた記号は随時定義した文法によって還元される
    - 記号の値はyylvalグローバル変数によって`yyparse()`関数に渡される
    - 記号の値の型はYYSTYPE型 (`%union`命令で指定した共用体のtypedef)
    - `yyparse()`関数 - セマンティックスタックにプッシュされた記号の還元を行う
4. 還元にフックして文法規則ごとに定義してあるアクションが実行され、アクションによって構文木が作られる
    - アクションの実行時には文法規則に対応する記号の値がアクションに渡される

## 参照
- [yacc](https://ja.wikipedia.org/wiki/Yacc)
- [第9章 速習yacc](https://i.loveruby.net/ja/rhg/book/yacc.html)
- [第10章 パーサ](https://i.loveruby.net/ja/rhg/book/parser.html)
- コンパイラ入門 構文解析の原理とlex/yacc, C言語による実装
