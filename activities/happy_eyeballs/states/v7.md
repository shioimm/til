# 状態遷移についての理解 (7)
- selectが複数の値を返すケースを考慮する

```
扱うリソース
- Resolution waiting pipe
  - any / empty # 名前解決イベントが起こったかどうか
- Hostname resolution queue # TODO キューである必要性があるかどうかを考える
  - opened / closed # 名前解決が終わったかどうか
- Resolved addrinfos (Resolved addrinfo)
  - any / empty
  - IPv6 resolved / IPv6 not yet resolved / IPv4 resolved / IPv4 not yet resolved
- Connecting sockets
  - any / empty
- Writable sockets (Writable socket)
  - any / empty
- Connected socket
- Last error
- Local addrinfos (Local addrinfo)
  - any / empty

オプション
- resolv_timeout # 待機時間として使用する
- connect_timeout # 待機時間として使用しない

---

Local addrinfos = Addrinfo.getaddrinfo(local_host, local_port)

Thread.new { IPv6 Addrinfo.getaddrinfo }
Thread.new { IPv4 Addrinfo.getaddrinfo }

if resolv_timeout
  Started at = now
  Ends at = Started at + resolv_timeout
else
  Ends at = nil
end

# Ends at が nil = タイムアウトなしで待ち続ける
# (resolv_timeout が設定されていない初回のループのみ)
# (2回目以降は resolv_timeout、Resolution delay、Connection attempt delay、あるいは0s待つ)

loop do
  select(Resolution waiting pipe, Connecting sockets, Ends at)
  # 名前解決、接続、Ends atの時間超過のいずれかを待つ
  # キューが閉じている場合、第一引数はnil

  # 名前解決のみを待つ場合 (resolv_timeout、Resolution Delay) 、selectを抜けたらEnds atの値をリセット
  #   タイムアウトした場合は必ずリセット
  #   タイムアウトしなかった場合は意図した通りに名前解決できているので二回目の待機はしない
  #   resolv_timeoutがあり、接続失敗した後に未解決のアドレスファミリが残っている場合のみresolv_timeoutの再設定が必要
  # Connection Attempt Delayの場合はタイムアウトした場合 / しなかった場合で値をリセットするかどうかが変わる
  #   タイムアウトした場合は必ずリセット
  #   タイムアウトしなかった場合は次の接続開始まで現在の値を保持
  Connection Attempt Delay中 = Connecting sockets: any && (Writable sockets: any || Resolution waiting pipe: any)
  Ends at = Connection Attempt Delay中 ? Ends at : 0
  # (1)(4)(5)でそれぞれ上書きされる可能性あり
  #   (1) 名前解決中のアドレスファミリあり
  #       && 解決済みアドレス宛の接続試行に失敗
  #       && resolv_timeoutあり
  #       && 名前解決イベントが未発生
  #   (4) IPv4の名前解決が終わっている && IPv6は名前解決中 (Resolution delay)
  #   (5) 接続試行を開始 (Connection attempt delay)
  # (1)(4) の条件下では接続を開始できないため、(1)(4) を(5) で上書きすることはない
  # (1) はすでに接続試行開始済みの状況であるため、(1) を (4) で上書きすることはない
  # (5) で設定され、Connection Attempt Delay中であったために保持された値が (1) によって上書きされる可能性はあり
  # この場合はその後 (5) で接続を開始できないため、上書きされても問題ない

  (1) if Writable sockets: any
    # ここに来るということは必ず一回は名前解決・接続済み
    # Connection attempt delay時間内の可能性あり。Resolution delay、resolv_timeout時間内の可能性はない
    Writable socket = Writable sockets.pop
    Connecting sockets.remove Writable socket
    getsockopt(<接続エラーの確認>)

    case 接続エラー: なし
      Connected socket = Writable socket
      (2) が実行される
    case 接続エラー: あり
      Last error = エラー

      if Writable sockets: any
        retry (1)

      if Writable sockets: empty
        case Resolved addrinfos: any
          case Ends at: 時間超過 && Resolution waiting pipe: any
            (4) が実行される
            その後、(5) が実行される
            その後、接続 (Hostname resolution queue: openedの場合は名前解決も) を待つために次のループへ進む
          case Ends at: 時間超過 && Resolution waiting pipe: empty
            (5) が実行される
            その後、接続 (Hostname resolution queue: openedの場合は名前解決も) を待つために次のループへ進む
          case Ends at: 時間内 && Resolution waiting pipe: any
            (4) が実行される
            その後、Ends atの時間超過を待つために次のループへ進む
          case Ends at: 時間内 && Resolution waiting pipe: empty
            Ends atの時間超過を待つために次のループへ進む

        case Resolved addrinfos: empty
          case Connecting sockets: any && Hostname resolution queue: opened && Resolution waiting pipe: any
            (4) が実行される (その際にHostname resolution queueがcloseされる)
            その後、接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: opened && Resolution waiting pipe: empty
            接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: closed
            # Hostname resolution queue: closed の時点で Resolution waiting pipe の値は必ずclosed
            接続を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened && Resolution waiting pipe: any
            (4) が実行される (その際にHostname resolution queueがcloseされる)
            その後、名前解決を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened && Resolution waiting pipe: empty
            if resolv_timeout
              Ends at = Started at + resolv_timeout
            end
            名前解決を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: closed
            # Hostname resolution queue: closed の時点で Resolution waiting pipe の値は必ずclosed
            raise Last error
      end
    end
  end

  (2) if Connected socket: any
    return Connected socket
  end

  (3) if (connect_timeout時間超過) ||
     (resolv_tiemout時間超過 &&
      Hostname resolution queue: opened && # 名前解決が終わっていない
      Connecting sockets: empty && # 接続中のソケットがない
      Resolved addrinfos: empty && # 接続未試行のアドレスがない
      Resolution waiting pipe: empty) # 名前解決済みイベントが発生していない
    raise Errno::ETIMEDOUT, 'user specified timeout'
  end

  (4) if Resolution waiting pipe: any
    # ここに来るのは1~2回 (IPv6/IPv4)
    # Connection attempt delay時間内の可能性あり (IPv6宛に接続開始済みの場合)
    # Resolution delay時間内の可能性はない
    # resolv_timeout時間内の可能性ありだがその場合すでにEnds atはリセット済み。
    while Resolved family, Resolved addrinfos = Hostname resolution queue.pop
      Resolved addrinfos.add(Resolved family, Resolved addrinfos)
    end

    if Resolved family: IPv4 && Resolved addrinfos: IPv6 not yet resolved
      # Connection attempt delay時間内の場合 (IPv6宛に接続開始済みの場合) はここは通らない
      Ends at = now + Resolution Delay
      # このループでは接続試行を開始しない。
      # 次のループのselectでEnds atを待った結果:
      #   名前解決が発生した場合は (4) -> (5) が実行される
      #   名前解決が発生しなかった場合は (5) が実行される
      #   その前にresolv_timeout時間超過が発生した場合は (3) が実行される
    end
  end

  (5) if Ends at: 時間超過 && Resolved addrinfos: any
    # Ends at = Connection attempt delay / Resolution Delay のいずれか
    Resolved addrinfo = Resolved addrinfos.get

    if Local addrinfos: any
      case Resolved addrinfo と同じアドレスファミリの Local addrinfo がある
        Local addrinfo = Local addrinfos.get

      case Resolved addrinfo と同じアドレスファミリの Local addrinfo がない
        case Resolved addrinfos: any
          retry (5) # 別の Resolved addrinfo を試す

        case Resolved addrinfos: empty
          case Connecting sockets: any && Hostname resolution queue: opened
            新しい接続試行を諦め、接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: closed
            新しい接続試行を諦め、接続を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened
            if resolv_timeout
              Ends at = Started at + resolv_timeout
            end
            新しい接続試行を諦め、名前解決を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: closed
            raise SocketError.new 'no appropriate local address'
    end

    Connecting socket = Socket.new(Resolved addrinfo)

    if Local addrinfo: any
      Connecting socket.bind Local addrinfo
    end

    if Resolved addrinfos: empty && Connecting sockets: empty && Hostname resolution queue: closed
      connect # TODO 未実装
    else
      connect_nonblock

      case 接続に成功
        Connected socket = Connecting socket
        break Connected socket
      case 接続中
        Connecting sockets.add Connecting socket
        Ends at = now + Connection Attempt Delay
        接続を待つために次のループへ進む
        # Hostname resolution queue: opened の場合は次のループで名前解決も待つ
      case SystemCallError
        Last error = エラー

        case Resolved addrinfos: any
          retry (5)

        case Resolved addrinfos: empty
          case Connecting Sockets: any && Hostname resolution queue: opened
            接続か名前解決を待つために次のループへ進む
          case Connecting Sockets: any && Hostname resolution queue: closed
            接続を待つために次のループへ進む
          case Connecting Sockets: empty && Hostname resolution queue: opened
            if resolv_timeout
              Ends at = Started at + resolv_timeout
            end
            名前解決を待つために次のループへ進む
          case Connecting Sockets: empty && Hostname resolution queue: closed
            raise Last error
    end
  end

  if Resolved addrinfos: empty && Connecting sockets: empty && Hostname resolution queue: closed
    raise last_error
  end
end
```
