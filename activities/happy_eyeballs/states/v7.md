# 状態遷移についての理解 (7)
- selectが複数の値を返すケースを考慮する

```
扱うリソース
- Resolution waiting pipe
  - any / empty # 名前解決イベントが起こったかどうか
- Hostname resolution queue # TODO キューである必要性があるかどうかを考える
  - opened / closed # 名前解決が終わったかどうか
- Resolved addrinfos (Resolved addrinfo)
  - any / empty
  - IPv6 resolved / IPv6 not yet resolved / IPv4 resolved / IPv4 not yet resolved
- Connecting sockets
  - any / empty
- Writable sockets (Writable socket)
  - any / empty
- Connected socket
- Last error
- Local addrinfos (Local addrinfo)
  - any / empty

オプション
- resolv_timeout # 待機時間として使用する
- connect_timeout # 待機時間として使用しない

---

Local addrinfos = Addrinfo.getaddrinfo(local_host, local_port)

Thread.new { IPv6 Addrinfo.getaddrinfo }
Thread.new { IPv4 Addrinfo.getaddrinfo }

if resolv_timeout
  Started at = now
  Ends at = Started at + resolv_timeout
else
  Ends at = nil
end

# Ends at が nil = タイムアウトなしで待ち続ける
# (resolv_timeout が設定されていない初回のループのみ)
# (2回目以降は resolv_timeout、Resolution delay、Connection attempt delay、あるいは0s待つ)

loop do
  select(Resolution waiting pipe, Connecting sockets, Ends at)
  # 名前解決、接続、Ends atの時間超過のいずれかを待つ
  # キューが閉じている場合、第一引数はnil

  Ends at = 0
  # (1)(4)(5)でそれぞれ上書きされる可能性あり
  #   (1) 名前解決中のアドレスファミリあり
  #       && 解決済みアドレス宛の接続試行に失敗
  #       && resolv_timeoutあり
  #       && 名前解決イベントが未発生
  #   (4) IPv4の名前解決が終わっている && IPv6は名前解決中 (Resolution delay)
  #   (5) 接続試行を開始 (Connection attempt delay)
  # (1)(4) の条件下では接続を開始できないため、(1)(4)を(5)で上書きすることはない
  # (1) はすでに接続試行開始済みの状況であるため、(1)を(4)で上書きすることはない
  # 上書きされなかった場合はselectを0s待機

  (1) if Writable sockets: any
    # ここに来るということは必ず一回は名前解決・接続済み
    # Connection attempt delay時間内の可能性あり。Resolution delay、resolv_timeout時間内の可能性はない
    Writable socket = Writable sockets.pop
    Connecting sockets.remove Writable socket
    getsockopt(<接続エラーの確認>)

    case 接続エラー: なし
      Connected socket = Writable socket
      (2) が実行される
    case 接続エラー: あり
      Last error = エラー

      if Writable sockets: any
        retry (1)

      if Writable sockets: empty
        Connecting sockets.delete Writable socket

        case Resolved addrinfos: any
          case Ends at: 時間超過 && Resolution waiting pipe: any
            (4) が実行される
            その後、(5) が実行される
            その後、接続 (Hostname resolution queue: openedの場合は名前解決も) を待つために次のループへ進む
          case Ends at: 時間超過 && Resolution waiting pipe: empty
            (5) が実行される
            その後、接続 (Hostname resolution queue: openedの場合は名前解決も) を待つために次のループへ進む
          case Ends at: 時間内 && Resolution waiting pipe: any
            (4) が実行される
            その後、Ends atの時間超過を待つために次のループへ進む
          case Ends at: 時間内 && Resolution waiting pipe: empty
            Ends atの時間超過を待つために次のループへ進む

        case Resolved addrinfos: empty
          case Connecting sockets: any && Hostname resolution queue: opened && Resolution waiting pipe: any
            (4) が実行される (その際にHostname resolution queueがcloseされる)
            その後、接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: opened && Resolution waiting pipe: empty
            接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: closed
            # Hostname resolution queue: closed の時点で Resolution waiting pipe の値は必ずclosed
            接続を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened && Resolution waiting pipe: any
            (4) が実行される (その際にHostname resolution queueがcloseされる)
            その後、名前解決を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened && Resolution waiting pipe: empty
            if resolv_timeout # TODO 未実装
              Ends at = Started at + resolv_timeout
            end
            名前解決を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: closed
            # Hostname resolution queue: closed の時点で Resolution waiting pipe の値は必ずclosed
            raise Last error
      end
    end
  end

  (2) if Connected socket: any
    return Connected socket
  end

  (3) if (connect_timeout時間超過) ||
     (resolv_tiemout時間超過 &&
      Hostname resolution queue: opened && # 名前解決が終わっていない
      Connecting sockets: empty && # 接続中のソケットがない
      Resolved addrinfos: empty && # 接続未試行のアドレスがない
      Resolution waiting pipe: empty) # 名前解決済みイベントが発生していない
    raise Errno::ETIMEDOUT, 'user specified timeout'
  end

  (4) if Resolution waiting pipe: any
    # ここに来るのは1~2回 (IPv6/IPv4)
    Resolved family, Resolved addrinfos = Hostname resolution queue.pop # TODO 未実装: キューが空になるまで取得が必要
    Resolved addrinfos.add(Resolved family, Resolved addrinfos)

    if Resolved family: IPv4 && Resolved addrinfos: IPv6 not yet resolved
      Ends at = now + Resolution Delay
      # このループでは接続試行を開始しない。
      # 次のループのselectでEnds atを待った結果:
      #   名前解決が発生した場合は (4) -> (5) が実行される
      #   名前解決が発生しなかった場合は (5) が実行される
      #   その前にresolv_timeout時間超過が発生した場合は (3) が実行される
    end
  end

  (5) if Resolved addrinfos: any && Ends at: 時間超過 # Ends at = Connection attempt delay
    Resolved addrinfo = Resolved addrinfos.get

    if Local addrinfos: any
      case Resolved addrinfo と同じアドレスファミリの Local addrinfo がある
        Local addrinfo = Local addrinfos.get

      case Resolved addrinfo と同じアドレスファミリの Local addrinfo がない
        case Resolved addrinfos: any
          retry (5) # 別の Resolved addrinfo を試す

        case Resolved addrinfos: empty
          case Connecting sockets: any && Hostname resolution queue: opened
            新しい接続試行を諦め、接続か名前解決を待つために次のループへ進む
          case Connecting sockets: any && Hostname resolution queue: closed
            新しい接続試行を諦め、接続を待つために次のループへ進む
          case Connecting sockets: empty && Hostname resolution queue: opened
            if resolv_timeout
              Ends at = Started at + resolv_timeout
            end
            新しい接続試行を諦め、名前解決を待つために次のループへ進む
        case Connecting sockets: empty && Hostname resolution queue: closed
          raise SocketError.new 'no appropriate local address'
    end

    Connecting socket = Socket.new(Resolved addrinfo)

    if Local addrinfo: any
      Connecting socket.bind Local addrinfo
    end

    if Resolved addrinfos: empty && Connecting sockets: empty && Hostname resolution queue: closed
      connect # TODO 未実装
    else
      connect_nonblock

      case 接続に成功
        Connected socket = Connecting socket
        break Connected socket # TODO 要修正: 現状(6/8時点)、即座にreturnせず(2)に集約してしまっている
      case 接続中
        Connecting sockets.add Connecting socket
        Ends at = now + Connection Attempt Delay
        接続を待つために次のループへ進む
        # Hostname resolution queue: opened の場合は次のループで名前解決も待つ
      case SystemCallError
        Last error = エラー

        case Resolved addrinfos: any
          retry (5)

        case Resolved addrinfos: empty
          case Connecting Sockets: any && Hostname resolution queue: opened
            接続か名前解決を待つために次のループへ進む
            # TODO 要修正: 現状(6/8時点)、 resolv_timeout があり、かつ Hostname resolution queue: opened の場合
            # 無条件に Ends at に resolv_timeout を設定してしまっている
            # Connecting Sockets がある場合は不要なので条件を追加する
          case Connecting Sockets: any && Hostname resolution queue: closed
            接続を待つために次のループへ進む
          case Connecting Sockets: empty && Hostname resolution queue: opened
            if resolv_timeout
              Ends at = Started at + resolv_timeout
            end
            名前解決を待つために次のループへ進む
          case Connecting Sockets: empty && Hostname resolution queue: closed
            raise Last error # TODO 未実装
    end
  end
end
```
