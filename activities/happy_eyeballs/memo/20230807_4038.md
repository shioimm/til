# PR#4038の実装
https://github.com/ruby/ruby/blob/0820228d29fa8de223f21043fb51988d32bfa97c/ext/socket/lib/socket.rb

```ruby
def self.tcp(host,
             port,
             local_host = nil,
             local_port = nil,
             connect_timeout: nil,
             resolv_timeout: nil) # :yield: socket

  last_error = nil
  ret = nil
  start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)

  if connect_timeout
    raise ArgumentError, "connect_timeout must be Numeric" unless connect_timeout.is_a?(Numeric)
    raise ArgumentError, "connect_timeout must not be negative" if connect_timeout.negative?
  end

  if resolv_timeout
    raise ArgumentError, "resolv_timeout must be Numeric" unless resolv_timeout.is_a?(Numeric)
    raise ArgumentError, "resolv_timeout must not be negative" if resolv_timeout.negative?
  end

  # デフォルトではIPv6 / IPv4いずれも実行
  attempt_v6 = true
  attempt_v4 = true
  local_addr_list = nil

  if local_host != nil || local_port != nil
    # local_hostかlocal_portがある場合は接続ソケットにバインドするためのアドレスリストを取得しておく
    local_addr_list = Addrinfo.getaddrinfo(local_host, local_port, nil, :STREAM, nil)

    # ユーザが指定したlocal_host / local_portがある場合はアドレスファミリごとに実行の有無を保持
    attempt_v6 = local_addr_list.any? {|local_ai| local_ai.afamily == Socket::AF_INET6 }
    attempt_v4 = local_addr_list.any? {|local_ai| local_ai.afamily == Socket::AF_INET }
  end

  pipe_read, pipe_write = IO.pipe
  mutex = Mutex.new
  ai_list_v6 = []
  ai_list_v4 = []
  error_queue = Queue.new

  # ----------------------------------
  # Hostname Resolution Query Handling
  # ----------------------------------

  # 1. スレッドを生成
  # 2. ai_list_vn を Addrinfo.getaddrinfo(host, port, :PF_INETn, :STREAM) で置き換えた値を返す
  # 3. pipe_write に getaddrinfo の完了を書き込む (ensure)
  # (IPv4の場合) Resolution Delayを実行し、終了後 pipe_write にResolution Delayの完了を書き込む
  getaddrinfo_v6_th =
    start_getaddrinfo_v6(host, port, mutex, pipe_write, ai_list_v6, error_queue) if attempt_v6
  getaddrinfo_v4_th =
    start_getaddrinfo_v4(host, port, mutex, pipe_write, ai_list_v4, error_queue) if attempt_v4

  # ユーザが指定したresolv_timeoutがある場合はタイムアウト時間分だけgetaddrinfoの終了を待つ
  if resolv_timeout
    timeout_th = Thread.new do
      Thread.current.report_on_exception = false
      sleep(resolv_timeout)
      mutex.synchronize { pipe_write.close() }
    end
  end

  # ----------------------------------
  # Connection Attempts
  # ----------------------------------

  ret, socket_list, addrinfos, last_error =
    make_connection_attempts(pipe_read, attempt_v6, attempt_v4, ai_list_v6, ai_list_v4, local_addr_list)

  ret, last_error =
    wait_connection(socket_list, addrinfos, connect_timeout, start_time) if !ret && !socket_list.empty?

  addrinfos.clear()

  unless ret
    if last_error
      raise last_error
    elsif connect_timeout || resolv_timeout
      raise Errno::ETIMEDOUT, "user specified timeout"
    elsif !error_queue.empty?
      # raise a unhandled exception in getaddrinfo threads
      error = error_queue.pop until error_queue.empty?
      raise error
    else
      raise SocketError, "no appropriate local address"
    end
  end

  ret.nonblock = false
  socket_list.delete(ret)

  if block_given?
    cleanup_socket_tcp([getaddrinfo_v6_th, getaddrinfo_v4_th, timeout_th], socket_list + [pipe_read, pipe_write])
    begin
      yield ret
    ensure
      ret.close
    end
  else
    return ret
  end
ensure
  unless block_given?
    threads = [getaddrinfo_v6_th, getaddrinfo_v4_th, timeout_th]
    ios = socket_list ? socket_list + [pipe_read, pipe_write] : [pipe_read, pipe_write]
    cleanup_socket_tcp(threads, ios)
  end
end
```

```ruby
def self.start_getaddrinfo_v6(host, port, mutex, pipe_write, ai_list_v6, error_queue)
  return Thread.new do
    Thread.current.report_on_exception = false
    ai_list_v6.replace(Addrinfo.getaddrinfo(host, port, :PF_INET6, :STREAM))
  rescue SocketError => ex
    case ex.message
    when "getaddrinfo: Address family for hostname not supported" # when IPv6 is not supported
      # ignore
    when "getaddrinfo: Temporary failure in name resolution" # when timed out (EAI_AGAIN)
      # ignore
    else
      error_queue.push(ex) # report the exception to main thread
    end
  rescue => ex
    error_queue.push(ex)
  ensure
    mutex.synchronize { pipe_write.putc(GETADDRINFO_V6_DONE) unless pipe_write.closed? }
  end
end

private_class_method :start_getaddrinfo_v6

# 50ms is the recommended value for the resolution delay for IPv4 in RFC8305
RESOLUTION_DELAY = 0.05
private_constant :RESOLUTION_DELAY

def self.start_getaddrinfo_v4(host, port, mutex, pipe_write, ai_list_v4, error_queue)
  return Thread.new do
    Thread.current.report_on_exception = false
    begin
      ai_list_v4.replace(Addrinfo.getaddrinfo(host, port, :PF_INET, :STREAM))
    rescue SocketError => ex
      case ex.message
      when "getaddrinfo: Address family for hostname not supported" # when IPv4 is not supported
        # ignore
      when "getaddrinfo: Temporary failure in name resolution" # when timed out (EAI_AGAIN)
        # ignore
      else
        error_queue.push(ex) # report the exception to main thread
      end
    rescue => ex
      error_queue.push(ex)
    ensure
      mutex.synchronize { pipe_write.putc(GETADDRINFO_V4_DONE) unless pipe_write.closed? }
    end

    unless ai_list_v4.empty? # if getaddrinfo finished successfully
      sleep(RESOLUTION_DELAY) # 50ms is the recommended value for the resolution delay for IPv4 in RFC8305
      mutex.synchronize { pipe_write.putc(RESOLUTION_DELAY_DONE) unless pipe_write.closed? }
    end
  end
end

private_class_method :start_getaddrinfo_v4
```

```ruby
CONNECTION_ATTEMPT_DELAY = 0.25
private_constant :CONNECTION_ATTEMPT_DELAY

def self.make_connection_attempts(pipe_read,
                                  attempt_v6,
                                  attempt_v4,
                                  ai_list_v6,
                                  ai_list_v4,
                                  local_addr_list)
  pipe_reads = [pipe_read]
  socket_list = []
  addrinfos = {}
  getaddrinfo_v6_done = attempt_v6 ? false : true
  getaddrinfo_v4_done = attempt_v4 ? false : true
  resolution_delay_done = false
  last_family = nil
  next_connection_start_time = nil
  while !getaddrinfo_v6_done || !getaddrinfo_v4_done || !ai_list_v6.empty? || !ai_list_v4.empty?
    if next_connection_start_time
      now = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      select_timeout = next_connection_start_time - now # wait until CONNECTION_ATTEMPT_DELAY is elapsed since last connection attempt
      select_timeout = 0 if select_timeout.negative?
    elsif socket_list.empty?
      select_timeout = nil # wait for events
    else
      select_timeout = CONNECTION_ATTEMPT_DELAY
    end

    readable_pipes, writable_sockets, = IO.select(pipe_reads, socket_list, nil, select_timeout)

    if writable_sockets && !writable_sockets.empty?
      ret, error, failed_sockets = find_connected_socket(writable_sockets, addrinfos)
      socket_list -= failed_sockets
      last_error = error if error
      break if ret
    end

    if readable_pipes && !readable_pipes.empty? # handle an event
      event = pipe_read.getbyte
      if event
        case event
        when GETADDRINFO_V6_DONE
          getaddrinfo_v6_done = true
        when GETADDRINFO_V4_DONE
          getaddrinfo_v4_done = true
        when RESOLUTION_DELAY_DONE
          resolution_delay_done = true
        end
      else # name resolution has timed out
        getaddrinfo_v6_done = true
        getaddrinfo_v4_done = true
      end
    end

    # IO.select may return within CONNECTION_ATTEMPT_DELAY
    # make sure CONNECTION_ATTEMPT_DELAY is elapsed from the last connection attempt
    if next_connection_start_time
      now = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      next if now < next_connection_start_time
    end

    ai = pick_addrinfo(getaddrinfo_v6_done, getaddrinfo_v4_done, resolution_delay_done, ai_list_v6, ai_list_v4, last_family)
    next unless ai # no addrinfo available for now
    last_family = ai.afamily

    local_addr = nil
    if local_addr_list
      local_addr = local_addr_list.find {|local_ai| local_ai.afamily == ai.afamily }
      next unless local_addr
    end

    next_connection_start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC) + CONNECTION_ATTEMPT_DELAY

    begin
      sock = Socket.new(ai.pfamily, ai.socktype, ai.protocol)
      sock.ipv6only! if ai.ipv6?
      sock.bind(local_addr) if local_addr

      addrinfos[sock] = ai
      case sock.connect_nonblock(ai, exception: false)
      when 0
        ret = sock
        break
      when :wait_writable
        socket_list.push(sock)
      end
    rescue SystemCallError => ex
      last_error = ex
      sock&.close()
    end
  end

  return ret, socket_list, addrinfos, last_error
end
```

```ruby
def self.wait_connection(socket_list, addrinfos, connect_timeout, start_time)
  ret = nil
  timeout = nil # wait forever
  last_error = nil
  while !ret && !socket_list.empty? && timeout != 0
    if connect_timeout
      # set timeout for IO.select
      elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start_time
      timeout = connect_timeout - elapsed
      timeout = 0 if timeout.negative? # returns immediately
    end
    begin
      _, writable_sockets, = IO.select(nil, socket_list, nil, timeout)
    rescue SystemCallError => ex
      last_error = ex
    end
    if writable_sockets && !writable_sockets.empty?
      ret, error, failed_sockets = find_connected_socket(writable_sockets, addrinfos)
      socket_list -= failed_sockets
      last_error = error if error
    end
  end
  return ret, last_error
end
```

```ruby
def self.cleanup_socket_tcp(threads, ios)
  threads.each {|th| th&.exit }
  ios.each do |io|
    begin
      io.close if io && !io.closed?
    rescue
      # ignore error
    end
  end
end

private_class_method :cleanup_socket_tcp
```
