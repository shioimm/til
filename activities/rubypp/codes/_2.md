# 実装メモ

```ruby
class Integer
  def __plusplus__(name, b)
    b.local_variable_set(name, self.succ)
  end
end

i = 0
i.__plusplus__("i", binding)

# RubyVM::AbstractSyntaxTree.parse('i.__plusplus__("i", binding)')
# => (SCOPE@1:0-1:28
#     tbl: []
#     args: nil
#     body:
#       (CALL@1:0-1:28 (VCALL@1:0-1:1 :i) :__plusplus__
#          (LIST@1:15-1:27 (STR@1:15-1:18 "i") (VCALL@1:20-1:27 :binding) nil)))
```

```c
// parse.y

method_call : // ...
            | primary_value lex_ctxt tINCOP_ASGN
            {
              // メソッド名
              ID plusplus = rb_intern("__plusplus__");

              // 第一引数 ("i")
              VALUE v = rb_id_quote_unprintable($1->nd_vid);
              NODE *receiver = NEW_LIT(v, &NULL_LOC);

              // Bindingオブジェクト
              NODE *self = NEW_SELF(&NULL_LOC);
              VALUE b = rb_funcall(self->u1.value, rb_intern("binding"), 0);
              NODE *binding = NEW_LIT(b, &NULL_LOC);

              $$ = new_qcall(p, $3, $1, plusplus, <(name, b)>, &@3, &@$);
              nd_set_line($$, @3.end_pos.lineno);
            }

// やること
//   メソッド名をIDとして取得する
//   (引数)
//     $1->u1.value の名前をノードとして取得する
//     self を VALUEとして取得する
//     VALUE b = rb_funcall(<self>, rb_intern("binding"), 0); を取得する
//     NODE *binding = NEW_LIT(b, &NULL_LOC); を取得する
//     $1->u1.value の名前ノードとbindingの配列ノードを作り、第三引数に渡す
```

```c
// メソッドのIDを取得
ID method = rb_intern("to_s");

// メソッドの実行結果のVALUEを取得
VALUE result = rb_funcall($1->nd_lit, method, 0);

// 変数名を示すIDから文字列VALUEを作成
VALUE receiver = rb_id_quote_unprintable($1->nd_vid);
```

### 引数 (`NODE *args`)

```c
// NEW_LIST で要素aを持つ新しいリストを作成し、list_append() で要素itemを追加する

// node.h
#define NEW_LIST(a,loc) NEW_NODE(NODE_LIST,a,1,0,loc)

// parse.y
static NODE*
list_append(struct parser_params *p, NODE *list, NODE *item);
```

```c
// self オブジェクトの作成

// node.h
#define NEW_SELF(loc) NEW_NODE(NODE_SELF,0,0,1,loc)
#define NEW_NODE(t,a0,a1,a2,loc) rb_node_newnode((t),(VALUE)(a0),(VALUE)(a1),(VALUE)(a2),loc)
```
