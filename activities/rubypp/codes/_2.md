# 実装メモ

```ruby
class Integer
  def __plusplus__(name, b)
    b.local_variable_set(name, self.succ)
  end
end

i = 0
i.__plusplus__("i", binding)

# RubyVM::AbstractSyntaxTree.parse('i.__plusplus__("i", binding)')
# => (SCOPE@1:0-1:28
#     tbl: []
#     args: nil
#     body:
#       (CALL@1:0-1:28 (VCALL@1:0-1:1 :i) :__plusplus__
#          (LIST@1:15-1:27 (STR@1:15-1:18 "i") (VCALL@1:20-1:27 :binding) nil)))
```

```c
// parse.y

method_call : // ...
            | primary_value lex_ctxt tINCOP_ASGN
            {
              ID plusplus = rb_intern("__plusplus__");

              $$ = new_qcall(p, $3, $1, plusplus, <(name, b)>, &@3, &@$);
              nd_set_line($$, @3.end_pos.lineno);
            }

// やること
//   $1->u1.value の名前をノードとして取得する
//   self を VALUEとして取得する
//   VALUE b = rb_funcall(<self>, rb_intern("binding"), 0); を取得する
//   NODE *binding = NEW_LIT(b, &NULL_LOC); を取得する
//   $1->u1.value の名前ノードとbindingの配列ノードを作り、第三引数に渡す
```

```c
// メソッドのIDを取得
ID method = rb_intern("to_s");

// メソッドの実行結果のVALUEを取得
VALUE result = rb_funcall($1->u1.value, method, 0);
```

### 引数 (`NODE *args`)
- `NEW_LIST`で要素`a`を持つ新しいリストを作成し、`list_append()`で要素`item`を追加する

```c
// node.h
#define NEW_LIST(a,loc) NEW_NODE(NODE_LIST,a,1,0,loc)

// parse.y
static NODE*
list_append(struct parser_params *p, NODE *list, NODE *item)
{
}
```
