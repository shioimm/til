# コンパイル
#### プログラミング言語の抽象度
1. 機械語 (オブジェクトファイル) - CPUが直接理解可能
2. アセンブリ言語
3. 中間表現 (バイトコード) - 高級言語のコンパイラ・インタプリタの内部形式・VMで実行される
4. 高級言語

## コンパイルの全体構成
1. フロントエンド
    - 変換前のコードLsを字句解析し、トークン列を生成する
    - トークン列を構文解析・意味解析し構文木/中間言語プログラムを生成する
2. バックエンド
    - 構文木/中間言語プログラムをコード最適化
    - 最適化した中間言語プログラムから変換後のコードLtを生成

#### 字句解析
- 正則表現を用いて字句の定義を行う
- 正則表現に対応する決定性有限オートマトンを用いてモデル化する
- 実際の解析においてはオートマトンをプログラムとして実装する (Lexなどを使用する)

#### 構文解析
- 文脈自由文法を用いて構文の定義を行う
- 文脈自由文法に基づく解析方法 (下向き構文解析・上向き構文解析etc) を用いてモデル化する
- 実際の解析においては解析方法をプログラムとして実装する (yaccなどを使用する)
- 終端記号 - 字句解析器から送られてくる記号 (= トークン)
- 非終端記号 - 字句解析器から送られて来ず、パーサの中でしか使用されない記号

### C言語のコンパイル手順
1. C言語で書かれたプログラムを解釈し、コンパイラの内部形式で表現する
2. コンパイラの内部形式で表現されたプログラムの最適化を行う
3. 最適化されたプログラムをアセンブリ言語のプログラムに変換する
4. アセンブリ言語のプログラムをアセンブラによって機械語に変換する

```
1. C言語のソースコード <- 字句解析・構文解析
2. 中間表現 <- 最適化
3. 中間表現 <- コード生成($ gcc -S add.c)
4. アセンブリ言語のソースコード <- アセンブル($ gcc -o add.o add.s)
5. 機械語(オブジェクトファイル) <-リンク
5. 機械語(実行ファイル) <- 実行
```

## 参照
- 独習アセンブラ
- コンパイラ入門 構文解析の原理とlex/yacc, C言語による実装
