# プログラムの実行
1. (字句解析) スキャナがソースコードを単語に切り出す
2. (字句解析) スキャナが単語から記号 (識別子) を割り出す
3. (構文解析) パーサジェネレータに文法規則読み込みパーサを生成する
4. (構文解析) パーサで単語と記号の列をツリー状に組み立てる (構文木)
5. (コンパイル) 構文木をバイトコードへコンパイルする
6. (実行) バイトコードをランタイムによって評価する

## プログラミング言語の抽象度
1. 高級言語
2. 中間表現 (バイトコード) - 高級言語のコンパイラ・インタプリタの内部形式・VMで実行される
3. アセンブリ言語
4. 機械語 (オブジェクトファイル) - CPUが直接理解可能

#### バイトコード
- 高級言語と機械語の中間に当たる形式
- 動作させるために、バイトコードを解釈してそのコンピュータの機械語に変換するための仮想マシンが必要
- 命令の並びは構文木ではなく一方向になっている場合が多い

```c
// バイトコード処理系の動作 (C言語)

while(次の命令があるかどうか) {
  命令 = 命令列[プログラムカウンタ];
  実行処理(命令);
}

実行処理(命令){
  switch(命令){
    case 命令1:
      命令1の処理;
      break;
    case 命令2:
      命令2の処理;
      break;
    ...
  }
  プログラムカウンタをインクリメント;
}
```

## コンパイラの動作フロー
1. フロントエンド
    - 変換前のコードを字句解析し、トークン列を生成する
    - トークン列を構文解析・意味解析し構文木/中間言語プログラムを生成する
2. バックエンド
    - 構文木/中間言語プログラムをコード最適化
    - 最適化した中間言語プログラムから変換後のコードLtを生成

#### 字句解析
- 正則表現を用いて字句の定義を行う
- 正則表現に対応する決定性有限オートマトンを用いてモデル化する
- 実際の解析においてはオートマトンをプログラムとして実装する (Lexなどを使用する)

#### 構文解析
- 文脈自由文法を用いて構文の定義を行う
- 文脈自由文法に基づく解析方法 (下向き構文解析・上向き構文解析etc) を用いてモデル化する
- 実際の解析においては解析方法をプログラムとして実装する (yaccなどを使用する)
- 終端記号 - 字句解析器から送られてくる記号 (= トークン)
- 非終端記号 - 字句解析器から送られて来ず、パーサの中でしか使用されない記号

### Cプログラムのビルド手順
1. Cプログラムを解釈し、コンパイラの内部形式で表現する
2. コンパイラの内部形式で表現されたプログラムの最適化を行う
3. 最適化されたプログラムをコンパイラによってアセンブリ言語によるプログラムへ変換する
4. アセンブリ言語によるプログラムをアセンブラによって機械語に変換する

```
1. Cプログラム`.c` <- 字句解析・構文解析
2. 中間表現 <- 最適化
3. 中間表現 <- コード生成 ($ gcc -S add.c)
4. アセンブリ言語のソースコード <- アセンブル ($ gcc -o add.o add.s)
5. 機械語 (オブジェクトファイル) <-リンク
5. 機械語 (実行ファイル) <- 実行
```

## 参照
- 独習アセンブラ
- コンパイラ入門 構文解析の原理とlex/yacc, C言語による実装
- [IT用語辞典 e-Words ： バイトコードとは 【byte code】](http://e-words.jp/w/E38390E382A4E38388E382B3E383BCE38389.html)
- [YARV Maniacs 【第 2 回】 VM ってなんだろう](https://magazine.rubyist.net/articles/0007/0007-YarvManiacs.html)
