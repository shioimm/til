# Thread-Per-Message
- 参照: Java言語で学ぶデザインパターン入門 マルチスレッド編 第7章

## TL;DR
- ClientがHostに対して依頼を渡す
  HostがClientから依頼を受け取り処理を行う
  - Hostは依頼を処理するために毎回新しいスレッドを生成する
- ClientとHostは互いの動作に影響を及ぼさない

### 文脈
- ClientがHostに対して処理を呼び出しているとき

### 問題
- Hostの処理が終わるまで制御がClientに戻らない
- 処理に時間がかかると応答性が下がる

### 解決方法
- Hostの中で新しいスレッドを生成する
- Hostの生成したスレッドが実際の処理を実行する
- ClientはHostに対して処理を呼び出した後、
  Hostの生成したスレッドの処理の実行を待たずに自身の処理に戻る

### 処理の依頼と実行の分離
- 依頼(Client)を行う役と実行を行う役(Host)を分離する
  - 応答性が向上する
  - 実行順序を制御することができる
  - キャンセル・繰り返し実行が可能
  - 分散処理を実現できる

## 要素
### Client
- Hostに対して依頼を渡す

### Host
- Clientからの依頼を受け取り、新しいスレッドを生成して処理を実行する

### Helper
- 処理を実行するためのAPIと実装をHostに提供する

## 適用可能性
- 処理の順序を気にしないとき
- 返り値が不要なとき
  - 処理の結果が必要なときはFutureパターンを使用する
- Webサーバーへの応用
  - クライアントからの処理の依頼gをサーバーが受け取り、
    実際の処理はサーバーが別のスレッドを起動して行う

## パフォーマンス
- Clientに対するHostの応答性が上がり遅延時間が下がる
- スレッドの起動にかかる時間を節約するためにWorkerThreadパターンを使用するケースもある

## 関連するパターン
- Future
  - 処理の返り値が必要な場合(Thread-Per-Messageと組み合わせて使う)
- WorkerThread
  - Hostによるスレッド生成のコストを下げたい場合
