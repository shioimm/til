# Docker
- コンテナのライフサイクルを管理するツールとプラットフォーム
  - コンテナ - Linuxカーネルのnamespaceによって分離された作業空間
  - namespaceの作成、プロセス空間の分離などコンテナを作成するために必要な操作を行う
- Dockerfileからイメージを作る(`$ docker build -t イメージ名`)
  -> イメージからコンテナを起動する(`$ docker run イメージ名`)
  - コンテナ起動時にポートやボリュームの指定を行うことができる

#### 基本動作
- Build - コンテナイメージの作成
  - 材料: Dockerfile + コンテキスト
  - コマンド: `$ docker build`
- Run - コンテナの実行
  - リソースが隔離された実行空間 + プロセスの実行に必要なファイル群 + プロセス
  - コマンド: `$ docker run`
- Ship - レジストリを用いたイメージの配布
  - コマンド: `$ docker pull` + `$ docker push`

## 構成要素
### コンテナ
- イメージから作成され、名前空間によって外部から隔離された特殊なプロセス
- 独立したファイルシステムを持つ
- 削除時に永続的なストレージに保存されていないものは消失する

#### イメージ
- コンテナを実行するためのテンプレート
- ベースとなるコンテナイメージのファイルシステムに新たなレイヤーを重ねることによって作成される

#### イメージの取得
- ベースとなるコンテナとしてシェルを起動し、任意の内容を手動でコミットしてイメージを作成する
- Dockerfileから自動作成する
- Docker Hubから公開されているイメージを取得する

### Docker Engine
- コンテナやイメージを管理するアプリケーション
- Dockerクライアント・Dockerデーモン(サーバー)・コンテナレジストリから構成される
- Dockerクライアント - DockerデーモンはHTTPによって通信を行う

#### コンポーネントの関係
- DockerクライアントがDockerデーモンに処理を依頼する
- DockerデーモンはDockerクライアントからの要求に応じてコンテナレジストリと通信する
- コンテナレジストリはイメージのアップロード、ダウンロードを行う
- Dockerデーモンはコンテナレジストリから取得したイメージを使用してコンテナの構築、実行、配布を行う

#### Dockerクライアント
- Dockerデーモンのユーザーインターフェースとなるコンポーネント
- DockerクライアントはユーザーへのAPIとして`docker`コマンドを提供する

#### Dockerデーモン
- Dockerクライアントからの要求に応じDockerオブジェクトを管理するコンポーネント
  - Dockerオブジェクト - Dockerデーモンの管理の対象となるもの
    - イメージ、コンテナ、ネットワーク、データ・ボリューム
- DockerデーモンはDockerクライアントへのAPIとしてREST APIを提供する

#### コンテナレジストリ
- コンテナイメージを保管するコンポーネント
- Docker Hubはパブリックなコンテナレジストリ

### ボリューム
- コンテナによって読み書きされるデータを永続化するための仕組み
- 同じボリュームを複数のコンテナのファイルシステムへマウントしたり共有することが可能

#### ツール
- Docker Hub         - [コンテナイメージ共有リポジトリ](https://www.docker.com/products/docker-hub)
- Docker Desktop     - デスクトップアプリケーション
- Dockerfile         - Dockerイメージを作成するためのDSLを記述する
- .dockerignore      - ホストに存在しているが、Dockerイメージには組み込みたくないファイル群を記述する
- docker-compose.yml - 複数のコンテナイメージを組み合わせて起動するdocker-composeの設定ファイル

## 仮想マシンとの違い
- 仮想マシン
  - ソフトウェア
  - ホストマシン上でハイパーバイザを利用してゲストOSを動かし、その上でミドルウェアなどを動かす
- Docker
  - プロセス
  - ホストマシンのカーネルを利用し、プロセスやユーザなどを隔離することによって
    別のマシンが動いているかのように動かす
  - ミドルウェアのインストールや各種環境設定はコード化して管理する(IaC)

## 利点
- コード化されたファイルを共有することで、同じ環境を容易に作ることができる
- 作成した環境を容易に破棄したり新たに作成することができる
- 作成した環境を容易に配布できる

## コンテナの状態
- コマンドやコンテナ内のプロセスの終了などをフックしてコンテナの状態が変化する

| 状態     | 説明                                       |
| -        | -                                          |
| 作成     | コンテナが作成された状態                   |
| 実行     | コンテナ内でプロセスが実行されている状態   |
| 停止     | コンテナ内でプロセスが終了している状態     |
| 一時停止 | コンテナ内でプロセスが一時停止している状態 |
| 削除     | コンテナが削除された状態                   |

### ライフサイクル
1. DockerHubからイメージを取得(`$ docker pull`)
2. イメージを元にコンテナ作成・コンテナ上でプロセス起動($`docker run`)
    - コンテナは内部で動作しているプロセスが終了すると休止状態になる
    - コンテナ内部でコマンド実行(`$ docker exec`)
    - コンテナ内部にログイン(`$ docker exec -it`)
3. コンテナ・プロセスを停止(`$ docker stop`)
    - 停止したコンテナを再開(`$ docker start`)
    - 永続化したいコンテナはイメージ化(`$ docker commit`)
    - イメージ化したコンテナをDockerHubにpush(`$ docker push`)
4. コンテナを削除(`$ docker rm`)
5. イメージを削除(`$ docker rmi`)

## Namespace
- 特殊なフラグを指定して実行されるプロセス
- Namespaceの子プロセスはNamespaceのメンバとなる
- DockerはNamespaceを使用してコンテナ同士を隔離する

### コンテナ実行時の動作
1. Dockerデーモンはそのコンテナ専用のNamespaceとなるプロセスを作成する
2. DockerデーモンはNamespaceのメンバとしてコンテナに含まれるプロセスを実行する

### Namespaceの種類

| Namespace | リソース                                 |
| -         | -                                        |
| Mount     | ファイルシステム                         |
| IPC       | プロセス間通信                           |
| Network   | ネットワークインターフェース・ポート番号 |
| UTS       | ホスト名                                 |
| PID       | プロセスID(Linux 3.8~)                   |
| User      | UID / GID(Linux 3.8~)                    |
| Cgroup    | cgroup(Linux4.6~)                        |
| Time      | システムクロックの一部(Linux 5.6~)       |

### control groups
- コンテナごとに利用可能なハードウェアリソースの使用量に上限を設ける機能
- cgroup - 制限の対象となるプロセスの集合
- cgroups - control groups、あるいは複数のcgroup

#### cgroupfs
- control groupsの設定を変更するためのファイルシステムライクなインターフェース
- control groupsは階層構造になっている
  - 上位のcgroupの設定は下位のcgroupへ引き継がれる
  - 下位のcgroupは上位のcgroupによって設定された制限を超えない

## インフラとしてのDocker
- コードとライブラリをパッケージングしてDockerイメージを作り(コンテナ化)、
  運用上同じdockerイメージを利用することによって
  開発環境と運用環境の違いを吸収する
  - コンテナを利用してアプリケーションおよび関連のコンポーネントを開発する
  - コンテナをアプリケーションの配布とテストを行う１つの単位として利用する
  - コンテナ単位あるいはオーケストレーション単位でアプリケーションをデプロイする

## Swarm mode
- Dockerエンジンに設けられたクラスタ管理(複数のマシンをまとめて管理する)機能
- Swarm modeが有効なDockerエンジン = Dockerホスト
- 複数のDockerホストから構成される集合体 = Swarm(クラスタ)
- Swarm内の個々のDockerホスト = ノード
- Docker自身がSwarmと同等の機能を持つKubernetesをサポートしたため
  Dockerにおけるクラスタ管理はKubernetesが主流化

### ノードの役割
- マネージャー - ワーカーを管理してサービスを維持する・Swarmへのエンドポイントとなる
‐ ワーカー - マネージャーからの指示に従ったコンテナを実行する
‐ マネージャー兼ワーカー

### サービス
- Swarm内で実行するコンテナのコンテナイメージ、コンテナ内で実行するコマンドなどの指示
- マネージャーはユーザーのサービス定義に基づいてコンテナを実行する
  - タスク - ワーカーで実行されるコンテナであり、マネージャーがサービスとして管理する最小単位

## 参照
- [Docker](https://www.docker.com/)
- [Docker 概要](https://docs.docker.jp/get-started/overview.html)
- [Docker入門（第一回）～Dockerとは何か、何が良いのか～](https://knowledge.sakura.ad.jp/13265/)
- [Docker入門（第二回）～Dockerセットアップ、コンテナ起動～](https://knowledge.sakura.ad.jp/13795/)
- [Docker入門（第四回）～Dockerfileについて～](https://knowledge.sakura.ad.jp/15253/)
- [Dockerイメージの理解とコンテナのライフサイクル](https://www.slideshare.net/zembutsu/docker-images-containers-and-lifecycle)
- [【連載】世界一わかりみが深いコンテナ & Docker入門 〜 その2:Dockerってなに？ 〜](https://tech-lab.sios.jp/archives/19073)
- [Rails on Docker](https://speakerdeck.com/sinsoku/rails-on-docker)
- 仮想化&コンテナがこれ1冊でしっかりわかる教科書
- イラストでわかるDockerとKubernetes
