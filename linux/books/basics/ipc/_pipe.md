# パイプ
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信
- 参照: Linuxネットワークプログラミング Chapter7 プロセス間通信 7-7
- 参照: Linuxによる並行プログラミング入門 第4章 リダイレクトとパイプ 4.5
- 参照: Linuxプログラミングインターフェース 44章

## TL;DR
- 共通先祖を持つプロセス間でのデータ通信機構
  - 親子プロセス、親孫プロセス、兄弟プロセス
- パイプの実体はカーネルが管理するバッファ
- プロセスはパイプへ読み書きするためのファイルディスクリプタを持つ
- プロセスからのファイルディスクリプタが全てクローズされるとパイプは消滅する

```
データの流れ

プロセスの書き込み用ファイルディスクリプタ
  -> カーネル内のパイプの読み込み端点(ファイルディスクリプタ)
  -> カーネル内のパイプの書き込み端点(ファイルディスクリプタ)
  -> プロセスの読み込み用ファイルディスクリプタ
```

- 一般にシェルコマンドを実行しその出力を読み取るか、入力を与える用途に使用される
- コマンドラインのパイプ(`|`)もパイプの仕組みを利用している

## パイプの性質
### バイトストリーム
- メッセージ区切りが存在しない
- パイプを読み取るプロセスは書き込みプロセスが書き込んだブロックサイズとは無関係に
  任意のバイトサイズのデータブロックを読み取る
- バイトストリームは書き込んだ順に読み取られる

### バッファ
- パイプのバッファが上限に達している状態で書き込もうとした場合、
  またはパイプのバッファが空の状態で読み込もうとした場合、
  読み書きができるようになるまで操作がブロックされる
- 読み取りプロセスはパイプ内の全データを読み取り後、EOFを読み取る
- 複数プロセスが同じパイプへ書き込んでも書き込みデータは混ざらない
  (`PIPE_BUF`を超えない限り)

#### `PIPE_BUF`
- 4096バイト
- サイズが`PIPE_BUF`より大きなデータをパイプへ書き込む場合、
  カーネルはデータを分割し、読み取りプロセスがパイプからデータを読み取り後に
  後続データを転送する
  - 複数プロセスが書き込みを待っている場合、分割時にデータが混ざる可能性がある

### 単方向性
- パイプのデータの流れは入力 -> 出力の一方通行(半二重)

### ファイルディスクリプタ
- プロセスがパイプに対して作成するファイルディスクリプタの値は
  その時点で最も小さい値を順に適用する
  - Ex.パイプを開いた時点で標準入出力がクローズされていた場合、
    プロセスの標準入出力をパイプへ変更することができる

## パイプの作成と使用
```
Ex. 親プロセス -> 子プロセスへの通信を行う場合

1. 親プロセスがカーネル内にパイプを生成
    - 親プロセスは生成したパイプへの読み書きファイルディスクリプタを得る
2. 親プロセスが`fork`する
    - 親プロセスの持つファイルディスクリプタをコピーする子プロセスが生成される
3. 親プロセスが読み取りファイルディスクリプタを閉じる
4. 子プロセスが書き込みファイルディスクリプタを閉じる
5. 親プロセスがパイプへ書き込む -> 子プロセスがパイプから読み取る
```

## API
### `pipe(2)`
- パイプを作成する
- パイプへの読み書きファイルディスクリプタを要素に持つ配列を取得する

#### 引数
- `filedes[2]`を指定する
  - `filedes[2]`- パイプへの読み書きディスクリプタを格納するための配列

#### 返り値
- 数値0を返す
  - エラー時は数値-1を返す

### `*popen(3)`
- 内部でパイプと子プロセスを作成し、シェルを実行する
  - プロセスがパイプを作成
    -> `fork`
    -> 子プロセスが使用しないパイプの端点を閉じてシェルを起動
    -> シェル上でコマンドを`exec`
- 自プロセスは`popen(3)`実行後、パイプからコマンドの出力を読み取るか、
  パイプへコマンドの入力を書き込む
  - コマンドがパイプの書き込み端点をクローズすると、パイプからの読み取りはEOFを返す
  - コマンドがパイプの読み取り端点をクローズすると、パイプからの書き込みは`EPIPE`となる
- `*popen(3)`が返すファイルストリームにはブロックバッファリングが適用される

#### 引数
- `*command`、`*mode`を指定する
  - `*command` - 実行するシェルコマンドを示す文字列へのポインタ
  - `*mode` - 自プロセスがパイプから読み取るか書き込むかのフラグを示す文字列へのポインタ
    - `r` - コマンドの標準入力をパイプの読み取り端点とする
    - `w` - コマンドの標準出力をパイプの書き込み端点とする

#### 返り値
- ファイルストリームを返す
  - エラー時はNULLを返す

### `pclose(3)`
- `popen(3)`で開いたパイプをクローズし、子プロセスの終了を待つ

#### 引数
- `*stream`を指定する
  - `*stream` - `popen(3)`が返したファイルストリームへのポインタ

#### 返り値
- 子プロセスの終了ステータスを返す
  - エラー時は数値-1を返す

## 使用上の注意
- 閉じたパイプへの読み書き
  - 書き込みプロセスがファイルディスクリプタを閉じた後、読み取りプロセスが読み取る
    -> EOFが発生する
  - 読み取りプロセスがファイルディスクリプタを閉じた後、書き込みプロセスが書き込む
    -> `EPIPE`エラーが発生 -> `SIGPIPE`が発生する
- ファイルディスクリプタの閉じ忘れ
  - 読み取りプロセスによる書き込みファイルディスクリプタの閉じ忘れ
    -> 読み取り後もEOFが発生せず、readがブロックされる
  - 書き込みプロセスによる読み取りファイルディスクリプタの閉じ忘れ
    -> パイプのバッファが溢れ、writeがブロックされる
