# シグナルハンドラ
- 参照: 例解UNIX/Linuxプログラミング教室P323-374
- 参照: 詳解UNIXプログラミング第3版 10. シグナル
- 参照: Linuxプログラミングインターフェース 20章 / 21章

## TL;DR
- プロセスが指定のシグナルを受信した際に実行される関数
  - プログラムの処理の流れに任意の時点で割り込む形で実行される
  - プロセスの代わりにカーネルがシグナルハンドラをコールし、
    関数が終了すると割り込んだ下に位置へ制御を戻す
  - シグナルの捕捉 - シグナルハンドラを使ってシグナルを処理すること
- 捕捉されたシグナルをプロセスで処理するとき、
  プロセスが実行中の命令列はシグナルハンドラによって一時的に中断される
  -> シグナルハンドラから戻ると元々プロセスが実行していた命令列に戻る
  - プロセスが非同期シグナル安全な関数を実行していた場合、
    シグナルによって一貫性を失うときはシグナルをブロックする
  - スレッドごとに`errno`の値は一つしかないため、
    シグナルハンドラが再入可能な関数を呼ぶと、
    値が上書きされる可能性がある

## シグナルマスク
- 各プロセスが現在ブロックしているシグナルセット
- シグナルマスクに含まれるシグナルが送信された場合、
  該当のシグナルがシグナルマスクから削除されるまでシグナルの処理がブロックされる
- シグナルマスクはスレッド属性であり、スレッドごとに独立した値を設定・参照可能

### シグナルマスクへの追加
- シグナルハンドラ実行時、その契機となったシグナルは自動的にシグナルマスクへ追加される
  - `sigaction(2)`設定時のフラグによって回避可能
- `sigaction(2)`によりシグナルハンドラ設定時、ハンドラ実行時にブロックするシグナルセットを指定できる
- `sigprocmask(2)`を呼ぶことにより明示的にシグナルマスクを設定できる
  - シグナルに対するビットがON = シグナルをブロックしている

### シグナルの保留
- ブロック中のシグナルを送信すると、プロセスの保留シグナルへ追加される
  ブロック中のシグナルをアンブロックすると、プロセスがシグナルを受信する
- 保留シグナルを明示的に得るためには`sigpending(2)`を使用する
- 保留シグナルはビットマスクであり、送信されたかどうかのみを表す
  複数回同じシグナルが送信されても、保留解除後に受信するシグナルは一回のみ
  - 上記は標準シグナルの挙動
  - リアルタイムシグナルはキューイングされる
  - プロセスがシグナルをブロックしていなくても、受信シグナルがカーネルにより
    スケジューリングされる前に複数回同じシグナルが送信されると同様の挙動になる

## シグナルの待機
- `pause(2)`を明示的に呼ぶことでシグナルハンドラが実行されるまで自プロセスの実行を停止する
  - または補足しないシグナルによってプロセスが終了されられるまで

## シグナルハンドラの設計方針
#### A.グローバルフラグのセット後、終了
- シグナルハンドラにおいてはグローバルフラグをセットする処理のみを行いそのまま終了させる
  メインプログラムは定期的にグローバルフラグを確認し、セットされていれば対応処理を実行する

```c
// メインプログラムとシグナルハンドラで共有するグローバルフラグの宣言
volatile sig_atomic flag;
```

#### B. クリーンアップ処理後、終了
- シグナルハンドラにおいてはクリーンアップを行う処理のみを行いそのまま終了させる
  またはスタックを巻き戻し、メインプログラムの決められた位置へグローバルジャンプする

## シグナルハンドラの実装方針
- (A) ハンドラ自身がリエントラントであることを保証し、非同期シグナルセーフな関数のみを使用する
- (B) メインプログラムが次の処理を実行している場合はシグナルをブロックする
  - 非同期シグナルセーフではない関数
  - ハンドラも変更するグローバルデータの更新

### 非同期シグナルセーフ関数
- シグナルハンドラが実行しても安全であることが保証されている関数
  - リエントラントな関数
  - シグナルハンドラに割り込まれない関数
- 非同期シグナルセーフ関数でも実行時に`errno`を上書きする危険がある
  -> 処理の冒頭に`errno`を退避させ、終了時に復元させるようにする

## シグナルハンドラの終了
- メインプログラムへ制御を戻す
- `_exit()`を実行しプロセスを終了させる
  - 事前にクリーンアップ処理を行う
  - `exit()`は非同期シグナルセーフではない
- `kill()` / `raise()`を実行しプロセスを終了させるシグナルを送信する
- シグナルハンドラ内からグローバルジャンプする
  - シグナルマスクの保存や回復を行う必要がある
  - シグナル発生後、シグナルハンドラによって元の処理を繰り返し呼び出すような場合に
    グローバルジャンプを用いることで問題の処理を迂回する
- `abort()`を実行しプロセスをコアダンプ後終了させる

## シグナル処理専用スタック
- プロセスのスタックとプロセスのシグナル処理専用スタックを分けることができる
  - プロセスのスタックサイズの上限を超えてスタックフレームを作成しようとすると
    `SIGSEGV`が発生する
    `SIGSEGV`を処理するシグナルハンドラが設定されている場合、
    プロセスはスタック上にフレームを作成することができない
    - シグナルハンドラが使用するスタックフレーム用に
      シグナル処理専用スタックのメモリを割り当てる
    - `sigaltstack(2)`によりシグナル処理専用スタックの存在を
      カーネルへ通知する
    - シグナルハンドラ設定時に`SA_ONSTACK`フラグを設定することで
      ハンドラのフレームを別スタック上に作成するようカーネルへ通知する

## システムコールへの割り込み・再開
- 特定のシステムコールにおいては、割り込み後プロセスがシグナルごとに自動的に再起動を行う
  - `ioctl(2)` / `read(2)` / `readv(2)` / `write(2)` / `writev(2)` / `wait(2)` / `waitpid(2)`
- プロセスがシグナルごとに自動再起動を停止することもできる

```
1. あるシグナルを補足するハンドラを設定
2. ブロッキングなシステムコールを実行
3. システムコールがブロック中にシグナルを受信 -> ハンドラが実行
```

- デフォルトでは`EINTR`エラーを返す
- 割り込まれたシステムコールをエラーとせず、
  シグナルハンドラ実行後にシステムコールへ制御を戻したい場合は
  システムコールをループ処理の条件として呼び、`continue`で処理を継続させる

```
while ((cnt = read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR) {
  continue();
}

if (cnt == -1) {
  perror("read()");
}

// GNU CライブラリではTEMP_FAILURE_RETRY()マクロで同様の操作ができる
// __GNU_SOURCEのマクロ定義は必要
```

- あるいは、`sigaction(2)`でシグナルハンドラを設定する際に
  `SA_RESTART`フラグを明示的に指定する
