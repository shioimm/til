# プロセススケジューリング
- 参照: 例解UNIX/Linuxプログラミング教室P185-224
- 参照: 詳解UNIXプログラミング第3版 7. プロセスの環境 / 8. プロセスの制御 / 9. プロセスの関係
- 参照: Linuxプログラミングインターフェース 2章 / 35章

## ラウンドロビンタイムシェアリング
- Linuxにおけるデフォルトのスケジューリングモデル
- 全プロセスを順番に、決められた時間(タイムスライス)ずつCPU上で実行する
- 公平性(全プロセスにCPUを与える) / 応答性(プロセスをCPU待ち状態で長時間待たせない)

## nice値
- カーネルスケジューラが優先度の高いプロセスをよりスケジューリングしやすくするためのプロセス属性
- 数値-20から+19
  - 数値が小さい方ほどスケジューリング優先度が高い
  - デフォルトは数値0
  - 数値-20から0は伝統的にトッッケンプロセスのみが使用可能
- 子プロセスは親プロセスからnice値を継承する

## プリエンプションが発生する可能性のある動作
- ブロックしていた高優先度のプロセスのブロックが終了したとき
- 他のプロセスの優先度が現在実行中のプロセスよりも高く引き上げられたとき
- 人材実行中のプロセスの優先度が他の実行可能プロセスよりも低く引き下げられた

## リアルタイムプロセススケジューリング
- リアルタイムアプリケーションにおいては
  - 外部入力への最長応答時間を保証する
    - 高優先度のプロセスは実行中のプロセスから奪ってでも(プリエンプション)
      時間に基づいたスケジューリングを実行しCPUを与える必要がある
  - 高優先度のプロセスは自身の処理を完了するか自発的にCPUを手放すまでCPUを占有できる
  - アプリケーションは自身のコンポーネントプロセスのスケジューリングを厳密に制御できる
- リアルタイムアプリケーションにおけるスケジューリングの要求に応じるため
  リアルタイムスケジューリングAPIと
  プロセス毎に設定できるリアルタイムスケジューリングポリシーが用意されている

### リアルタイムスケジューリングポリシー
- `SCHED_RR`
  - ラウンドロビンタイムシェアリングに実行される(タイムスライスあり)
- `SCHED_FIFO`
  - ラウンドロビンタイムシェアリングに実行される(タイムスライスなし)
    - タイムスライスがないため、プロセスは自発的にCPUを手放すか、終了するか、
      高優先度のプロセスにプリエンプトされるまでCPUを占有する
- `SCHED_OTHER`
  - デフォルトのスケジューリングポリシー
- `SCHED_BATCH`
- `SCHED_IDLE`

### リアルタイムプロセスの優先度
- 数値1から99
  - 数値が大きいほどスケジューリング優先度が高い
- `SCHED_RR` / `SCHED_FIFO`どちらのスケジューリングポリシーでも共通

### リアルタイムプロセスが発生させるシステムロックの防止
- `setrlimit(2)`によりCPUリソース消費制限のソフトリミットを低めに設定する
- `alarm(2)`によってタイマーを設定する
- プロセスの終了を監視するための高優先度のリアルタイムプロセス(watch dog)を別途作成する

### リアルタイムプロセスがCPUを手放すケース
- `SCHED_RR`においてタイムスライスを使い切る
- ブロックするシステムコールを呼ぶ
- `sched_yield(2)`を呼ぶ

## CPUアフィニティ
- プロセススケジューリング時、前回プロセスを実行したCPUがビジーな場合、
  別のCPUでプロセスが実行される
- プロセスを実行するCPUを変更すると性能が低下する
  - 前回実行した際のキャッシュが前のCPUに残っている場合、
    一度キャッシュを無効にして新しいCPUのキャッシュヘロードし直す
- キャッシュ無効化のコストは高いため、Linux2.6カーネルでは
  プロセスのソフトCPUアフィニティの維持を優先し、可能なら前回と同じCPUにスケジューリングする
- 明示的にCPUアフィニティを指定する場合は`sched_setaffinity(2)`を使用する
