# 多重IO
- 参照: Linuxプログラミングインターフェース 63章

## TL;DR
- 複数のファイルディスクリプタをIO可能になるまで監視する
- `select(2)` - BSD由来
- `poll(2)` - System V由来
- レベルトリガ通知を使用可能

## 内部動作
- `select(2)` / `poll(2)`は監視対象ファイルディスクリプタをカーネルへ指定する
- カーネルはIO可能になったファイルディスクリプタを示すようにデータを変更し、ユーザー空間へ返す
- 実行のたびに監視対象ファイルディスクリプタの全てをユーザー空間とカーネル空間で転送し、結果を確認する

## API
### `select(2)`
- 指定したファイルディスクリプタのうち一つ以上がIO可能になるまでブロックする
- ファイルディスクリプタセット`*readfds` / `*writefds` / `*exceptfds`に処理結果を格納する
  - リターン時にはファイルディスクリプタセットにIO可能なファイルディスクリプタのみが残される
  - ループ内で`select(2)`を使用する場合は毎回ファイルディスクリプタセットの初期化・設定が必要
- `pselect(2)` - ブロック中にアンマスクするシグナルを指定したい場合
- [Linux2.6.27~]`signalfd` - シグナルとファイルディスクリプタを同時に監視する場合

#### ファイルディスクリプタセット
- 監視対象のファイルディスクリプタは`fd_set`型で実装される
- `fd_set`はビットマスクで実装され、操作はマクロで行う
  - `FD_ZERO(fd_set *fdset)`
    - `fdset`に指定されたファイルディスクリプタセットを空に初期化する
  - `FD_SET(int fd, fd_set *fdset)`
    - `fdset`に`fd`を追加する
  - `FD_CLR(int fd, fd_set *fdset)`
    - `fdset`から`fd`を削除する
  - `FD_ISSET(int fd, fd_set *fdset)`
    - マクロはいずれも`fdset`内に`fd`がセットされていれば数値1、そうでない場合は数値0を返す

#### 引数
- `nfd`、`*readfds`、`*writefds`、`*exceptfds`、`*timeout`を指定する
  - `nfd` - 監視対象のファイルディスクリプタ数
  - `*readfds` - 読み取り監視対象のファイルディスクリプタセットへのポインタ
  - `*writefds` - 書き込み監視対象のファイルディスクリプタセットへのポインタ
  - `*exceptfds` - 例外監視対象のファイルディスクリプタセットへのポインタ
    - パケットモードの疑似端末のマスタデバイスへ接続されたスレーブデバイスの状態変化
    - ストリームソケットに帯域外データが届いた
  - `*timeout` - `select(2)`がブロックする時間の上限を示す`timeval`構造体へのポインタ
    - 時間によってブロックしない場合は`timeval`構造体の各フィールドに数値0を指定する

#### 返り値
- IO可能になったファイルディスクリプタ数を返す
  - 同じファイルディスクリプタが読み書き両用かつ読み書き可能になった場合1つ分カウントされる
  - タイムアウト時は数値0を返す
  - エラー時は数値-1を返す

### `poll(2)`
- 指定したファイルディスクリプタのうち一つ以上がIO可能になるまでブロックする
- 監視内容を表す`pollfd`構造体に処理結果を格納する
- [Linux2.6.16~]`ppoll(2)` - ブロック中にアンマスクするシグナルを指定したい場合

#### 監視・返却可能イベント
| フラグ     | `events` | `revents` | 説明                                         |
| -          | -        | -         | -                                            |
| `POLLIN`   | 可能     | 可能      | 高優先度データ以外の通常データを読み取り可能 |
| `POLLOUT`  | 可能     | 可能      | 通常データを書き込み可能                     |
| `POLLPRI`  | 可能     | 可能      | 高優先度データを書き込み可能                 |
| `POLLDHUP` | 可能     | 可能      | ピアソケットがクローズされた                 |
| `POLLHUP`  | -        | 可能      | ハングアップ発生                             |
| `POLLERR`  | -        | 可能      | エラー発生                                   |

#### 引数
- `fds[]`、`nfds`、`timeout`を指定する
  - `fds[]` - `pollfd`構造体の配列
  - `nfds` - `fds`配列の要素数
  - `timeout` - ブロック動作を指定する数値
    - 数値-1 - 対象のファイルディスクリプタが一つでもIO可能になるまで動作をブロック
    - 数値0 - ブロックしない・対象のファイルディスクリプタがIO可能か検査する
    - 正の値 - ミリ秒単位のタイムアウト時間

```c
struct pollfd {
  int   fd;      // 対象のファイルディスクリプタ
  short events;  // 監視イベントビットマスク
  short revents; // 発生イベントビットマスク(発生したイベントを格納する)
};
```

#### 返り値
- IO可能になったファイルディスクリプタ数を返す
  - 同じファイルディスクリプタが読み書き両用かつ読み書き可能になった場合2つ分カウントされる
  - タイムアウト時は数値0を返す
  - エラー時は数値-1を返す

## IO可能判定
#### 通常ファイル
- 常に読み取り・書き込み可能

#### 端末・疑似端末

| イベント                                                             | `select(2)`  | `poll(2)`  |
| -                                                                    |-             | -          |
| 読み取り可能                                                         | `r`          | `POLLIN`   |
| 書き込み可能                                                         | `w`          | `POLLOUT`  |
| ピア疑似端末がクローズした                                           | `rw`         | `POLLHUP`  |
| パケットモードの疑似端末マスタデバイスがスレーブの状態変化を検知した | `rw`         | `POLLHUP`  |

#### パイプ・FIFO
- 読み取り口に対する動作

| パイプ内にデータがある | 書き込み口がオープン中 | `select(2)` | `poll(2)`            |
| -                      | -                      | -           | -                    |
| no                     | no                     | `r`         | `POLLHUP`            |
| yes                    | yes                    | `r`         | `POLLIN`             |
| yes                    | no                     | `r`         | `POLLIN` / `POLLHUP` |

- 書き込み口に対する動作

| 空き領域サイズが`PIPE_BUF`以上 | 読み取り口がオープン中 | `select(2)` | `poll(2)`             |
| -                              | -                      | -           | -                     |
| no                             | no                     | `w`         | `POLLERR`             |
| yes                            | yes                    | `w`         | `POLLOUT`             |
| yes                            | no                     | `w`         | `POLLOUT` / `POLLERR` |

#### ソケット

| イベント                                               | `select(2)` | `poll(2)`                         |
| -                                                      |-            | -                                 |
| 読み取り可能                                           | `r`         | `POLLIN`                          |
| 書き込み可能                                           | `w`         | `POLLOUT`                         |
| リスニングソケットが接続要求を確立した                 | `r`         | `POLLIN`                          |
| 帯域外データを受信した(TCP)                            | `w`         | `POLLOUT`                         |
| ピアストリームソケットがクローズされた / `shutdown(2)` | `rw`        | `POLLIN` / `POLLOUT` / `POLLDHUP` |

## 性能差
- 監視対象のファイルディスクリプタの値が密集している場合、性能差はほとんど出ない
- 監視対象のファイルディスクリプタの値が密集していない場合、顕著に`select(2)`が遅くなる
  - `select(2)`は監視対象の全ファイルディスクリプタセット内を
    監視対象のファイルディスクリプタ数分スキャンする必要がある
  - `poll(2)`は対象のファイルディスクリプタのみをスキャンすることができる

## 問題点
- 大量のファイルディスクリプタの監視には不向き
  - カーネルは`select(2)` / `poll(2)`実行のたびに指定の全てのファイルディスクリプタを検査する
  - プログラムは`select(2)` / `poll(2)`実行のたびに監視対象のファイルディスクリプタをカーネルへ指定する
    - システムコール実行後はカーネルが更新したデータを確認する
  - プログラムは`select(2)` / `poll(2)`実行後に返された情報を全て確認する
- `select(2)` / `poll(2)`の問題の原因は、カーネルが内部で直接ファイルディスクリプタ群を管理していない点
  - シグナルドリブンIO / `epoll(2)`ではカーネルが内部にファイルディスクリプタ群を保持する
