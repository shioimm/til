// 引用: ふつうのLinuxプログラミング
// 第11章 プロセスとハードウェア 1

// デバイス
//   全てのデバイスはバスで接続されている
//
//   メモリ
//     ビットの列を8ビット(1バイト)単位で記憶する
//     バイトごとに位置を示す番号を振っている(メモリアドレス)
//
//   CPU
//     メモリ上にあるプログラム(機械語)に従って
//     メモリに記憶されているバイト列を変化させる
//
//       機械語の持つ命令
//         メモリからバイトを読む
//         メモリにバイトを書く
//         四則演算
//         ビットシフト
//         原始的な条件分岐
//
//       レジスタ
//         CPU内部にある変数のような機構
//         メモリからデータをコピーし、演算してメモリに戻す
//
//   HDD/SSD
//     メモリと同様の記憶領域
//     一定のバイト単位でしかデータをやりとりできない
//     電源を切ってもデータが保存される
//     容量が大きい
//     遅い
//
//  全てのコンピュータにはCPUとメモリがある
//  メモリとCPUはバスを経由してビット列をやり取りする

// コンピュータアーキテクチャ
//   x86
//     AMD64 / x86-64 / x64 - 64ビットアーキテクチャ
//   ARMアーキテクチャ

// プロセス
//   動作中のプログラム
//   一つのCPU / 一つのメモリで一つのプロセスが動作する
//
//   仮装CPU
//     短い時間単位(タイムスライス)で実行するプロセスを複数切り替えることにより
//     一つのCPUを複数のCPUであるかのように扱う
//
//       スケジューラ
//         プロセスの優先順位に応じて
//         プロセスにいつタイムスライスを与えるかを管理する機構
//
//   仮想メモリ
//     プロセスから見えるメモリアドレスを論理アドレス
//     実際のメモリアドレスを物理アドレスとして
//     プロセスごとに独立したアドレス空間を確保する(ページ単位)
//
//     論理アドレス確保時点では物理アドレスに割り当てておく必要はない
//     (必要になった時点で割り当てられる)
//     そのため、アドレス空間のサイズは実際のPCに搭載されているメモリサイズよりも大きい
//     (約172億GB)
//
//     ページング
//       HDDやSSDなどのストレージを物理メモリの代わりに使用する機構
//         1. 使われていないページをストレージに記録して論理アドレスとの対応を解除
//         2. プロセスがページにアクセスした際、カーネルが該当のプロセスを停止
//         3. ストレージからページを読み込み、論理アドレスに対応づけてプロセスを再開
//
//     メモリマップトファイル
//       ファイルをメモリとしてアクセスできるようにする仕組み
//       メモリを読む     <-> ファイルを読む
//       メモリに書き込む <-> ファイルに書き込む
//         1. 論理アドレスと物理アドレスの対応を切っておく
//         2. プロセスがメモリにアクセスをした際、カーネルがファイルをメモリに読み込み
//            論理アドレスと物理アドレスを対応づける
//         3. プロセスがメモリを使い終わった事を通知
//         4. 論理アドレスと物理アドレスの対応を切り、メモリの内容をファイルに書き戻す
//
//     共有メモリ
//       特定範囲の物理メモリを複数プロセスで共有する機構
//       一つの物理メモリを複数の論理メモリに対応づける

// アドレス空間の構造
//   テキスト領域
//     プログラムが置かれる
//   データ領域
//     グローバル変数、初期化済みのスタティック変数、文字列リテラルなどが置かれる
//   BSS領域
//     グローバル変数、初期化が必要ないスタティック変数などが置かれる
//   ヒープ領域
//     malloc()が管理する領域
//   スタック領域
//     関数呼び出しに伴って必要になるデータが置かれる(引数、変数)
