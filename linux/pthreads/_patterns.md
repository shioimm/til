# デザインパターン
- 参照: Linuxとpthreadsによるマルチスレッドプログラミング入門 Chapter7

## エージェントパターン
### 場面
- 単一のリソースに対して複数のスレッドが同時にアクセスし、
  同時にデータを書き換える可能性がある場合

### 解決策
- リソースにアクセスするスレッドを一つに限定し(エージェント)、
  他のスレッドはエージェントへ処理を依頼するようにする

### メリット
- リソースに対する動作排他を行う必要がなくなる

### デメリット
- 依頼した処理の結果を受け取る場合に処理が複雑化する

#### 対策
- 処理が完了した際に呼び出されるコールバック関数を処理要求のパラメータに加える
- 処理要求をキューに積む際に要求番号を発行し、番号ごとに処理結果を問い合わせる関数を作る
- 処理完了鵜を知らせる条件変数を用愛いし、条件待ちを行う

### 注意点
- エージェントスレッドに依頼を行う関数をスレッドセーフにする

## ワーカーパターン
### 場面
- Webサーバーなどで複数のクライアントからの処理要求に同時に対応する場合

### 解決策
- 受付スレッドと実行スレッドを分ける
  - クライアントからの接続を待ち続けるスレッド(マスター)は、接続があるたびに新たなスレッドを作る
  - 作ったスレッドにソケットハンドルを引き渡し、マスターは次の接続を待つ

## スレッドプールパターン
### 場面
- Webサーバーなどで複数のクライアントからの処理要求に同時に対応する必要があり、
  ワーカースレッドを動的に生成しない場合
- エージェントパターンを使用し、コールバックを使用する場合で
  エージェント自身にコールバックを実行させたくない場合

### 解決策
- ワーカースレッド予め一定数用意しておく

## 待ち合わせ
### 場面
- マルチスレッドプログラミングにおいて、
  他のスレッドの処理が一定段階まで進むのを待ってから自スレッドの処理を先に進めたい場合

### 解決策
- 待ち合わせのための関数を使用する
  - `pthread_barrier_init(3)`
  - `pthread_barrier_destroy(3)`
  - `pthread_barrier_wait(3)`
