# 疑似端末
- 参照: Linuxプログラミングインターフェース 64章

## TL;DR
- IPCチャネルの一種である仮想的なデバイス
- チャネルの片方の口は端末へ接続するプログラム、
  もう片方の口は端末上での動作を想定したプログラム(端末指向プログラム)
  - 端末指向プログラム - ユーザー入力を端末へ書き込み、端末からの出力を読み取る

### 疑似端末ペア
- 疑似端末マスターデバイス / 疑似端末スレーブデバイスの組み
- 疑似端末ペアは双方向のIPCチャネルを持つ
  - 2プロセスがマスターデバイス・スレーブデバイスをそれぞれオープンし、
    疑似端末を介して双方向にデータを送受信する

### 疑似端末の使用方法
1. ドライバプログラムが疑似端末マスターデバイスをオープン
2. ドライバプログラムは`fork(2)`を実行し、子プロセスを作成
3. 子プロセスは`setsid(2)`を実行し、新規セッションを開始
4. 子プロセスは疑似端末マスターデバイスに対応する疑似端末スレーブデバイスをオープン
5. 子プロセスは`dup(2)`を実行し、スレーブデバイスのファイルディスクリプタを標準入出力へ複製する
6. 子プロセスは`exec(2)`を実行し疑似端末スレーブデバイスへ接続した端末指向プログラムを実行する

## 擬似端末(pseudo terminal)
- アプリケーションプログラムには端末のように見えるが、実際の端末ではない
- ファイルディスクリプタ(マスター)とファイルディスクリプタ(スレーブ)の間を
  パイプ二本で双方向通信させ、パイプのスレーブ側の一端に端末ラインディシプリンをつけたもの
  - スレーブ側に書いたデータはマスター側から読める
  - マスター側に書いたデータはスレーブ側から読める
  - スレーブ側のファイルディスクリプタは端末に見える(`isatty(3)`は真を返す)
- `posix_openpt(3)` - 疑似端末マスターデバイスをオープンする
- `grantpt(3)` - 擬似端末スレーブへのアクセスを許可
- `ptsname(3)` - 擬似端末スレーブの名前を取得する
- `unlockpt(3)` - 擬似端末マスター / スレーブのペアのロックを解除する

### 配置
- プロセスは擬似端末のマスター側をオープンして`fork`する
- 子プロセスは新たなセッションを確立し、擬似端末のスレーブ側をオープンし、端末ラインディシプリンをつけて`exec`
- マスター側に書いたものはスレーブ側の入力、スレーブ側に書いたものはマスター側の入力として扱われる

### 利用例
- ネットワークログインサーバー
- ウィンドウシステム端末エミュレーション
- `script(1)`
- `expect(1)`
- 長時間実行プログラムの出力監視

### 擬似端末を使う手順
1. 擬似端末マスター(`/dev/ptmx`)を開く(`open`)
2. 擬似端末スレーブを`chomod` / `chown`でアクセスできるようにする(`grantpt`)
3. 擬似端末の内部的なロックを解除(`unlockpt`)
4. 擬似端末スレーブのファイル名を取得(`ptsname`)
5. 擬似端末スレーブを開く(`open`)

### 高度な機能
- パケットモード
  - マスター側がスレーブ側の状態変化を感知できるようになる
- リモートモード
  - スレーブ側をリモートモードに設定する
  - スレーブはマスターから受け取ったデータの処理を行わない
- ウィンドウサイズの変更
- シグナル生起
  - マスターからスレーブのプロセスグループへシグナルを送る
