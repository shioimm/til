# 非局所脱出
- 参照: 例解UNIX/Linuxプログラミング教室P433-448

## TL;DR
- 深い関数呼び出しの入れ子からプログラムの実行制御を一気にリターンさせる機能
  - goto文     - 関数の中でのみジャンプ可能
  - 非局所脱出 - 関数の範囲を超えてジャンプ可能(ただしリターンする方向だけ)

### スタックフレーム
- 関数呼び出し一回分に必要なデータを格納するスタック領域
  - 局所変数、関数の引数、関数の返り値、戻り番地、レジスタを対比した値などを格納
- 関数が呼び出されるたびスタック上にプッシュされ、関数がリターンされるたびスタック上からポップされる

## 仕組み
1. `setjmp`呼び出し
2. レジスタ値を`jmp_buf env`にコピー
    - `setjmp`の戻り番地(プログラムカウンタの値として保存)
    - スタックポインタ
    - `longjmp`時に`setjmp`の場所に実行を移すため必要となるレジスタ値
3. `longjmp`呼び出し
4. 保存しておいたレジスタ値を元に戻す
    - スタックポインタを元に戻すことでスタックフレームを一気にポップする
5. `setjmp`の続きから処理を再開する

## 操作
###ジャンプ先の登録 / 脱出
- `setjmp(3)` - `setjmp(3)`を呼び出した位置をジャンプ先として登録
  - `jmp_buf env`を引数に渡し、プログラムカウンタとスタックポインタを含むいくつかのレジスタの値を保存
  - `jmp_buf env`に格納したレジスタの値(スタックフレーム)は`longjmp(3)`した時点で破棄される
    - `jmp_buf`はプラットフォームごとに必要なデータサイズで用意された配列型
- `longjmp(3)` - 登録されたジャンプ先へ非局所脱出
  - `setjmp(3)`で格納したレジスタのデータをレジスタに回復する
  - ジャンプした後は`setjmp(3)`から返ってきたように処理が継続する
  - 自動変数やレジスタの値は`setjmp(3)`した時の値に戻ることがある
    - `volatile`をつけると元に戻らないことを保証する
    - 確実に元に戻す方法はない

### シグナルハンドラ中のジャンプ先の登録 / 脱出
- シグナルハンドラ中は、非局所脱出においてもシグナルマスクの保存や回復を行う必要がある
- シグナル発生後、シグナルハンドラによって元の処理を繰り返す呼び出すような場合に
  非局所脱出で問題の処理を迂回する
- `sigsetjmp(3)`  - シグナルマスクも保存する`setjmp`
  - `sigjmp_buf env`と`int savemask`を引数に渡す
  - `sigjmp_buf`はシグナルマスクを保存できる`jmp_buf`型
  - `savemask`が0でない場合にシグナルマスクを保存する
- `siglongjmp(3)` - シグナルマスクも回復する`longjmp`
