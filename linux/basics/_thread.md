# スレッド
- 参照: 詳解UNIXプログラミング第3版 11. スレッド
- 参照: 詳解UNIXプログラミング第3版 12. スレッドの制御

## TL;DR
- プロセスは一つのスレッドを持つ(メインスレッド)
- プロセスはスレッドを追加で作成することができる
- 単一スレッド(スレッドベースモデル)
  - 単一のプロセスの中で一つのスレッドが動作する
    -> 各プロセスは一つの処理を担う
- 複数スレッド
  - 単一のプロセスの中で複数のスレッドが動作する
    -> 各プロセスは複数の処理を担う
- スレッドはプロセスと同じ状態遷移を持つ
- スレッドはプロセスと同じくカーネルによりスケジューリングと実行スレッドの切り替えが行われる

### スレッドの持つ情報
- プロセス内での実行状況を表現するために必要な情報
  - スレッドID
  - 一連のレジスタ群の値
  - スタック
  - スケジュール優先度と方針
  - シグナルマスク
  - 変数`errno`
  - スレッド固有のデータ
- プロセス内にあるすべてのものはプロセス内のスレッドによって共有される
  - 実行可能プログラムのテキスト部
  - プログラムの大域メモリ・ヒープメモリ・スタック・ファイルディスクリプタ

## スレッドID
- `pthread_t`型 - 構造体でも可
- スレッドIDを表示するポータブルな方法はない
  - `pthread_equal(3)` - スレッドIDの比較
  - `pthread_self(3)` - 自スレッドIDの取得

## スレッドの作成
- `pthread_create(3)`
- スレッド作成後、新しく作成されたスレッドと呼び出し側のスレッドのうち
  どちらが先に動き出すかについては保証がない
- 新しく作成されたスレッドは呼び出し側のスレッドの浮動小数点数環境とシグナルマスクを継承する
  - 保留中のシグナルセットは破棄される

## スレッドの終了
### プロセスの終了
- プロセス内の任意のスレッドで`exit`関数群を呼ぶとプロセス全体が終了する
- プロセスを終了させるシグナルをスレッドに送ると当該プロセス全体が終了する

### スレッドの終了
- スレッドの始動ルーティンから戻る
  - スレッドの脱出コードが返る
- 同一プロセス内の他のスレッドが`pthread_cancel(2)`を呼ぶ
  - 指定されたスレッドは`pthread_exit(3)`を呼んだ時のように振る舞う
- スレッドで`pthread_exit(3)`を呼ぶ

### スレッドの待機
- 呼び出し側スレッドが`pthread_join(3)`を呼ぶ
  - 指定したスレッドが終了するまで呼び出し側スレッドの処理がブロックされる
  - 対象スレッドを自動的にデタッチ状態にしてリソースを解放することができる

### スレッドのデタッチ
- `pthread_detach(3)` - 当該スレッドが終了した場合直ちに領域を解放
  - `pthread_join(3)`で待ち合わせることはできない

### スレッドクリーンアップハンドラ
- スレッド終了時に呼び出す関数群
- スレッドは複数個のクリーンアップハンドラを確立できる
- ハンドラはスタックに記録され、登録順とは逆順に実行される
  - `pthread_cleanup_push(3)` - ハンドラの呼び出しをスケジュール
  - `pthread_cleanup_pop(3)` - 直近にスケジュールされたハンドラを呼び出し

#### ハンドラが呼び出されるタイミング
- `pthread_exit(3)`
- `pthread_cancel(3)`
- `pthread_cleanup_pop(3)`

## プロセスに関する操作との類似性
| プロセス  | スレッド               |
| -         | -                      |
| `fork`    | `pthread_create`       |
| `exit`    | `pthread_exit`         |
| `waitpid` | `pthread_join`         |
| `atexit`  | `pthread_cleanup_push` |
| `getpid`  | `pthread_self`         |
| `abort`   | `pthread_cancel`       |

## 制限事項
- `PTHREAD_DESTRUCTOR_ITERATIONS` - 4回
  - スレッド終了時にスレッド固有データを破棄する実装の最大試行回数
- `PTHREAD_KEYS_MAX` - 1024個
  - スレッドが作成できるキーの最大個数
- `PTHREAD_STACK_MIN` - 16384バイト
  - スレッドスタックに使用可能な最小バイト数
- `PTHREAD_THREADS_MAX` - 無制限
  - プロセスで作成可能なスレッドの最大個数

## 属性
- pthreadインターフェースにおいては各オブジェクトに付随する属性を設定することにより、
  スレッドと同期オブジェクトの振る舞いを微調整できる
  - 各オブジェクトには独自の属性オブジェクトが付随する
    - スレッド - スレッド属性
    - ミューテックス - ミューテックス属性etc
  - 属性オブジェクトを管理する関数群がある
  - 属性をそのデフォルト値に設定する初期化関数がある
  - 属性オブジェクトを破棄する別の関数がある
  - 各属性には属性オブジェクトから属性値を取得する関数がある
  - 各属性には属性値を設定する関数がある
- `pthread_attr_t`構造体で表す
  - `detachstate` - デタッチ属性
  - `gaurdsize` - スレッドのスタック末尾のガードバッファのバイト単位サイズ
    - `スタックオーバーフローに備えてスタックの末端硫黄のメモリ領域のサイズを制御する`
  - `stackaddr` - スレッドのスタックの低位アドレス
  - `stacksize` - スレッドのスタックのバイト単位サイズ
    - スレッドでは同じ大きさの仮想アドレス空間を全てのスレッドのスタックで共有する
    - アプリケーションが使用するスレッドのスタックの総量によってスタックサイズを増減する必要がある
- `pthread_attr_init(3)` - `pthread_attr_t`構造体の初期化
- `pthread_attr_destroy(3)` - `pthread_attr_t`構造体の削除
- `pthread_attr_getdetachstate(3)` - デタッチ属性の現在の値を取得
- `pthread_attr_setdetachstate(3)` - デタッチ属性の変更
- `pthread_attr_getstack(3)` - スタック属性の取得
- `pthread_attr_setstack(3)` - スタック属性の変更
- `pthread_attr_getguardsize(3)` - スタックサイズの取得
- `pthread_attr_setguardsize(3)` - スタックサイズの変更
- `pthread_attr_getstacksize(3)` - スタックサイズの取得
- `pthread_attr_setstacksize(3)` - スタックサイズの変更

### `pthread_attr_t`構造体に含まれないスレッド属性
- キャンセル属性 - `pthread_cancel`時の動作
  - `cancelability state` - キャンセル可能状態
    - 可能 / 不可能
  - `cancelability type` - キャンセル可能種別
    - 遅延キャンセル /  非同期キャンセル
- `pthread_setcancelstate(3)` - `cancelability state`の変更
- `pthread_testcancel(3)` - キャンセル可能ポイントの追加
  - キャンセル可能ポイント - スレッドがキャンセル要請に対応する場所
- `pthread_setcanceltype` - `cancelability type`の変更

## 再入可能性
- スレッド安全 - 同時に複数のスレッドから呼び出しても正しく動作する
  - 静的なメモリ領域行きにデータを格納して返す関数はスレッド安全ではない
  - 呼び出し側が自前の領域を用意するようにインターフェースを変更している関数はスレッド安全になる
- `flockfile(3)` / `ftrylockfile(3)` - `FILE`に付随する排他ロックを取得
  - `flockfile(3)` - 他のスレッドが先にロックを取得している場合、ロックが解除されるまでブロック
  - `ftrylockfile(3)` - 他のスレッドが先にロックを取得している場合、0を返す

## スレッド固有データ(スレッドローカル変数)
- 特定のスレッドに付随するデータを格納したり探索する機構
- 他のスレッドに対して同期してアクセスすることを気にせず各スレッドがそれ独自のデータにアクセスする
- 当該データに付随するキーを作成し、キーを使ってスレッド固有データへのアクセス権限を得る
- `pthread_key_t`型 - キー型
- `pthread_key_create(3)` - キーの作成
- `pthread_key_delete(3)` - キーの削除
- `pthread_once(3)` - 複数スレッドにおける呼び出しでも最初の一回だけ初期化ルーティンを呼ぶ
- `pthread_setspecific(3)` - スレッド固有の値と以前`pthread_key_create(3)` を呼び出して取得したキーを関連づける

## シグナル
- 各スレッドは独自のシグナルマスクを持つ
- シグナル処理はプロセス内の全てのスレッドで共有する
- 個々のスレッドはシグナルをブロックできるが、
  個々のスレッドにおいてシグナルに付随した変更を行うと
  全てのスレッドでその変更を共有する
- シグナルはプロセス内の一つのスレッドに配送される
- `pthread_sigmask(3)` - シグナルマスクを設定する
- `sigwait(2)` - スレッドにおいて指定のシグナル(群のいずれか)の生起を待つ
  - 対象のシグナルをアンブロックし、配送を不可分に待つ
  - 事前に待つ対象のシグナルをブロックしておく必要がある
- `pthread_kill(3)` - スレッドに任意のシグナルを送る
  - シグナルのデフォルト動作が終了の場合、プロセス全体が終了する

## `fork(2)`
- スレッドで`fork(2)`を呼ぶと、プロセスのアドレス空間全体を子プロセスにコピーする
- 子プロセスは親プロセスで`fork`を読んだスレッドのコピーとなる単一のスレッドを持つ
  - 親のスレッドがロックを持つ場合、子のスレッドもロックを持つ
- 子プロセスは親プロセスからミューテックス、reader / writerロック、条件変数の各状態を継承する
  - 親プロセスが複数のスレッドから成り、子プロセスで`fork`直後に`exec`しない場合
    ロック状態をクリアする必要がある
- `pthread_atfork(3)` - 三つのフォークハンドラを確立する
  - `prepare`フォークハンドラ - `fork`で子プロセスを作る前に親側で呼ばれる
    - 親で定義している全てのロックを獲得する
  - `parent`フォークハンドラ - `fork`で子プロセスを作り`fork`から戻る前に親側で呼ばれる
    - `prepare`が獲得したロックをアンロックする
  - `child`フォークハンドラ - `fork`から戻る前にこの環境で呼ばれる
    - `prepare`が獲得したロックをアンロックする
    - 親と子がそれぞれのロックをアンロックすると、
      子に新たにメモリが割り付けられ親から子へメモリ内容をコピーする

## 同期機構
### デッドロック
- 複数ミューテックスがあり、両方をロックする必要がある場合、
  ロックする順序を制御することでデッドロックを回避する
  - 全てのスレッドが同じ順序でミューテックスをロックすればデッドロックはおきない
  - あるスレッドが他のスレッドの逆順にミューテックスをロックするとデッドロックが起こる
  - ミューテックスをロックする順序が制御できない場合、
    取得したロック群を全て解放し、時間をおいて再ロックする

### ミューテックス
- `pthread`の排他制御インターフェース
  - データを保護し一度に一つのスレッドだけが共有リソースにアクセスすることを保証する
- 共有リソースにアクセスする前にロックし、処理を完了したらアンロックする
  - すでにロックされているミューテックスを他のスレッドがロックしようとすると
    ミューテックスがアンロックされるまで他のスレッドはブロックされる
  - ミューテックスをアンロックした時に複数のスレッドがブロックしている場合、
    当該ミューテックスでブロックしているスレッド全てを実行可能にし、
    最初に動いたスレッドがロックを獲得する
    - 他のスレッドは再びブロックされる
- ミューテックスは 一度に一つのスレッドだけロック・アンロックすることができる
- ミューテックスは全てのスレッドが同一のデータアクセス規則に従う場合のみ意味を成す
- ミューテックスは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある

#### ミューテックスの基本動作
- ロックする
- アンロックする

#### ミューテックスの状態
- ロックがかかっている
- ロックがかかっていない

#### ミューテックスを用いた同期の取り方
1. ロックをかける
2. 危険領域の操作
3. ロックを外す

#### ミューテックスの操作
- `pthread_mutex_t`型 - ミューテックス変数型
- `pthread_mutex_init(3)` - ミューテックスの初期化
- `pthread_mutex_destroy(3)` - ミューテックスの削除
- `pthread_mutex_lock(3)` - ミューテックスのロック
- `pthread_mutex_trylock(3)` - ミューテックスのロック(ロック時、待機せずに別処理を行う)
- `pthread_mutex_timedlock(3)` - ミューテックスのロック(時間制限付き)
- `pthread_mutex_unlock(3)` - ミューテックスのアンロック

#### ミューテックス属性の操作
- `pthread_mutexattr_t`構造体 - ミューテックス属性
  - `proccess-shared` - プロセス共有
    - ミューテックスを単一プロセスのスレッド群のみが使うのか複数プロセスのスレッド群が使うのか制御
  - `robust` - 堅牢性
    - 複数プロセス間で共有しているミューテックスの状態回復問題を扱う
  - `type` - 種別
    - ミューテックスをロックする種別を制御
    - `PTHREAD_MUTEX_NORMAL`
    - `PTHREAD_MUTEX_ERRORCHECK`
    - `PTHREAD_MUTEX_RECURSIVE`
    - `PTHREAD_MUTEX_DEFAULT`
- `pthread_mutexattr_init(3)` - `pthread_mutexattr_t`構造体の初期化
- `pthread_mutexattr_destroy(3)` - `pthread_mutexattr_t`構造体の削除
- `pthread_mutexattr_getpshared(3)` - `proccess-shared`の取得
- `pthread_mutexattr_setpshared(3)` - `proccess-shared`の設定
- `pthread_mutexattr_getrobust(3)` - `robust`の取得
- `pthread_mutexattr_setrobust(3)` - `robust`の設定
- `pthread_mutex_consistent(3)` - 当該ミューテックスをアンロックする前にミューテックスに付随する状態が一貫していることを示す
- `pthread_mutexattr_gettype(3)` - `type`の取得
- `pthread_mutexattr_settype(3)` - `type`の設定

### reader / writerロック(共有排他ロック)
- ミューテックスより高い並列度を持つロック機構
- reader / writerロックはread(共有)モードロック / write(排他)モードロック / アンロックの状態を保ち、
  write(排他)モードでは一つのスレッド、
  read(共有)モードでは複数のスレッドをロックすることができる
  - どのスレッドもロックを獲得していない場合
    -> どのスレッドでもread(共有)モードでロックを獲得できる
    -> どのスレッドでもwrite(排他)モードでロックを獲得できる
  - あるスレッドがread(共有)モードでロックを獲得している場合
    -> 他のスレッドはread(共有)モードでロックを獲得できる
    -> 他のスレッドはwrite(排他)モードでロックを獲得できない
  - あるスレッドがwrite(排他)モードでロックを獲得している場合
    -> 他のスレッドはread(共有)モードでロックを獲得できない
    -> 他のスレッドはwriterモードでロックを獲得できない
- reader / writerロックは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_rwlock_init(3)` - reader / writerロックの初期化
- `pthread_rwlock_destroy(3)` - reader / writerロックの削除
- `pthread_rwlock_rdlock(3)` - reader / writerロックのロック(readモード)
- `pthread_rwlock_tryrdlock(3)` - reader / writerロックのロック(readモード・条件付き)
- `pthread_rwlock_rdlock(3)` - reader / writerロックのロック(readモード・時間制限付き)
- `pthread_rwlock_wrlock(3)` - reader / writerロックのロック(writeモード)
- `pthread_rwlock_trywrlock(3)` - reader / writerロックのロック(writeモード・条件付き)
- `pthread_rwlock_timedwrlock(3)` - reader / writerロックのロック(writeモード・時間制限付き)
- `pthread_rwlock_unlock(3)` - reader / writerロックのアンロック

#### reader / writerロック属性の操作
- `pthread_rwlocksttr_t`構造体 - reader / writerロック属性
  - `proccess-shared` - プロセス共有
    - reader / writerロックを単一プロセスのスレッド群のみが使うのか複数プロセスのスレッド群が使うのか制御
- `pthread_rwlockattr_init(3)` - `pthread_rwlockattr_t`構造体の初期化
- `pthread_rwlockattr_destroy(3)` - `pthread_rwlockattr_t`構造体の削除
- `pthread_rwlockattr_getpshared(3)` - `proccess-shared`の取得
- `pthread_rwlockattr_setpshared(3)` - `proccess-shared`の設定

### 条件変数
- 条件を満たしたタイミングで合図を送る
  - ミューテックスと合わせて使用すると、スレッドは任意の条件が成立するまで競合なしに待つことができる
- 条件変数はミューテックスによって保護する
  - スレッドが条件変数を評価するためにはミューテックスをロックする必要がある
  - スレッドが条件変数の状態を変更するためにはミューテックスをロックする必要がある
  - スレッドはミューテックスのロックを獲得するまでは条件変数の状態や変化を知り得ない
  - `pthread_cond_wait(3)`に渡すミューテックスが条件変数を保護する
    - このとき、呼び出し側のスレッドがロックしたミューテックスを渡すことによって
      呼び出し側のスレッドは当該条件変数を持つスレッドのリストに追加され、
      渡したミューテックスはアンロックされる
    - 呼び出し側のスレッドが条件変数の変化を感知し、
      `pthread_cond_wait(3)`から戻ると
      ミューテックスは再度ロック済みになっている
- 条件変数は使用前に初期化し、使用するメモリを解放する前に破棄する必要がある

#### 条件変数の基本動作
- 合図を送る
- 合図を待つ

#### 条件変数を用いた同期の取り方
1. スレッドAが合図を待つ
   スレッドAはwait状態になる
2. スレッドBが合図を送る
3. スレッドAが合図を受け取り、ready状態になる
   タスクの切り替えによりスレッドAがrunning状態になり、処理が再開する

#### ミューテックスとの連動による同期の取り方
1. スレッドAがミューテックスを獲得する
2. スレッドAが条件判定を行う(条件を表すグローバルな変数を使用する)
   条件が満たされていない場合、スレッドBが条件を満たすまでwait状態になる
   このときミューテックスが自動的に解放される
3. スレッドBが条件判定の結果(条件を表すグローバルな変数)を書き換える処理を行う
4. 条件判定の結果の書き換えを受け、スレッドAに合図が送られる
5. スレッドAが合図を受け取り、ready状態になる
   スレッドAが自動的に再びミューテックスを獲得する
   スレッドAが再び条件判定を行い、条件が満たされている場合次の処理に移る
6. スレッドAが処理を行い、ミューテックスを解放する


#### 条件変数の操作
- `pthread_cond_init(3)` - 条件変数の初期化
- `pthread_cond_destroy(3)` - 条件変数の削除
- `pthread_cond_wait(3)` - 合図を待つ
- `pthread_cond_timedwait(3)` - 合図を待つ(時間制限付き)
- `pthread_cond_signal(3)` - 合図を送る
- `pthread_cond_broadcast(3)` - 条件変数待ち中の全スレッドへ合図を送る

#### 条件変数属性の操作
- `pthread_condattr_t`構造体 - 条件変数属性
  - `proccess-shared` - プロセス共有
    - 条件変数を単一プロセスのスレッド群のみが使うのか複数プロセスのスレッド群が使うのか制御
  - `clock` - `pthread_cond_timedwait(3)`の時間切れ引数を評価するクロックの種類(クロックID)を制御
- `pthread_condattr_init(3)` - `pthread_condattr_t`構造体の初期化
- `pthread_condattr_destroy(3)` - `pthread_condattr_t`構造体の削除
- `pthread_condattr_getpshared(3)` - `proccess-shared`の取得
- `pthread_condattr_setpshared(3)` - `proccess-shared`の設定
- `pthread_condattr_getclock(3)` - `clock`の取得
- `pthread_condattr_setclock(3)` - `clock`の設定

## スピンロック
- プロセスがロックを獲得できるまでビジーウェイト(スピン)でブロックするロック機構
  - ロックの保持期間が短く、スレッドがスケジュールから外されるコストを避ける際に使用される
- 他の種類のロックを実装するための低レベル基本操作
  - ノンプリエンプティブなカーネルで使うと有用
- スピンロックは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_spin_init(3)` - スピンロックの初期化
- `pthread_spin_destroy(3)` - スピンロックの破棄
- `pthread_spin_lock(3)` - スピンロックのロック
- `pthread_spin_trylock(3)` - スピンロックのロック(条件付き/スピンしない)
- `pthread_spin_unlock(3)` - スピンロックのアンロック

## バリア
- 並列動作している複数のスレッドを協調するために使える同期機構
  - 協調動作している全てのスレッドが同一地点に達するまで各スレッドが待つ
  - 任意個のスレッドが全て処理を完了するまで待ち合わせる
    - スレッドは終了する必要はなく、全てのスレッドがバリアに達すると処理を続行できる
- バリアは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_barrier_init(3)` - バリアの初期化
- `pthread_barrier_destroy(3)` - バリアの破棄
- `pthread_barrier_wait(3)` - 当該スレッドが他のスレッドを待ち合わせ開始

#### バリア属性
- `pthread_barrierattr_t`構造体で表す
  - `proccess-shared` - プロセス共有
    - バリアを単一プロセスのスレッド群のみが使うのか複数プロセスのスレッド群が使うのか制御
- `pthread_barrierattr_init(3)` - `pthread_barrierattr_t`構造体の初期化
- `pthread_barrierattr_destroy(3)` - `pthread_barrierattr_t`構造体の削除
- `pthread_barrierattr_getpshared(3)` - `proccess-shared`の取得
- `pthread_barrierattr_setpshared(3)` - `proccess-shared`の設定

## リエントラントな関数
- 複数のスレッドから同時に実行された際、
  他のスレッドの状態に関わらず期待通りの結果が保証される関数
- グローバルまたはスタティックなデータを更新する関数は
  非リエントラントである恐れがある
