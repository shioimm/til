# スレッド
- 参照: 詳解UNIXプログラミング第3版 11. スレッド
- 参照: 詳解UNIXプログラミング第3版 12. スレッドの制御

## TL;DR
- プロセスは一つのスレッドを持つ(メインスレッド)
- プロセスはスレッドを追加で作成することができる
- 単一スレッド(スレッドベースモデル)
  - 単一のプロセスの中で一つのスレッドが動作する
    -> 各プロセスは一つの処理を担う
- 複数スレッド
  - 単一のプロセスの中で複数のスレッドが動作する
    -> 各プロセスは複数の処理を担う

### スレッドの持つ情報
- プロセス内での実行状況を表現するために必要な情報
  - スレッドID
  - 一連のレジスタ群の値
  - スタック
  - スケジュール優先度と方針
  - シグナルマスク
  - 変数`errno`
  - スレッド固有のデータ
- プロセス内にあるすべてのものはプロセス内のスレッドによって共有される
  - 実行可能プログラムのテキスト部
  - プログラムの大域メモリ・ヒープメモリ・スタック・ファイルディスクリプタ

## スレッドID
- `pthread_t`型 - 構造体でも可
- スレッドIDを表示するポータブルな方法はない
  - `pthread_equal(3)` - スレッドIDの比較
  - `pthread_self(3)` - 自スレッドIDの取得

## スレッドの作成
- `pthread_create(3)`
- スレッド作成後、新しく作成されたスレッドと呼び出し側のスレッドのうち
  どちらが先に動き出すかについては保証がない
- 新しく作成されたスレッドは呼び出し側のスレッドの浮動小数点数環境とシグナルマスクを継承する
  - 保留中のシグナルセットは破棄される

## スレッドの終了
### プロセスの終了
- プロセス内の任意のスレッドで`exit`関数群を呼ぶとプロセス全体が終了する
- プロセスを終了させるシグナルをスレッドに送ると当該プロセス全体が終了する

### スレッドの終了
- スレッドの始動ルーティンから戻る
  - スレッドの脱出コードが返る
- 同一プロセス内の他のスレッドが`pthread_cancel(2)`を呼ぶ
  - 指定されたスレッドは`pthread_exit(3)`を呼んだ時のように振る舞う
- スレッドで`pthread_exit(3)`を呼ぶ

### スレッドの待機
- 呼び出し側スレッドが`pthread_join(3)`を呼ぶ
  - 指定したスレッドが終了するまで呼び出し側スレッドの処理がブロックされる
  - 対象スレッドを自動的にデタッチ状態にしてリソースを解放することができる

### スレッドのデタッチ
- `pthread_detach(3)` - 当該スレッドが終了した場合直ちに領域を解放
  - `pthread_join(3)`で待ち合わせることはできない

### スレッドクリーンアップハンドラ
- スレッド終了時に呼び出す関数群
- スレッドは複数個のクリーンアップハンドラを確立できる
- ハンドラはスタックに記録され、登録順とは逆順に実行される
  - `pthread_cleanup_push(3)` - ハンドラの呼び出しをスケジュール
  - `pthread_cleanup_pop(3)` - 直近にスケジュールされたハンドラを呼び出し

#### ハンドラが呼び出されるタイミング
- `pthread_exit(3)`
- `pthread_cancel(3)`
- `pthread_cleanup_pop(3)`

## プロセスに関する操作との類似性
| プロセス  | スレッド               |
| -         | -                      |
| `fork`    | `pthread_create`       |
| `exit`    | `pthread_exit`         |
| `waitpid` | `pthread_join`         |
| `atexit`  | `pthread_cleanup_push` |
| `getpid`  | `pthread_self`         |
| `abort`   | `pthread_cancel`       |

## 同期機構
### ミューテックス
- `pthread`の排他制御インターフェース
  - データを保護し一度に一つのスレッドだけが共有リソースにアクセスすることを保証する
- 共有リソースにアクセスする前にロックし、処理を完了したらアンロックする
  - すでにロックされているミューテックスを他のスレッドがロックしようとすると
    ミューテックスがアンロックされるまで他のスレッドはブロックされる
  - ミューテックスをアンロックした時に複数のスレッドがブロックしている場合、
    当該ミューテックスでブロックしているスレッド全てを実行可能にし、
    最初に動いたスレッドがロックを獲得する
    - 他のスレッドは再びブロックされる
- ミューテックスはロック / アンロックの状態を持ち、
  一度に一つのスレッドだけロックすることができる
- ミューテックスは全てのスレッドが同一のデータアクセス規則に従う場合のみ意味を成す
- `pthread_mutex_t`型 - ミューテックス変数型
- `pthread_mutex_init(3)` - ミューテックスの初期化
- `pthread_mutex_destroy(3)` - ミューテックスの削除
- `pthread_mutex_lock(3)` - ミューテックスのロック
- `pthread_mutex_trylock(3)` - ミューテックスのロック(条件付き)
- `pthread_mutex_timedlock(3)` - ミューテックスのロック(時間制限付き)
- `pthread_mutex_unlock(3)` - ミューテックスのアンロック
- ミューテックスは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある

### デッドロック
- 複数ミューテックスがあり、両方をロックする必要がある場合、
  ロックする順序を制御することでデッドロックを回避する
  - 全てのスレッドが同じ順序でミューテックスをロックすればデッドロックはおきない
  - あるスレッドが他のスレッドの逆順にミューテックスをロックするとデッドロックが起こる
  - ミューテックスをロックする順序が制御できない場合、
    取得したロック群を全て解放し、時間をおいて再ロックする

### reader / writerロック(共有排他ロック)
- ミューテックスより高い並列度を持つロック機構
- reader / writerロックはread(共有)モードロック / write(排他)モードロック / アンロックの状態を保ち、
  write(排他)モードでは一つのスレッド、
  read(共有)モードでは複数のスレッドをロックすることができる
  - どのスレッドもロックを獲得していない場合
    -> どのスレッドでもread(共有)モードでロックを獲得できる
    -> どのスレッドでもwrite(排他)モードでロックを獲得できる
  - あるスレッドがread(共有)モードでロックを獲得している場合
    -> 他のスレッドはread(共有)モードでロックを獲得できる
    -> 他のスレッドはwrite(排他)モードでロックを獲得できない
  - あるスレッドがwrite(排他)モードでロックを獲得している場合
    -> 他のスレッドはread(共有)モードでロックを獲得できない
    -> 他のスレッドはwriterモードでロックを獲得できない
- reader / writerロックは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_rwlock_init(3)` - reader / writerロックの初期化
- `pthread_rwlock_destroy(3)` - reader / writerロックの削除
- `pthread_rwlock_rdlock(3)` - reader / writerロックのロック(readモード)
- `pthread_rwlock_tryrdlock(3)` - reader / writerロックのロック(readモード・条件付き)
- `pthread_rwlock_rdlock(3)` - reader / writerロックのロック(readモード・時間制限付き)
- `pthread_rwlock_wrlock(3)` - reader / writerロックのロック(writeモード)
- `pthread_rwlock_trywrlock(3)` - reader / writerロックのロック(writeモード・条件付き)
- `pthread_rwlock_timedwrlock(3)` - reader / writerロックのロック(writeモード・時間制限付き)
- `pthread_rwlock_unlock(3)` - reader / writerロックのアンロック

### 条件変数
- スレッドの待ち合わせ場所を提供
  - ミューテックスと合わせて使用すると、スレッドは任意の条件が成立するまで競合なしに待つことができる
- 条件変数はミューテックスによって保護する
  - スレッドが条件変数を評価するためにはミューテックスをロックする必要がある
  - スレッドが条件変数の状態を変更するためにはミューテックスをロックする必要がある
  - スレッドはミューテックスのロックを獲得するまでは条件変数の状態や変化を知り得ない
  - `pthread_cond_wait(3)`に渡すミューテックスが条件変数を保護する
    - このとき、呼び出し側のスレッドがロックしたミューテックスを渡すことによって
      呼び出し側のスレッドは当該条件変数を持つスレッドのリストに追加され、
      渡したミューテックスはアンロックされる
    - 呼び出し側のスレッドが条件変数の変化を感知し、
      `pthread_cond_wait(3)`から戻ると
      ミューテックスは再度ロック済みになっている
- 条件変数は使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_cond_init(3)` - 条件変数の初期化
- `pthread_cond_destroy(3)` - 条件変数の削除
- `pthread_cond_wait(3)` - 条件が真になるまで待つ
- `pthread_cond_timedwait(3)` - 条件が真になるまで待つ(時間制限付き)
- `pthread_cond_signal(3)` - 条件変数待ち中の一つのスレッドへ条件が真になったことを通知する
- `pthread_cond_broadcast(3)` - 条件変数待ち中の全スレッドへ条件が真になったことを通知する

## スピンロック
- プロセスがロックを獲得できるまでビジーウェイト(スピン)でブロックするロック機構
  - ロックの保持期間が短く、スレッドがスケジュールから外されるコストを避ける際に使用される
- 他の種類のロックを実装するための低レベル基本操作
  - ノンプリエンプティブなカーネルで使うと有用
- スピンロックは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_spin_init(3)` - スピンロックの初期化
- `pthread_spin_destroy(3)` - スピンロックの破棄
- `pthread_spin_lock(3)` - スピンロックのロック
- `pthread_spin_trylock(3)` - スピンロックのロック(条件付き/スピンしない)
- `pthread_spin_unlock(3)` - スピンロックのアンロック

## バリア
- 並列動作している複数のスレッドを協調するために使える同期機構
  - 協調動作している全てのスレッドが同一地点に達するまで各スレッドが待つ
  - 任意個のスレッドが全て処理を完了するまで待ち合わせる
    - スレッドは終了する必要はなく、全てのスレッドがバリアに達すると処理を続行できる
- バリアは使用前に初期化し、使用するメモリを解放する前に破棄する必要がある
- `pthread_barrier_init(3)` - バリアの初期化
- `pthread_barrier_destroy(3)` - バリアの破棄
- `pthread_barrier_wait(3)` - 当該スレッドが他のスレッドを待ち合わせ開始

## 制限事項
- `PTHREAD_DESTRUCTOR_ITERATIONS` - 4回
  - スレッド終了時にスレッド固有データを破棄する実装の最大試行回数
- `PTHREAD_KEYS_MAX` - 1024個
  - スレッドが作成できるキーの最大個数
- `PTHREAD_STACK_MIN` - 16384バイト
  - スレッドスタックに使用可能な最小バイト数
- `PTHREAD_THREADS_MAX` - 無制限
  - プロセスで作成可能なスレッドの最大個数

## 属性
- pthreadインターフェースにおいては各オブジェクトに付随する属性を設定することにより、
  スレッドと同期オブジェクトの振る舞いを微調整できる
  - 各オブジェクトには独自の属性オブジェクトが付随する
    - スレッド - スレッド属性
    - ミューテックス - ミューテックス属性etc
  - 属性オブジェクトを管理する関数群がある
  - 属性をそのデフォルト値に設定する初期化関数がある
  - 属性オブジェクトを破棄する別の関数がある
  - 各属性には属性オブジェクトから属性値を取得する関数がある
  - 各属性には属性値を設定する関数がある
