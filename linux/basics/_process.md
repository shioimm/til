# プロセス
- 参照: 例解UNIX/Linuxプログラミング教室P185-224
- 参照: 詳解UNIXプログラミング第3版 7. プロセスの環境 / 8. プロセスの制御 / 9. プロセスの関係

## TL;DR
- OSが実行中のプログラムを管理する単位
  - プログラムを実行することによって作られる
- 一つのプロセスは独立したメモリ空間(仮想記憶領域)を持つ
- 一つのプロセスは一意なプロセスIDを持つ
  - プロセスが終了した場合そのプロセスIDは別のプロセスに再利用される可能性がある

### プロセスの制御関数
- 新しいプロセスの作成 - `fork`関数群
- プログラムの実行 - `exec`関数群
- プロセスの終了 - `exit`関数群
- 終了するプロセスの待ち合わせ - `wait`関数群

## プログラムとプロセス
- プログラムはファイルシステムの中に実行可能ファイルとして存在する
- 実行可能ファイルを実行するとプロセスが生成される
  - 関数`main`の先頭が呼ばれた時点
- プロセスはプログラム終了時消える
  - `exit`が呼ばれた時点
- ファイルを複数回実行すると複数の独立したプロセスが生成される

## プロセスID
- `getpid(2)` - プロセスIDの取得
- `getppid(2)` - プロセスの親プロセスIDの取得
- `getuid(2)` - 実ユーザーIDの取得
- `geteuid(2)` - 実効ユーザーIDの取得
- `getgid(2)` - 実グループIDの取得
- `getegid(2)` - 実効グループIDの取得
- `PID 0` - スケジューラプロセス / スワッパー
  - カーネルの一部・システムプロセス
- `PID 1` - プロセス`init`
  - ブート手続きの最後にカーネルが起動するプロセス
  - システム依存の初期化ファイル群を読み取り、システムを起動させる
  - 孤児プロセスの親となる

## 環境リスト
- 環境文字列(環境変数)へのポインタの配列
  - 配列の要素である各ポインタは文字列のアドレス(NULL終端)
- 環境リストのアドレスは大域変数`environ`に格納されている
  - `environ`は`extern char **environ`としてプロセス自身からもアクセス可能
```
環境ポインタ(environ)
    |
環境リスト
    |
    |- 環境文字列(環境変数)
    |- 環境文字列(環境変数)
    |- ...
    |- NULL
```
- 環境リストはプログラム実行時にプロセスに渡される
- 環境リストはプロセスから新しく起動したプロセスに自動的に引き継がれる

### 環境変数の操作
- `getenv`   - 値の取得
- `setenv`   - 値の設定
- `unsetenv` - 変数の削除
  - `setenv` `unsetenv`は環境を新しいメモリ領域に作り直し領域内で環境変数を変更する
  - 外部変数`environ`を直接操作することはしない

## 新しいプロセスの作成
- プロセスは自分の複製を作ることができる
  - 親プロセス - 元のプロセス
  - 子プロセス - 新しくできたプロセス
    - 子プロセスは親プロセスが持つ情報を全て引き継ぐ
- UNIXで新しくプロセスを生成する唯一の手段は既存のプロセスをforkすること
- 親子プロセスは非同期で動作する
  それぞれの動作のタイミングはカーネルが行うプロセススケジューリングによって決まる
  - 同期させる場合はプロセス間通信が必要

### `fork(2)`
1. 親プロセスが持つ全ての情報を複製して子プロセスを生成する
2. 複製が終わると`fork`から親プロセスに戻る
    - 親プロセスには`fork`から子プロセスのPIDが返る
3. 子プロセスは「`fork`から戻る」ところから始まる
    - 子プロセスには`fork`から0が返る

### 子プロセスが親プロセスから引き継ぐ情報
- CoWによって処理を遅延する
  - 実行状態
  - メモリマップ
  - ユーザーID / グループID / セッションID
  - 環境
  - 作業ディレクトリ
  - umask値
  - シグナルマスク・シグナルハンドラの設定
  - ファイルディスクリプタ
  - ディレクトリストリーム
  - 制御端末

#### 子プロセスに引き継がれないもの
- PID / PPID
- `fork`からの返り値
- 親の`tms_utime` / `tms_stime` / `tms_cutime` / `tms_ctime`
- 親が設定したファイルロック
- 親の保留中アラーム
- 親の保留中シグナルセット

#### ファイル共有
- 親子関係において、両者が同じファイルに対するストリームをそれぞれ持つ場合、
  ファイルに対する操作が競合する可能性がある
  - 親が子の完了を`wait`することによって親子の操作を同期させる
  - 各自が不要なストリームを切り離す - 各自が不要なファイルディスクリプタを閉じ、操作が干渉しないようにする

### `vfork(3)`
- 親のアドレス空間を子にコピーしない
- 子は`vfork(3)`の直後に`exec` / `exit`を呼ぶ
  - 子は`exec` / `exit`を呼ぶまで親のアドレス空間で動作する(メモリを共有する)
- 子は親よりも先に動作する

## プログラムの実行
- `exec`関数 - 実行可能ファイルに格納されているプログラムをプロセスとして実行する関数群
  - プロセス上で実行中のプログラムを新しいプログラムへ置き換える
  - 呼び出しプロセスのメモリ領域の内容を新しいプログラムを実行する内容で置き換える
    - `exec`呼び出し時点で標準入出力ライブラリのバッファに残っているデータは
      呼び出しが成功すると捨てられる
- `exec`の呼び出しに成功した場合、元のプログラムのexec以降は実行されない

### `exec`関数群
- `execl(3)`
- `execle(3)`
- `execlp(3)`
- `execv(3)`
- `execve(2)`
- `execvp(3)`
- `fexecve(3)` - ファイルディスクリプタを使用する

#### `exec`関数群の接尾辞
- `l` - 引数がリスト
- `v` - 引数がベクタ
- `e` - 環境文字列へのポインタの配列へのポインタを指定
- `p` - 環境変数`PATH`を参照して実行可能ファイルを探す

#### `exec`関数群の関係
- `execv` -> `arg`を作成 -> `execve`
- `execl` -> `arg`を作成 -> `execv` -> `execve`
- `execvp` -> `arg`を作成 -> `execv` -> `environ`を使う -> `execve`
- `execlp` -> `arg`を作成 -> `execvp` -> PATH接頭辞を試す -> `execv` -> `environ`を使う -> `execve`
- `execle` -> `environ`を使う -> `execve`
- `fexecve` -> パス名を作成 -> `execve`

### プロセスが`exec`の前後で引き継ぐ情報
- PID / PPID
- ユーザーID / グループID
- 環境
- umask値
- シグナルマスク・シグナルハンドラの設定
- ファイルディスクリプタ
  - オープンしてあるディレクトリストリームは`exec`後にクローズ
- 作業ディレクトリ
- シグナルマスク
- リソースリミット
- 制御端末
- そのプロセスがそれまでに利用した資源の情報

## プロセスの終了
- プロセスが終了すると、カーネルはその親に`SIGCHLD`を送り、プロセスの終了コードを保持する
  -> 親プロセスが`SIGCHLD`を捕捉し子プロセスの終了コードを読み出す
  -> カーネルが子プロセスを消滅させる
  - 親プロセスは`fork`後、子プロセスを`wait`することで子プロセスの終了を待ち合わせる
  - 親プロセスが子プロセスの終了コードを読み出すまで子プロセスは消去されない(ゾンビプロセス)
- プロセスが終了する時、そのプロセスが使っていた資源は自動的に解放され
  カーネルによって回収される

#### 正常終了
- 関数`main`から戻る(関数`main`は戻り時に`exit`を呼ぶため)
- `exit`を呼ぶ
- `_exit` / `_Exit`を呼ぶ
- スレッドの開始ルーティンの最後のスレッドから戻る
- 最後のスレッドから`pthread_exit(3)`を呼ぶ

#### 異常終了
- `abort`を呼ぶ
- シグナルを受け取る
- キャンセル要請に対する最後のスレッドの応答

### `exit`関数群
- `exit(3)` - プロセスを終了し、後処理を行った後カーネルに戻る
- `_exit(2)` / `_Exit(2)` - プロセスを終了し、直ちにカーネルに戻る
- `exit`関数群はステータスを引数に取る
  - 0 - 正常終了
  - 1 - 異常終了
  - 引数なし - 未定義の挙動

#### 脱出ハンドラ
- `exit`が自動的に呼び出す関数
- `atwxit(3)` - 脱出ハンドラを登録する
  - 実際の`exit`時には登録時と逆順に呼び出される

#### `exit(3)`が実行する処理
- `at_exit(3)`で登録された処理の呼び出し
- 標準入出力ライブラリの後始末
- 出力ストリームのフラッシュ
- ストリームを閉じる
- 一時ファイルの消去
- 終了コードを返す

### 親子の終了関係
- 親が終了・子が実行中
  -> 子が孤児化する -> プロセス`init`が子の親になる
- 親が実行中・子が終了
  -> 親が`wait`していた場合: 親が子の終了を検知する
  -> 親が`wait`していなかった場合: 子がゾンビ化する

## 終了するプロセスの待ち合わせ
### `wait`関数群
- `wait(2)` - 子プロセスの状態を得る
- `waitpid(2)` - 指定した子プロセスの状態を得る
  - `pid > 0` - 指定したPIDを持つ子プロセス
  - `pid == 0` - 親プロセスと同じプロセスグループに属する子プロセス
  - `pid == -1` - 任意の子プロセス(`wait`と同じ)
  - `pid < -1` - プロセスグループIDが指定したPIDの絶対値に等しい子プロセス
- `wait` / `waitpid`は
  - 全ての子が動作している間は処理をブロックする
  - すでに終了している子があり、まだ終了状態が取得されていない場合は、終了状態を取得して即座に返る
  - 子がいない場合はエラーで即座に返る
- `wait` / `waitpid`は
  - 整数へのポインタに子の終了状態を格納することができる
    - `WIFEXITED(status)` - 正常終了した子は真を返す
    - `WIFSIGNALE(status)` - 補足しないシグナルによって異常終了した子は真を返す
    - `WIFSTOPPED(status)` - 現在停止している子は真を返す
    - `WIFCONTINUED(status)` - ジョブ制御の停止後に再開した子は真を返す
- `waitpid`
  - オプションで処理のブロックを行うことができる
  - オプションでジョブ制御を扱うことができる

## リソースリミット
- 各プロセスにはリソースの制限がある
  - 使用可能メモリの最大サイズ
  - コアファイルのバイト単位の最大サイズ
  - CPU時間の秒単位の最大量 など
- `getrlimit(2)` - リソースリミットを取得
- `setrlimit(2)` - リソースリミットを変更
```c
struct rlimit {
  rlim_trlim_cur; // ソフトリミット - 現在値
  rlim_trlim_max; // ハードリミット - 上限
};
```
- プロセスは自身のハードリミットまでソフトリミットを変更できる
- プロセスは自身のソフトリミットまでハードリミットを減少できる
- スーパーユーザーがハードリミットを増加させることができる

## シェルの入出力リダイレクト
- `fork` `exec`におけるファイルディスクリプタの引き継ぎを利用して実現されている
```
(1) 親プロセスがコマンドを受け取る
(2) 親プロセスが子プロセスをfork
(3) 子プロセスは親プロセスのファイルディスクリプタを引き継ぐ
(4) 子プロセスがリダイレクトに不要なファイルディスクリプタを閉じる
(5) 子プロセスがリダイレクトに必要なファイルディスクリプタを開く
(6) 子プロセスが親プロセスから引き継いだコマンドを実行
```

## `init`(現在の`systemd`)
- 全てのプロセスの先祖
- 孤児プロセスは`init`が親プロセスとなり`wait`する
  - 孤児プロセス - 自身の終了前に親プロセスが終了したプロセス

## カーネルプロセス
- カーネルの中にあるプログラムの動作
  - プロセススケジューリングを行うプロセス
  - 仮想記憶に関する処理を行うプロセス など

## プロセスグループ
- 参照: 例解UNIX/Linuxプログラミング教室P366-
- プロセスグループ - プロセスの集まり
  - 同一ジョブに関連づけられ、同一端末からシグナルを受け取る
  - 同じプロセスグループに属するプロセスは同じシグナルを受け取る
  - グループ内に最低一つのプロセスがあればグループは存在し続ける

### プロセスグループの種類
- フォアグラウンドプロセスグループ   - 端末を介してユーザーと対話中のプロセスグループ(一セッションにつき一つ)
  - `tcgetpgrp(3)` - フォアグラウンドプロセスグループIDを取得
  - `tcsetpgrp(3)` - フォアグラウンドプロセスグループを変更
  - 端末ドライバに対して入出力を行うことができる
  - 端末ドライバは端末生起シグナル(`SIGINT` / `SIGQUIT` / `SIGSTP`)を送信できる
- バックグラウンドプロセスグループ - フォアグラウンドプロセスグループ以外の全てのプロセスグループ

  - 端末ドライバからの読み取りで`SIGTTIN`を生起する
  - 端末ドライバへの書き出しで`SIGTTOU`を生起する

### プロセスグループリーダー
- プロセスIDとプロセスグループIDが等しいプロセス
- グループ内にプロセスを作成し、終了できる
- `getpgid(2)` - 自プロセスのプロセスグループリーダーのプロセスIDを取得
- `setpgid(2)` - 新しいプロセスグループを作り、そこに移動する
  - プロセスグループを作ったプロセスがプロセスグループリーダーになる

### ジョブ
- プロセスの集まり
- プロセスグループのうち、ユーザーが端末から実行したコマンド
  - パイプ`|`でつなげたコマンド同士は一つのジョブ(一つのプロセスグループ)
  - アンパサンド`&`でつなげたコマンド同士は別のジョブ(別のプロセスグループ)

#### ジョブ制御
- ユーザーが単体の端末から複数のジョブを操作し、
  どのジョブに端末へのアクセスを許し、
  どのジョブをバックグラウドで動かすかを制御する
  - `^Z` - フォアグラウンドのジョブをバックグラウンドにして一時中断
  - `bg(1)` - 一時中断状態のジョブをバックグラウンドで実行再開
  - `fg(1)` - バックグラウンドのジョブをフォアグラウンドで実行
- ジョブ制御はシグナルを利用して行われる

## セッション
- プロセスグループの集まり
  - 端末上でジョブ制御の影響が及ぶ範囲
  - 一つのセッション内には1個のフォアグラウンドプロセスグループと
    0個以上のバックグラウンドプロセスグループが入っている
- セッションは1個の制御端末を持つことができる
  - ユーザーが端末ログインした端末装置
  - ユーザーがネットワークログインした擬似端末装置
- 制御プロセス - 制御端末との接続を確立しているセッションリーダープロセス
- デーモンプロセス - 制御端末を持たないプロセス
- ログイン時や`init`起動時に自動的に新しいセッションが作られ、制御端末が設定される
- `setsid(2)` - 新しいセッションを作る
  - `setsid(2)`を読んだプロセスがプロセスグループリーダーでない場合、
    -> 当該プロセスは新たなセッションのセッションリーダーとなる
    -> 当該プロセスは新たなプロセスグループのプロセスリーダーとなる
    -> 当該プロセスの制御端末を解除する
  - `setsid(2)`を読んだプロセスがプロセスグループリーダーの場合、エラーを返す
  - デーモンプロセスや端末エミュレータを作る時に使用する

### 制御端末とフォアグラウンドプロセスグループの関係
- セッションに制御端末がある場合、そのセッションには一つのフォアグラウンドプロセスグループがある
  - セッション内の別のプロセスグループはすべてバックグラウンドプロセスグループになる
- フォアグラウンドプロセスグループ中のプロセスは制御端末への入出力が可能
- 制御端末から`^C` / `^\` / `^Z`を押すと
  制御端末はフォアグラウンドプロセスグループ中の全プロセスへ
  `SIGINT` / `SIGQUIT` / `SIGTSTP` を送信する

### 制御端末とバックグラウンドプロセスグループの関係
- バックグラウンドプロセスグループ中のプロセスは制御端末への入出力が不可能
- 制御端末からデータを入力する場合、制御端末はそのプロセスに`SIGTTIN`を送信する
  - `SIGTTIN`のデフォルトの動作は一時中断
- 制御端末への出力が許されるかどうかは端末の設定による

### 制御端末と制御プロセスの関係
- (遠隔操作等で)制御端末が切断を検出すると、
  カーネルは制御プロセス(セッションリーダー)へ`SIGHUP`を送信する
  - `SIGHUP`のデフォルトの動作は終了
- 制御プロセスが終了すると、
  カーネルは制御プロセスを切り離してフォアグラウンドプロセスグループへ`SIGHUP`を送信する
- フォアグラウンドプロセスグループが終了した後、
  孤児になったバックグラウンドプロセスグループが発生した場合、
  かつ孤児プロセスグループ中に一時中断したプロセスがある場合
  カーネルは孤児プロセスグループへ`SIGHUP`と`SIGCONT`を送信する
- バックグラウンドプロセスはそのまま動作を続ける

### `session`構造体
- 各セッションごとに割り付けられる
```c
struct session {
  int          s_count  // プロセスグループの個数 / 0になると構造体を解放
  struct proc *s_leader // セッションリーダー構造体procへのポインタ
  struct vnode *s_ttyvp  // 制御端末構造体vnodeへのポインタ
  struct tty   *s_ttyp   // 制御端末構造体ttyへのポインタ
  pid_t         s_sid    // セッションID
};
```

### `tty`構造体
```c
struct tty {
  struct session *t_session; // この端末を制御端末とするsession構造体
  struct pgrp    *t_pgrp;    // フォアグラウンドプロセスグループのpgrp構造体
  struct termios  t_termios; // 当該端末に関する情報を集めたtermios構造体
  struct winsize  t_winsize; // 端末ウィンドウサイズを収めたwinsize構造体
};
```

### `pgrp`構造体
```c
struct pgrp {
  pid_t              pg_id;      // プロセスグループID
  struct session    *pg_session; // プロセスグループが属するセッションのsession構造体
  LIST_HEAD(, proc)  pg_members; // 当該プロセスグループのメンバに対するproc構造体のリストへのポインタ
};
```

### `proc`構造体
```c
struct proc {
  pid_t             p_pid;    // プロセスID
  struct proc      *p_pptr;   // 親プロセスのproc構造体へのポインタ
  struct pgrp      *p_pgrp;   // 当該プロセスが属するプロセスグループのpgrp構造体へのポインタ
  LIST_ENTRY(proc)  p_pglist; // プロセスグループの前後のプロセスへのポインタを収めたproc構造体
};
```

### `vnode`構造体
- 端末制御装置をオープンすると割り付けられる
- プロセスでの`/dev/tty`への参照は`vnode`構造体を介して行われる
```c
struct vnode {
  void *v_data;
};
```

## 解釈実行ファイル(shebang)
- `#!`から始まるテキストファイル
  - 引数として渡したファイルを実行する
```
#! /path/to/実行したいファイル オプションの引数
```
- 解釈実行ファイルはシステムコールの処理の一環としてカーネル内で認識される
- ファイル中にインタプリタのパス名を記述することによって
  スクリプトファイルを外部コマンドとして実行できるようになる
```
# ./xxx.sh

#!/bin/bash

echo 'Hello'

# 実行許可を与える - $ chmod +x xxx
# 外部コマンドとして実行できるようになる - $ ./xxx -> Hello
```

## プロセスの実行記録
- プロセスが終了すると`/var/log/account/pacct`に保存される
- `acct(2)` - プロセスの実行記録をON/OFF
```c
// <sys/acct.h>
struct acct {
    char      ac_flag;     // 実行中の事象を記録するフラグ
    u_int16_t ac_uid;      // 実ユーザーID
    u_int16_t ac_gid;      // 実グループID
    u_int16_t ac_tty;      // 制御端末
    u_int32_t ac_btime;    // 開始時間
    comp_t    ac_utime;    // ユーザーCPU時間
    comp_t    ac_stime;    // システムCPU時間
    comp_t    ac_etime;    // 経過時間
    comp_t    ac_mem;      // 平均使用メモリ量
    comp_t    ac_io;       // 読み書きによる転送バイト数
    comp_t    ac_rw;       // 読み書きしたブロック数
    char      ac_comm[17]; // 17文字
};

// ac_flag
//   AFORK - forkされたプロセスがexecを呼んでいない
//   ASU   - SU特権を使ったプロセス
//   ACORE - コアダンプしたプロセス
//   AXSIG - シグナルでkillされたプロセス
```

## プロセススケジューリング
- プロセスは自身のナイス値を上げることによりスケジューリング優先度を下げることができる
  - スーパーユーザーのみがナイス値を下げることができる
- 子プロセスは親プロセスからナイス値を継承する
- `nice(2)` - -20~20の範囲で指定された値にナイス値を変更
- `getpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を取得
- `setpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を変更
