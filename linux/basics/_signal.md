# シグナル(ソフトウェア割り込み)
- 参照: 例解UNIX/Linuxプログラミング教室P323-374

## TL;DR
- シグナルはプロセスに対して非同期的に送られる通知
- シグナルは`<signal.h>`にマクロとして定義されており、コンパイル時に整数に展開される

### シグナルのライフサイクル
1. プロセスに対してシグナルが生起
2. シグナルの保留
3. プロセスに対してシグナルが配送
    - プロセスがシグナルをブロックしている場合
      プロセスがシグナルをアンブロックするか無視するまで
      シグナルは保留される

### シグナルの処理
- シグナルを受け取ったカーネルが行う動作
  - 無視
  - デフォルト動作
    - 終了
    - 終了 + コアダンプ(`core`ファイル生成)
    - プロセス停止
  - 捕捉
    - シグナルハンドラ実行

### シグナルの生起条件
- 端末生起シグナル
  - `SIGINT`
- ハードウェア例外
  - `SIGSEGV`
- ソフトウェア条件
  - `SIGURG`
  - `SIGPIPE`
  - `SIGALRM`
    - プロセスは一つのアラームクロックを持つ
    - `alarm(3)` - 指定された秒数が経過した後に`SIGALRM`を送信
- `kill(1)` / `kill(2)` / `raise(3)`
  - `kill`  - 指定のプロセス・プロセスグループに任意のシグナルを送信する
    - `pid > 0` - 指定したPIDを持つ子プロセス
    - `pid == 0` - 親プロセスと同じプロセスグループに属する子プロセス
    - `pid == -1` - 任意の子プロセス(`wait`と同じ)
    - `pid < -1` - プロセスグループIDが指定したPIDの絶対値に等しい子プロセス
  - `raise` - 自プロセスに任意のシグナルを送信する

### シグナルを送信する条件
- 送信側の実ユーザーIDあるいは実行ユーザーIDが
  受信側の実ユーザーIDあるいは保存セットユーザーIDに一致していること

## シグナルの割り込みに対する処理
- 特定のシステムコールにおいては、割り込み後プロセスがシグナルごとに自動的に再起動を行う
  - `ioctl(2)` / `read(2)` / `readv(2)` / `write(2)` / `writev(2)` / `wait(2)` / `waitpid(2)`
- プロセスがシグナルごとに自動再起動を停止することもできる

## シグナルハンドラ
- 「シグナルの捕捉」 - シグナルハンドラを使ってシグナルを処理すること
- 捕捉されたシグナルをプロセスで処理するとき、
  プロセスが実行中の命令列はシグナルハンドラによって一時的に中断される
  -> シグナルハンドラから戻ると元々プロセスが実行していた命令列に戻る
  - プロセスが非同期シグナル安全な関数を実行していた場合、
    シグナルによって一貫性を失うときはシグナルをブロックする
  - スレッドごとに`errno`の値は一つしかないため、
    シグナルハンドラが再入可能な関数を呼ぶと、
    値が上書きされる可能性がある
- `signal(2)` - 指定のシグナルを受信した際、指定の関数(シグナルハンドラ)を実行する
  - プロセスがシグナルを受け取った際、それまで実行していたプログラムは一時停止する
  - プロセスはいつシグナルを受け取るかわからない
  - `handler`型 - 引数が`int`、返り値が`void`である関数型
  - OSによって挙動が異なる、シグナルが紛失する場合がある、受け取れる情報が少ないなどの問題がある
    -> `signal(2)`の代わりに`sigaction(2)`を使用する
- `sigaction(2)` - 指定のシグナルを受信した際の新しい動作と以前の動作をそれぞれ`sigaction`構造体に保存する
```c
// sigaction構造体
struct sigaction {
  sigset_t sa_mask;  // シグナルマスク(シグナルハンドラ実行中にブロックするシグナルの設定)
  int      sa_flags; // オプション設定フラグ

  // どちらか一つだけ設定
  void (*sa_handler)(int);                        // 引数が一つのシグナルハンドラ
  void (*sa_sigaction)(int, siginfo_t *, void *); // 引数が三つのシグナルハンドラ
};

// sigactionの設定
// struct sigaction xxx;
// act.sa_hander = シグナルハンドラ
// act.sa_flags  = シグナルハンドラ実行中の動作を設定
// sigemptyset(&xxx.sa_mask);
// sigaction(シグナル, &xxx, NULL);
```

### シグナルマスクの設定
- シグナルマスク - 各プロセスが持つブロック中のシグナルの集合
  - シグナルに対するビットがON = シグナルをブロックしている
- `sigset_t` - シグナルの集合を表すシステムデータ型
  - `sigemptyset(3)` - シグナル集合を空にする
  - `sigfillset(3)` - シグナル集合に全てのシグナルを加える
  - `sigaddset(3)` - シグナル集合に任意のシグナルを加える
  - `sigdelset(3)` - シグナル集合から任意のシグナルを削除
  - `sigismember(3)` - シグナル集合に任意のシグナルが含まれるか確認
- `sigprocmask(2)` - プロセスのシグナルマスクの設定と検査
- `sigpending(2)` - 呼び出したプロセスが配送をブロックしているシグナルの集合を検査
- `sigsuspend(2)` - シグナルのブロック解除から再ブロックまでをatomicに実行
  - `sigprocmask`(ブロック解除) -> `pause`(待機) -> `sigprocmask`(ブロックを元に戻す)

## シグナル待機
- `pause(3)` - シグナルが来るまで以降の操作をブロックする
  - `pause`する前にシグナルが届いた場合、ブロックが永遠に解除されない

## race condition
- シグナルによる処理は非同期であるためrace conditionを招く場合がある
  - race condition   - プログラムの実行順やタイミングに依存して意図しない実行結果を招くこと
  - critical section - race conditionの原因となるプログラム部分
    - 排他制御・割り込みの禁止などを行いrace conditionを避けるようにする
  - atomicな処理     - 実行途中の状態を他のプロセス・スレッド・シグナルハンドラから見えないようにした処理

### グローバル変数へのアクセス
- `volatail`宣言 - `この変数は非同期的に変更されるため、最適化を行わない`とコンパイラに伝える
  - 最適化 -> レジスタへのキャッシュなど
  - グローバル変数に対して`volatail`をつける
- atomicにアクセスできるという保証がなければ、`sigprocmask`で囲んでシグナルをブロックするようにする

## シグナルハンドラ中に呼ぶことができる関数
- 非同期シグナル安全な関数
  - 再入可能関数 - ある関数を実行中に、更にその関数を呼び出すことができる関数(非破壊的関数)
  - シグナルが割り込めない関数
