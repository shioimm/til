# ソケット
- 参照: 例解UNIX/Linuxプログラミング教室P291-322
- 参照: 詳解UNIXプログラミング第3版 16. ネットワークIPC: ソケット

## TL;DR
### ソケット
- ネットワークを跨いだプロセス間通信を行う双方向インターフェース
  - ソケットに書く   -> 他のプロセスにデータが送信される
  - ソケットから読む -> 他のプロセスからデータを受信する
- ソケットディスクリプタ - プロセスとソケットを結びつける記述子
  - ソケットディスクリプタはファイルディスクリプタとして実装される
  - ソケットにはファイルオフセットの概念がない
- ソケットはバイトストリームを送受信する
  - ファイルと違い、位置決めはできない

## 操作
#### サーバープロセスが使用するシステムコール
1. `socket`
2. `bind`
3. `listen`
4. `accept`
5. `read` / `recv` / `write` / `send`
6. `shutdown`
7. `close`

#### クライアントプロセスが使用するシステムコール
1. `socket`
2. `connect`
3. `read` / `recv` / `write` / `send`
4. `shutdown`
5. `close`

### `socket(2)`
- プロセスに新しいソケットを一つ作成し、ソケットディスクリプタを返す
  - アドレス形式 - 通信領域(通信手段)
    - `AF_INET`  - INET領域(IPv4によるTCP/IPを使用したプロセス間通信)
    - `AF_INET6` - INET6領域(IPv6によるTCP/IPを使用したプロセス間通信)
    - `AF_UNIX`  - UNIX領域(同一コンピュータ内のプロセス間通信)
    - `AF_UNSPEC` - 規定なし
    - 通信領域によってプロトコルファミリとアドレスファミリが決定する
  - ソケット種別 - 通信形式
    - `SOCK_STREAM` - 順序・信頼性・双方向・コネクション型バイトストリーム
    - `SOCK_DGRAM`  - 固定長・非信頼性・コネクションレス型データグラム
  - プロトコル
    - ソケット種別によりデフォルトプロトコルが決まる
- ソケットを作成した時点で相手となるプロセス(入出力する対象)は指定されない

### `bind(2)`
- プロセスが紐づいているソケットに固有の名前をつける
  - IPアドレス - ポート番号の組
  - 接続受け付け時、相手となるプロセスが送信先を決定する際に必要となる
- `bind(2)`を呼ぶ前にソケット固有の名前のデータを作成する必要がある
  - `sockaddr`構造体 - ソケット固有の名前のデータを保存する汎用アドレス構造体

### サーバー: `listen(2)`
- クライアントプロセスからの接続を受け付ける
  - ソケットに接続要求を入れるための待ち行列を付け、受付を開始する
  - 待ち行列の長さを指定する

### サーバー: `accept(2)`
- クライアントプロセスからの接続要求を受け入れてコネクションを確立する
  - クライアントプロセスからの接続要求は一度待ち行列に入り、
    サーバープロセスが`accept`を呼ぶ度に先頭から順に受け入れられる
  - 待ち行列が空の場合、要求が来るまでサーバープロセスは待ち状態になる
  - クライアントプロセスからの接続要求を受け入れると、
    `accept`がそのコネクションが繋がった新しいサーバーソケット(接続済みソケット)を作り、
    そのソケットディスクリプタを返す(コネクションの確立)
  - 元のサーバーソケット(接続待ちソケット)は次の接続要求に対して`accept`を呼ぶ
    - 以下繰り返し
  - 予めクライアントソケットの名前を受け取るためのメモリ領域を確保しておき、
    接続要求を受け入れた際にクライアントソケットの名前を保存する

### クライアント: `connect(2)`
- サーバープロセスに接続要求を出す
  - 接続先のサーバーソケット固有の名前を指定する
  - 接続要求に使用されたソケットが直接サーバーソケットとコネクションを確立する
    - クライアントプロセスでは新しいソケットは作成されない

### 読み書き
- 読み - `read(2)` / `recv(2)`
  - ソケットから読めるデータがない場合、`read`の呼び出しがブロックする
  - ストリームから1バイトも読み込めなかった場合、EOFを意味する
- 書き - `write(2)` / `send(2)`
  - ネットワークにデータを送信するため、
    `write`はカーネル内にあるネットワーク用バッファにデータを置く
  - 利用できるバッファがない場合、`write`の呼び出しがブロックする

### `shutdown(2)`
- 指定したソケットの入出力を停止する
  - `SHUT_RD` - 受信の停止
  - `SHUT_WR` - 送信の停止
  - `SHUT_RDWR` - 送受信の停止

#### `close(2)`との違い
- `shutdown(2)`はソケットを参照する使用中のディスクリプタの個数に関係なくソケットを非活性化できる
  - `close(2)`は使用中の最後の参照がクローズされた時にのみネットワークの端点を解放する
- `shutdown(2)`はソケットの一方向の通信を止めることができる

### `close(2)`
- ソケットディスクリプタを閉じる
  - ソケットを参照している全てのソケットディスクリプタが閉じると
    ソケットは廃棄される

## アドレシング
- 通信先となるプロセスを識別する
  - ネットワークアドレス - ネットワーク上のコンピュータを識別
  - ポート番号 - コンピュータ上の特定のプロセスの識別

### バイトオーダー
- マルチバイトデータ型のバイトの配置順序
- プロセッサアーキテクチャによって変わる
  - リトルエンディアン - 最高位バイトアドレスが最上位バイト(MSB)
  - ビッグエンディアン - 最高位バイトアドレスが最下位バイト(LSB)
  - TCP/IPプロトコルはビッグエンディアン
    - 通信時、ホストバイトオーダーをネットワークバイトオーダーにに合わせる必要がある
- `htonl(3)` - ネットワークバイトオーダーでの32ビット整数を返す
- `htons(3)` - ネットワークバイトオーダーでの16ビット整数を返す
- `ntohl(3)` - ホストバイトオーダーでの32ビット整数を返す
- `ntohs(3)` - ホストバイトオーダーでの16ビット整数を返す

### アドレス形式
- 特定の通信ドメイン内のソケット端点を識別する
- サーバーソケット・クライアントソケットで同じ型の構造体を使用する

```c
// sockaddr構造体 - 汎用アドレス構造体

struct sockaddr {
  sa_family_t sa_family; // アドレスファミリ
  char        sa_data[]; // 可変長アドレス
};
```

```c
// sockaddr_in構造体 - TCP(IPv4)を使用する際に使用するsockaddr構造体

struct sockaddr_in {
  sa_family_t    sin_family;  // アドレスファミリ(AF_INET)
  in_port_t      sin_port;    // ポート番号
  struct in_addr sin_addr;    // IPv4アドレス(INADDR_ANY)
};

// INET6領域のアドレスファミリを使用する場合はsockaddr_in6構造体
// UNIX領域のアドレスファミリを使用する場合はsockaddr_un構造体を使用する
```

```c
// in_addr構造体 - IPアドレスを記述する構造体

struct in_addr {
  inaddr_t s_addr; // IPv4アドレス
};

// IPv6アドレスを扱う場合はin6_addr構造体を使用する

// sin_portとs_addrはマルチバイト整数・ビッグエンディアン(ネットワークバイトオーダ)
```
- `inet_ntop(3)` - ネットワークバイトオーダーのバイナリアドレスをテキスト文字列に変換
- `inet_pton(3)` - テキスト文字列をネットワークバイトオーダーの
バイナリアドレスに変換

#### IPアドレス
- `INADDR_ANY`
  - 自ホストが複数のIPアドレスを持っている場合、
    どのアドレス宛て入力でもポート番号が合っていれば受け付ける
    - ネットワークインターフェースにつけられているIPアドレス
    - ループバックアドレス(自ホストのIPアドレス)

## 並行サーバー
### マルチプロセス
1. サーバープロセスが接続待ちソケットに対して`accept(2)`を行い、
   サーバープロセスがクライアントプロセスからの接続要求を待つ
2. サーバープロセスとクライアントプロセス間のコネクションが確立し、
   `accept(2)`が接続済みソケットを返す
3. サーバープロセスがforkし子サーバープロセスを作成する
4. 子サーバープロセスが接続待ちソケットディスクリプタを`close(2)`する
5. 子サーバープロセスが接続済みソケットでクライアントプロセスと通信する
6. 子サーバープロセスは通信が終了すると`exit(2)`する
   親サーバープロセスは接続済みソケットディスクリプタを閉じる

### 入出力の多重化
- 一つのプロセスで複数の入出力を扱う
  - サーバーソケットは`accept(2)`や`read(2)`の段階で
    クライアントプロセスからの入力待ちになる可能性がある
  - 複数のソケットディスクリプタを監視する場合、
    準備ができたディスクリプタを特定する必要がある
- `select(2)` - 監視する対象のディスクリプタ群を指定し、準備ができたディスクリプタ数を返す
  - `fd_set readfds`  - 読み込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set writefds` - 書き込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set errorfds` - エラーになった際に通知する対象のディスクリプタ群
  - `fd_set`型 - 複数のディスクリプタを保持できるシステムデータ型
    - `FD_ZERO`  - 指定した`fd_set`型のデータの全ビットを0にする
    - `FD_SET`   - `fd_set`にディスクリプタを追加する
    - `FD_CLR`   - `fd_set`からディスクリプタを削除する
    - `FD_ISSET` - `fd_set`にディスクリプタが含まれていれば0以外、含まれていなければ0を返す

## ホスト名からIPアドレスへの変換
- `gethostbyname(3)` - 指定したホスト名をIPアドレスに変換し`hostent`構造体へのポインタを返す
```c
// hostent構造体
struct  hostent {
  char *h_name;       // ホストの正式名
  char **h_aliases;   // ホストの別名の配列
  int  h_addrtype;    // アドレスファミリ(AF_INET)
  int  h_length;      // アドレスのバイト数(4)
  char **h_addr_list; // IPアドレスの配列
};

// エラーコード
// HOST_NOT_FOUND ホストが存在しない
// NO_DATA        適切なIPアドレスが見つからない
// NO_RECOVERY    検索中のエラー
// TRY_AGAIN      要再試行
```

## プロトコル独立
- 特定のプロトコル(アドレスファミリ)に依存しない実装
- `getaddrinfo(3)` - アドレスの情報を格納する`addrinfo`構造体型のリストを得る
```c
// addrinfo構造体

struct addrinfo {
  int             ai_family;     // アドレスファミリ(AF_UNSPEC)
  int             ai_socktype;   // ソケットの型
  struct sockaddr *ai_addr;      // sockaddr構造体(ソケットアドレス)へのポインタ
  struct addrinfo *ai_next;      // アドレスリンクリストの次の要素
};
```
