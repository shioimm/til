# ソケット
- 参照: 例解UNIX/Linuxプログラミング教室P291-322

## TL;DR
### ソケット
- プロセス間通信を行うためのインターフェースの一つ
  - ソケットに書く   -> 他のプロセスにデータが送信される
  - ソケットから読む -> 他のプロセスからデータを受信する
- ソケットディスクリプタ - プロセスとソケットを結びつける記述子
- ソケットはバイトストリームを送受信する
  - ファイルと違い、位置決めはできない

## 操作
#### サーバープロセスが使用するシステムコール
1. `socket`
2. `bind`
3. `listen`
4. `accept`
5. `read` / `recv` / `write` / `send`
6. `shutdown`
7. `close`

#### クライアントプロセスが使用するシステムコール
1. `socket`
2. `connect`
3. `read` / `recv` / `write` / `send`
4. `shutdown`
5. `close`

### `socket(2)`
- プロセスに新しいソケットを一つ作成し、ソケットディスクリプタを返す
  - 通信領域 - 通信手段
    - `AF_INET`  - INET領域(IPv4によるTCP/IPを使用したプロセス間通信)
    - `AF_INET6` - INET6領域(IPv6によるTCP/IPを使用したプロセス間通信)
    - `AF_UNIX`  - UNIX領域(同一コンピュータ内のプロセス間通信)
    - 通信領域によってプロトコルファミリとアドレスファミリが決定する
  - ソケットの型 - 通信形式
    - `SOCK_STREAM` - コネクション型(バイトストリームによる)通信
    - `SOCK_DGRAM`  - コネクションレス型(データグラムによる)通信
- ソケットを作成した時点で相手となるプロセス(入出力する対象)は指定されない

### `bind(2)`
- プロセスが紐づいているソケットに固有の名前をつける
  - IPアドレス - ポート番号の組
  - 接続受け付け時、相手となるプロセスが送信先を決定する際に必要となる
- `bind(2)`を呼ぶ前にソケット固有の名前のデータを作成する必要がある

#### `sockaddr`構造体
- ソケット固有の名前のデータを保存する構造体
- サーバーソケット・クライアントソケットで同じ型の構造体を使用する
```
// sockaddr_in構造体 - TCPを使用する際に使用するsockaddr構造体
struct sockaddr_in {
  sa_family_t    sin_family;  // アドレスファミリ(AF_INET)
  in_port_t      sin_port;    // ポート番号
  struct in_addr sin_addr;    // IPアドレス(INADDR_ANY)
};

// in_addr構造体 - IPアドレスを記述する構造体
struct in_addr {
  inaddr_t s_addr;
};

// sin_portとs_addrはマルチバイト整数・ビッグエンディアン(ネットワークバイトオーダ)
//   htons(3) - ホストバイトオーダで表現された16ビット整数をネットワークバイトオーダに変換
//   htonl(3) - ホストバイトオーダで表現された32ビット整数をネットワークバイトオーダに変換
```

#### IPアドレス
- `INADDR_ANY`
  - 自ホストが複数のIPアドレスを持っている場合、
    どのアドレス宛て入力でもポート番号が合っていれば受け付ける
    - ネットワークインターフェースにつけられているIPアドレス
    - ループバックアドレス(自ホストのIPアドレス)

### サーバー: `listen(2)`
- クライアントプロセスからの接続を受け付ける
  - ソケットに接続要求を入れるための待ち行列を付け、受付を開始する
  - 待ち行列の長さを指定する

### サーバー: `accept(2)`
- クライアントプロセスからの接続要求を受け入れてコネクションを確立する
  - クライアントプロセスからの接続要求は一度待ち行列に入り、
    サーバープロセスが`accept`を呼ぶ度に先頭から順に受け入れられる
  - 待ち行列が空の場合、要求が来るまでサーバープロセスは待ち状態になる
  - クライアントプロセスからの接続要求を受け入れると、
    `accept`がそのコネクションが繋がった新しいサーバーソケット(接続済みソケット)を作り、
    そのソケットディスクリプタを返す(コネクションの確立)
  - 元のサーバーソケット(接続待ちソケット)は次の接続要求に対して`accept`を呼ぶ
    - 以下繰り返し
  - 予めクライアントソケットの名前を受け取るためのメモリ領域を確保しておき、
    接続要求を受け入れた際にクライアントソケットの名前を保存する

### クライアント: `connect(2)`
- サーバープロセスに接続要求を出す
  - 接続先のサーバーソケット固有の名前を指定する
  - 接続要求に使用されたソケットが直接サーバーソケットとコネクションを確立する
    - クライアントプロセスでは新しいソケットは作成されない

### 読み書き
- 読み - `read(2)` / `recv(2)`
  - ソケットから読めるデータがない場合、`read`の呼び出しがブロックする
  - ストリームから1バイトも読み込めなかった場合、EOFを意味する
- 書き - `write(2)` / `send(2)`
  - ネットワークにデータを送信するため、
    `write`はカーネル内にあるネットワーク用バッファにデータを置く
  - 利用できるバッファがない場合、`write`の呼び出しがブロックする

### `shutdown(2)`
- 指定したソケットの入出力を停止する
  - `SHUT_RD`   - 受信の停止
  - `SHUT_WR`   - 送信の停止
  - `SHUT_RDWR` - 送受信の停止

### `close(2)`
- ソケットディスクリプタを閉じる
  - ソケットを参照している全てのソケットディスクリプタが閉じると
    ソケットは廃棄される

## 並行サーバー
### マルチプロセス
1. サーバープロセスが接続待ちソケットに対して`accept(2)`を行い、
   サーバープロセスがクライアントプロセスからの接続要求を待つ
2. サーバープロセスとクライアントプロセス間のコネクションが確立し、
   `accept(2)`が接続済みソケットを返す
3. サーバープロセスがforkし子サーバープロセスを作成する
4. 子サーバープロセスが接続待ちソケットディスクリプタを`close(2)`する
5. 子サーバープロセスが接続済みソケットでクライアントプロセスと通信する
6. 子サーバープロセスは通信が終了すると`exit(2)`する
   親サーバープロセスは接続済みソケットディスクリプタを閉じる

### 入出力の多重化
- 一つのプロセスで複数の入出力を扱う
  - サーバーソケットは`accept(2)`や`read(2)`の段階で
    クライアントプロセスからの入力待ちになる可能性がある
  - 複数のソケットディスクリプタを監視する場合、
    準備ができたディスクリプタを特定する必要がある
- `select(2)` - 監視する対象のディスクリプタ群を指定し、準備ができたディスクリプタ数を返す
  - `fd_set readfds`  - 読み込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set writefds` - 書き込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set errorfds` - エラーになった際に通知する対象のディスクリプタ群
  - `fd_set`型 - 複数のディスクリプタを保持できるシステムデータ型
    - `FD_ZERO`  - 指定した`fd_set`型のデータの全ビットを0にする
    - `FD_SET`   - `fd_set`にディスクリプタを追加する
    - `FD_CLR`   - `fd_set`からディスクリプタを削除する
    - `FD_ISSET` - `fd_set`にディスクリプタが含まれていれば0以外、含まれていなければ0を返す

## ホスト名からIPアドレスへの変換
- `gethostbyname(3)` - 指定したホスト名をIPアドレスに変換し`hostent`構造体へのポインタを返す
```c
// hostent構造体
struct  hostent {
  char *h_name;       // ホストの正式名
  char **h_aliases;   // ホストの別名の配列
  int  h_addrtype;    // アドレスファミリ(AF_INET)
  int  h_length;      // アドレスのバイト数(4)
  char **h_addr_list; // IPアドレスの配列
};

// エラーコード
// HOST_NOT_FOUND ホストが存在しない
// NO_DATA        適切なIPアドレスが見つからない
// NO_RECOVERY    検索中のエラー
// TRY_AGAIN      要再試行
```
