# 共有ライブラリ
- 参照: Linuxプログラミングインターフェース 2章 / 41章

## TL;DR
- 一箇所に置いたライブラリ関数を複数のプロセスが実行時に共有する仕組み

## オブジェクトライブラリ
- 複数のオブジェクトファイルを一つにまとめたもの

### 実行ファイルの作成
- ソースファイルをそれぞれコンパイルし、オブジェクトファイルを生成後、
  全オブジェクトファイルをリンクすることで実行ファイルを作成する

### 種類
- スタティックライブラリ
- 共有ライブラリ

## スタティックライブラリ(アーカイブ)
- オブジェクトファイルのコピーをすべて包含したファイル
  - 内部のオブジェクトファイルにはいくつかの属性が付与される
    - ファイルパーミッション
    - ユーザーID
    - グループID
    - 最終更新時刻
- プログラムにスタティックライブラリをリンクすると、
  実行ファイルは必要なオブジェクトファイルのコピーを内部に包含する

### 利点
- 広く利用する複数のオブジェクトファイルを一つのライブラリファイルにまとめる
  -> アプリケーションビルド時、ソースファイルを再コンパイルせずに複数の実行ファイルへリンクできる
- リンク実行時にスタティックライブラリファイル名のみを与える
  -> リンクコマンドラインが簡潔になる

### 欠点
- 同じオブジェクトファイルが別のプログラム内部にそれぞれ含まれるためディスク容量を消費する
- 異なるプログラムでも内部で同じモジュールを使用する実行ファイルを複数同時に実行すると、
  それぞれが仮想メモリ内にオブジェクトモジュールのコピーを持つことになり、
  仮想メモリ消費増大につながる
- スタティックライブラリ内部のオブジェクトモジュールを変更した場合、
  リンクしている全ての実行ファイルに対して再リンクが必要になる

### ファイル名
- `libアーカイブ名.a`とする

### 作成方法
```
$ ar options libarchive.a object-file.o ...
```

#### 処理の種類
- `r` - replace
  - アーカイブへオブジェクトファイルを追加し、
    同名のオブジェクトファイルがある場合は上書きする
- `t` - table of contents
  - アーカイブの内容を一覧表示する
- `d` - delete
  - 指定したオブジェクトファイルをアーカイブから削除する

### 実行ファイルへのリンク方法
- リンク時のコマンドラインにスタティックライブラリ名を指定する

```
$ gcc -g -c prog.c # プログラムをコンパイル
$ gcc -g -o prog prog.o libarchive.a
```

- ファイル名から`lib`と`.a`を削除したライブラリ名を`-l`で指定する
```
# リンカが標準で検索するディレクトリへスタティックライブラリが置かれている場合
# (/usr/libなど)
$ gcc -g -o prog prog.o -larchive

# リンカが標準で検索するディレクトリへスタティックライブラリが置かれていない場合
$ gcc -g -o prog prog.o -Ldirname -larchive
```

## 共有ライブラリ
- ひとつのオブジェクトモジュールを全実行ファイルで共有するためのファイル
- オブジェクトモジュールを実行ファイルへコピーせず共有ライブラリ間で別途管理する
- プログラムに共有ライブラリをリンクしても
  実行ファイルはオブジェクトモジュールをコピーせず、
  そのモジュールを必要とするプログラムを初めて実行した際にライブラリをメモリへロードする
  - その後に同じモジュールを使用する他のプログラムを実行すると、
    メモリにロード済みのライブラリを使用する
- 共有ライブラリには作成時にELFヘッダが付与される
  - ELFヘッダはsonameを含む

### 利点
- 実行ファイルが消費するディスク容量・実行時の仮想メモリサイズを削減できる
- プログラムサイズ全体を削減できる -> プログラムのメモリへのロード時間を短縮できる
- オブジェクトモジュールを変更した場合、
  リンクしている実行ファイルに対して再リンクせずに変更を反映させることができる

### 欠点
- スタティックライブラリよりも複雑化する
- PICでコンパイルする必要がある
- 実行時にシンボル再配置を行い、共有ライブラリ内でのシンボル参照を
  仮想メモリ内の実行時配置に対応させる必要がある
  - 再配置処理のためスタティックライブラリのリンクよりも若干時間がかかる

### ELF形式
- Executable and Linking Format
- UNIXシステムで実行ファイル・共有ライブラリに採用されているファイル形式
- `a.out` / COFF形式を置き換えるもの

### PIC
- 位置独立コード(配置非依存コード)
- 仮想アドレス空間内のどこへでも配置可能であり、実行時に動的に位置を決定するコード
- PICはレジスタを余計に使用するためオーバーヘッドを伴う

### 作成方法
#### スタティックライブラリを共有ライブラリ化する
```
# プログラムをコンパイルし、オブジェクトモジュールを作成
$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c

# オブジェクトモジュールを共有ライブラリにまとめる
$ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o

# 上記を一度に行う
$ gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so
```

#### 標準規約に沿って共有ライブラリを作成する
```
# プログラムをコンパイルし、オブジェクトファイルを作成
$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c

# real nameがlibrealname.so.1.0.1、sonameがlibsoname.so.1の共有ライブラリを作成
$ gcc -g -shared -Wl,-soname,libsoname.so.1 -o librealname.1.0.1 mod1.o mod2.o mod3.o

# soname / linker nameのシンボリックリンクを作成
$ ln -s librealname.so.1.0.1 libsoname.so.1
$ ln -s libsoname.so.1 libliknername.so

# プログラムを実行
$ gcc -g -Wall -o prog prog.c -L -llinkername
$ LD_LIBRARY_PATH=. ./prog
```

### 実行ファイルへのリンク方法
- 実行時に必要となる共有ライブラリを特定する
  - 実行ファイルリンク時に共有ライブラリ名が埋め込まれる
    - ELFでは依存ライブラリを`DT_NEEDED`タグをつけ実行ファイル内に埋め込む
  - ダイナミック依存リスト - プログラムが依存するライブラリ一覧
- 実行時に埋め込まれた共有ライブラリ名を解決し、メモリへロードする(ダイナミックリンク)

#### ダイナミックリンカ(ダイナミックリンクローダー)
- 共有ライブラリ`/lib/ld-linux.so.2`
- 共有ライブラリを使用する全てのELF実行ファイルのダイナミックリンクを行う
- 実行ファイルが必要とする共有ライブラリ一覧を検査し、
  規定の規則に従ってファイルシステム内のライブラリファイルを検索する

#### ダイナミックリンカの検索対象ディレクトリ
- `/usr/lib` - 最も標準的なライブラリをインストールするディレクトリ
- `/lib` - システム起動時に必要なライブラリをインストールするディレクトリ
- `/usr/local/lib` - 非標準・開発中のライブラリをインストールするディレクトリ
- `etc/ld.so.conf`に記述したディレクトリ
- プログラム実行時に環境変数`LD_LIBRARY_PATH`で指定されたディレクトリ
- スタティックリンク時に実行ファイル内に埋め込まれたパスの指すディレクトリ
  - `$ gcc -g -Wall -Wl,-rpath,/path/to/dir -o prog prog.c libdemo.so`
  - `-rpath`オプションは別ディレクトリに置かれた別共有ライブラリに依存する
    共有ライブラリとのリンクにも使用できる

### soname
- 実行ファイルに埋め込まれる共有オブジェクトライブラリ名
- 共有ライブラリ作成時に名前を指定することができる
- sonameを指定していない共有ライブラリの場合、
  ダイナミックリンク時に実行ファイルに
  共有ライブラリファイルの実際の名前(real name)が埋め込まれる

```
# 共有ライブラリlibfoo.soにsonameとしてlibbar.soをつけるようリンカに指示
$ gcc -g -shared -Wl -soname, libbar.so -o libfoo.so mod1.o mod2.o mod3.o

# 既存の共有ライブラリのsonameを確認する
$ objdmp  -p libfoo.so | grep SONAME
$ readelf -d libfoo.so | grep SONAME

# sonameを持つ共有ライブラリをプログラムにリンクして実行ファイルを作成
# (リンカが実行ファイルにsonameであるlibbar.soを埋め込む)
$ gcc -g -Wall -o prog prog.c libfoo.so

# ダイナミックリンカがlibbar.soを解決できるようにするため、
# real nameであるlibfoo.soへのシンボリックリンクをsonameで作成
$ ln -s libfoo.so libbar.so

# プログラムを実行
$ LD_LIBRARY_PATH=. ./prog
```

### バージョン命名規則
- real name - `librealname.so.major-id.minor.id`
  - ライブラリコードを持つファイル
  - メジャーバージョン + マイナーバージョンにつき一つ存在する
- soname - `libsoname.so.major-id`
  - メジャーバージョンにつき一つ存在する
  - 実行ファイルとのリンク時に埋め込まれ、実行時に検索される名前
  - 最新バージョンのreal nameへのシンボリックリンク
  - real nameのライブラリと同じディレクトリ下に相対パスのシンボリックリンクとして作成される
  - real nameと同じメジャーバージョンでの最新マイナーバージョンを指す
- linker name - `libliknername.so`
  - バージョンに依存しない共有ライブラリと実行ファイルとのリンクに使用される名前
  - バージョンを問わず一つだけ存在する
  - 最新バージョンのreal nameへのシンボリックリンク

### 課題
- 共有ライブラリは様々なディレクトリへ置かれる
- 新バージョンのライブラリがインストールされたり、
  旧バージョンのライブラリが削除されたりした際、
  sonameのシンボリックリンクが取り残される可能性がある

### 実行時シンボル解決
- メインプログラム内のグローバルシンボル定義はライブラリ内の定義よりも優先する
- グローバルシンボルが複数のライブラリ内で定義されている場合、
  スタティックリンク時に指定されたライブラリの並びを左から右へ検索し、
  最初に認識した定義を優先する
- 共有ライブラリ内でのグローバルシンボル参照にライブラリ内での定義を優先する場合は
  共有ライブラリビルド時に`-Bsymbolic`オプションを与える

## 共有ライブラリ関連ツール
### `ldd(1)`
- list dynamic dependencies
- プログラム・共有ライブラリの実行に必要な共有ライブラリを表示する
- ダイナミックリンカと同じ検索規則に従い、参照するライブラリを解決する

### `objdmp(1)` / `readelf(1)`
- 共有ライブラリ、実行ファイル、オブジェクトファイルの解析に役立つ各種情報を表示する
  - 実行ファイル、オブジェクトファイル、共有ライブラリから逆アセンブルしたマシン語
  - ELFセクションヘッダなど
- `objdmp(1)` / `readelf(1)`では表示形式が異なる

### `nm(1)`
- オブジェクトライブラリ、実行ファイル内のシンボルを表示する

### `ldconfig(8)`
- 標準ディレクトリを読み取り、全てのライブラリのキャッシュを
  `/etc.ld.cache`ファイルへキャッシュする
  - `/etc/ld.so.conf`に記述されたディレクトリ -> `/lib` -> `/usr/lib`
- ライブラリのメジャーバージョンごとに最新マイナーバージョンを確認し、
  埋め込まれたsonameを検索する
  得られたsonameから同一ディレクトリ内のシンボリックリンクを作成・更新する
- ライブラリを新規インストールした際、既存のライブラリを更新・削除した際、
  `/etc/ld.so.conf`の内容を更新した際は必ず実行する
