# プログラムの実行
## `execve(2)`の動作
- プロセスのメモリ空間へ新たなプログラムをロードする
- それまで実行されていたプログラムは破棄される
　プロセスのスタック・データ・ヒープの各セグメントは
  新しいプログラム用に置き換えられる
  - `execve(2)`呼び出し時点で標準入出力ライブラリのバッファに残っているデータは
    呼び出しが成功すると捨てられる
- Cライブラリランタイムスタートアップコード、プログラムの初期化コード実行後、
  新しいプログラムの`main`関数へ制御を移す

## プロセスが`exec()`の前後で引き継ぐ情報
- PID / PPID
- ユーザーID / グループID
- 環境
- umask値
- シグナルマスク・シグナルハンドラの設定
- ファイルディスクリプタ
  - オープンしてあるディレクトリストリームは`exec`後にクローズ
- 作業ディレクトリ
- シグナルマスク
- リソースリミット
- 制御端末
- そのプロセスがそれまでに利用した資源の情報

## `exec`関数群
- いずれも`内部でexecve(2)`を実行する

| 関数名     | プログラム名(-, p)  | パラメータ(v, l) | 元にする環境(e, -)    |
| -          | -                   | -                | -                     |
| `execve(2)`| パス名              | 配列             | 引数`envp`            |
| `execle(2)`| パス名              | 文字列リスト     | 引数`envp`            |
| `execlp(2)`| ファイル名 + `PATH` | 文字列リスト     | 自プロセスの`environ` |
| `execvp(2)`| ファイル名 + `PATH` | 配列             | 自プロセスの`environ` |
| `execv(2)` | パス名              | 配列             | 自プロセスの`environ` |
| `execl(2)` | パス名              | 文字列リスト     | 自プロセスの`environ` |

### `spawn(2)`
- `fork(2)` + `exec()`
- ワンショットでのプロセス作成 -> 実行

## コマンド実行
- 自プロセスから任意のシェルコマンドを実行する
  - 子プロセスを作成し、シェルを実行し、シェル内でコマンドを実行する
  - `fork()` / `exec()` / `wait()` / `exit()`をコーディングしなくて済む
  - エラー処理、シグナル処理を`system(2)`に任せることができる
  - 最低でもプロセスを２つ作成する必要がある
  - 外部プログラムを実行する必要がある場合は使用を避ける

## インタプリタのスクリプト
- インタプリタ - テキスト形式のコマンドを読み取り、実行するプログラム
  - Ex. UNIX各種コマンド / `awk` / `sed` / `perl` / `ruby`
  - 対話的にコマンドを読み取り・解釈・実行する
  - テキストファイル(スクリプト)からコマンドを読み取り・解釈・実行する

### カーネルによるスクリプトファイルの実行
1. スクリプトファイルに実行許可ビットをセットする
2. スクリプトファイルの先頭行に実行するインタプリタのパス名を記述する(shebang)
    - `#!interpreter-path [optional-arg]`
3. シェル上でスクリプトファイルを呼び出す
    - スクリプトファイルからインタプリタのパス名と引数、
      プログラムが実行する`execve(2)`からスクリプトのパス名とパラメータと環境が
      インタプリタへ渡される

## ファイルディスクリプタ
- `exec`を実行するプログラムがオープンしたファイルディスクリプタは
  `exec`後もオープンしたまま新規ファイルへ引き継がれる(Ex. IOリダイレクション)

### close-on-execフラグ(`FD_CLOEXEC`)
- close-on-execフラグがセットされているファイルディスクリプタは
  `exec()`時に自動的にクローズする
  - `exec()`時にエラーが発生した場合はオープンされたまま残る
  - `fnctl(fd, F_GETFD)`でclose-on-execが設定されているか確認できる
- `dup(2)` / `dup2(2)` / `fnctl(2)`によって複製されたファイルディスクリプタでは
  close-on-execフラグはクリアされている

## シグナル
### シグナルハンドラ
- `exec()`は自プロセスのシグナルハンドラを破棄する
  - テキストセグメントごと破棄されるため
- ハンドラを設定したシグナルは`SIG_DFL`へリセットされる
- ハンドラを設定していないシグナルはデフォルト動作のまま
  - `SIGCHLD`の動作は未定義
    - `SIGCHLD`の可搬性のために`exec()`前に`signal(SIGCHLD, SIG_DFL)`しておく

### シグナル処理専用スタック
- `exec()`は自プロセスのシグナル処理専用スタックを破棄する
  - データ、スタック、ヒープセグメントごと破棄されるため
- すべてのシグナルで`SA_ONSTACK`フラグはクリアされる

### シグナルマスク・保留中のシグナル
- exec()``後もプロセスのシグナルマスク・保留中のシグナルは存続する
- 任意のプログラムの`exec()`前にはシグナルのブロックや無視をする設定は
  行わないことが推奨される

## 参照
- 例解UNIX/Linuxプログラミング教室P185-224
- 詳解UNIXプログラミング第3版 7. プロセスの環境 / 8. プロセスの制御 / 9. プロセスの関係
- Linuxプログラミングインターフェース 2章 / 6章 / 27章
