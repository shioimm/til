# プロセスグループ、セッション、ジョブコントロール
- 参照: Linuxプログラミングインターフェース 34章

## TL;DR
- プロセスグループ、セッション - プロセス間に二段階の階層構造を生成するもの
  - プロセスグループ - 関係を持つ複数のプロセスからなる集合
  - セッション - 関係を持つ複数のプロセスグループからなる集合
  - プロセスグループ・セッションはシェルのジョブコントロールを実現するための抽象概念
- ジョブコントロール - コマンドのフォアグランド / バックグラウンド実行に関する操作

### 例示
- インタラクティブログインにおいて
  - 制御端末 - ログインした端末
  - セッションリーダー / 制御プロセス - ログインシェル
  - 新規プロセス・新規プロセスグループ - シェルから実行したコマンド
  - フォアグラウンドプロセスグループ - シェルから実行したコマンド
  - バックグラウンドプロセスグループ - シェルから`&`を付加して実行したコマンド

## プロセスグループ
- 同じプロセスグループIDを共有する一つまたは複数のプロセスの集合
- プロセスグループの作成者であるプロセスをプロセスグループリーダーとする
  - プロセスグループリーダーは自身のプロセスIDをプロセスグループIDとする
- 新規プロセスは親プロセスと同じプロセスグループに入る

### `pgrp`構造体
```c
struct pgrp {
  pid_t              pg_id;      // プロセスグループID
  struct session    *pg_session; // プロセスグループが属するセッションのsession構造体
  LIST_HEAD(, proc)  pg_members; // 当該プロセスグループのメンバに対するproc構造体のリストへのポインタ
};
```

### `proc`構造体
```c
struct proc {
  pid_t             p_pid;    // プロセスID
  struct proc      *p_pptr;   // 親プロセスのproc構造体へのポインタ
  struct pgrp      *p_pgrp;   // 当該プロセスが属するプロセスグループのpgrp構造体へのポインタ
  LIST_ENTRY(proc)  p_pglist; // プロセスグループの前後のプロセスへのポインタを収めたproc構造体
};
```

### プロセスグループのライフタイム
1. プロセスグループリーダーがプロセスグループを作成する
2. プロセスグループから全てのメンバープロセスがいなくなると終了する

### プロセスがプロセスグループから抜けるケース
- プロセスが終了する
- 他のプロセスグループへ移動する

## セッション
- 同じセッションIDを共有するプロセスの集合であるプロセスグループの集合
- セッションを開始したプロセスをセッションリーダーとする
  - セッションリーダーは自身のプロセスIDをセッションIDとする
- 新規プロセスは親プロセスと同じセッションに入る
- 一つのセッション内には1個のフォアグラウンドプロセスグループと
  0個以上のバックグラウンドプロセスグループが入っている
- デーモンプロセス - 制御端末を持たないプロセス

### 制御端末との関係
- セッション内の全プロセスは同じ制御端末を共有する
- セッションリーダーが最初に接続を確立(オープン)した端末デバイスを制御端末とする
  = 制御端末との接続を確立したセッションリーダーはその端末の制御プロセスになる
  - 端末デバイスは同時に複数のセッションの制御端末になることができない
  - 制御端末との接続が切断されるとカーネルが制御プロセスへ`SIGHUP`シグナルを送信する
- セッション内のプロセスグループのうち、
  同時に一つだけが端末のフォアグラウンドプロセスグループになれる
  - 残りのプロセスグループはバックグラウンドプロセスグループとして動作する
  - 制御端末からの入力を受け取れるのはフォアグラウンドプロセスグループのみ
    - 割り込みキー、終了キー、一時停止キーが送信するシグナルは
      フォアグラウンドプロセスグループ内の全プロセスが受け取る

### `session`構造体
- 各セッションごとに割り付けられる
```c
struct session {
  int          s_count  // プロセスグループの個数 / 0になると構造体を解放
  struct proc *s_leader // セッションリーダー構造体procへのポインタ
  struct vnode *s_ttyvp  // 制御端末構造体vnodeへのポインタ
  struct tty   *s_ttyp   // 制御端末構造体ttyへのポインタ
  pid_t         s_sid    // セッションID
};
```

## 制御端末 / 制御プロセス
- セッション内のプロセスは一つの制御端末(`/dev/tty`)を持つことができる
  - 新規セッションは制御端末を持たない
  - セッションリーダーが他のセッションの制御端末ではない端末を
    最初に(`O_NOCTTY`をセットせず)オープンすると制御端末との接続が確立される
- セッションリーダーは制御端末をオープンするとその端末の制御プロセスになる

### `tty`構造体
```c
struct tty {
  struct session *t_session; // この端末を制御端末とするsession構造体
  struct pgrp    *t_pgrp;    // フォアグラウンドプロセスグループのpgrp構造体
  struct termios  t_termios; // 当該端末に関する情報を集めたtermios構造体
  struct winsize  t_winsize; // 端末ウィンドウサイズを収めたwinsize構造体
};
```

### `vnode`構造体
- 端末制御装置をオープンすると割り付けられる
- プロセスでの`/dev/tty`への参照は`vnode`構造体を介して行われる
```c
struct vnode {
  void *v_data;
};
```

### 制御端末の切断
- `ioctl(fd, TIOCNOTTY)`を実行した場合
  - `fd` - 制御端末のファイルディスクリプタ
    - 制御端末のファイルディスクリプタは`/dev/tty`で得られる
- モデムの信号が途絶え、端末ドライバが切断状態を判断した場合
- 端末ウィンドウが閉じれらた場合

### 制御端末を切断時に発生すること
- セッション内の全プロセスが制御端末を失う
- 制御端末は対応するセッションを失う
- カーネルが制御プロセスへ`SIGHUP`シグナルを送信する
  -> `SIGHUP`シグナルが制御プロセスを終了させる
  -> フォアグラウンドプロセスグループ内の全メンバーへ`SIGHUP`シグナルが送信される
  -> `SIGHUP`シグナルがフォアグラウンドプロセスグループ内の全メンバーを終了させる
  - バックグラウンドグループには影響しない
  - `SIGHUP`シグナルは他のプロセスに伝播することがある

## フォアグラウンドプロセスグループ / バックグラウンドプロセスグループ
- 制御端末を自由に読み書きできるのはフォアグラウンドプロセスグループのみ
- フォアグラウンドプロセスグループになれるのは一度に一プロセスグループのみ
  - それ以外の全てのプロセスグループはバックグラウンドプロセスグループになる
- ジョブコントロールに対応するため、端末ドライバは制御端末のフォアグラウンドプロセスグループを管理する
  - シグナルを生成する特殊なキーが入力されると
    端末ドライバがフォアグラウンドプロセスグループの全メンバーにシグナルを送信する
- ジョブコントロールによりフォアグラウンドとバックグラウンドの入れ替えも可能
- セッション内でフォアグラウンドプロセスグループが終了した後、
  孤児になったバックグラウンドプロセスグループが発生した場合、
  かつ孤児プロセスグループ中に一時中断したプロセスがある場合
  カーネルは孤児プロセスグループへ`SIGHUP`と`SIGCONT`を送信する
- バックグラウンドプロセスはそのまま動作を続ける

## ジョブコントロール
- ジョブ - プロセスグループのうち、ユーザーが端末から実行したコマンド
  - パイプ`|`でつなげたコマンド同士は一つのジョブ(一つのプロセスグループ)
  - アンパサンド`&`でつなげたコマンド同士は別のジョブ(別のプロセスグループ)
- ジョブコントロール - シェルから同時に複数のコマンドを実行・一時停止・再開する機能
  - ジョブコントロールにおいてはシェルがセッションリーダーとなる
  - ユーザーが単体の端末から複数のジョブを操作し、
    どのジョブに端末へのアクセスを許し、
    どのジョブをバックグラウドで動かすかを制御する

### ジョブコントロールの要件
- ジョブ内の全プロセスは同一プロセスグループに所属する必要がある
- 子プロセスが`exec()`する前にプロセスグループの移動を終える必要がある

### ジョブコントロールの状態
- フォアグラウンド実行
- バックグラウンド実行
- バックグラウンド一時停止
- 終了

### 使用方法
#### バックグラウンドジョブの起動
- 実行するコマンドの末尾に`&`をつけるとバックグラウンドジョブになる
  - バックグラウンドジョブにはシェルによって一意なジョブ番号が割り振られる
  - バックグラウンドジョブ起動時にはジョブ番号・コマンドのプロセスIDが表示される

#### ジョブ一覧の確認
```
$ jobs
```

#### バックグラウンドジョブをフォアグラウンドジョブにする
```
$ fg %ジョブ番号
```

#### フォアグラウンドジョブの一時停止
- `SIGTSTP`シグナル
  - 端末操作`Ctrl` + `Z`

#### バックグラウンドジョブの一時停止
- `kill -STOP %ジョブ番号`
- `SIGTTIN`シグナル
  - バックグラウンドから制御端末を読み取ろうとした場合
- `SIGTTOU`シグナル
  - バックグラウンドから`TOSTOP`フラグをセットした制御端末へ書き込もうとした場合
    - ジョブをフォアグラウンドにすると書き込みされる

#### 停止中ジョブの再開
- `SIGCONT`シグナル(フォアグラウンドで実行再開)
  - `$ fg %ジョブ番号`
- `SIGCONT`シグナル(バックグラウンドで実行再開)
  - `$ bg %ジョブ番号

#### ジョブの終了
- `SIGINT`シグナル
  - フォアグラウンドから端末操作`Ctrl` + `C`
- `SIGQUIT`シグナル
  - フォアグラウンドから端末操作`Ctrl` + `\`
- `SIGKILL`シグナル
  - バックグラウンドから`$ kill`

