# プロセス
- 参照: 例解UNIX/Linuxプログラミング教室P185-224
- 参照: 詳解UNIXプログラミング第3版 7. プロセスの環境 / 8. プロセスの制御 / 9. プロセスの関係
- 参照: Linuxによる並行プログラミング入門 第2章 プロセスの変身とシェル 2.3
- 参照: Linuxプログラミングインターフェース 2章 / 6章 / 24章 / 28章

## TL;DR
- プログラムの実行中の姿
  - 「プログラムの実行に必要なシステムリソースを割り当てるため、カーネルが定義する抽象エンティティ」
  - プログラム - 実行中にどのようなプロセスが作成されるかを記したファイル
  - プログラムが起動される
    -> カーネルがプログラムの実行コードを仮想メモリにロードする
    -> カーネルがプログラム内の変数の領域を割り当てる
    -> カーネルがプロセスに関する様々な情報を管理するカーネル内のデータを更新する
  -  プログラムが終了する
    - カーネルがプロセスの使用していたリソースを解放する

## カーネルから見てプロセスを構成するもの
- ユーザー空間メモリ
  - プログラムコード
  - 変数など
- プロセスの状態を管理するカーネルデータ
  - プロセスに関する各種識別子
  - 仮想メモリテーブル
  - ファイルディスクリプタテーブル
  - シグナル配送 / ハンドラ情報
  - リソース消費・上限
  - カレントワーキングディレクトリ
  - その他

## プログラムに含まれる内容
- バイナリ形式種別
  - ELFが使用される(過去には`a.out` -> COFFが使用されていた)
- 機械語命令
- 実行開始アドレス
- データ
- シンボル、リロケーションテーブル
  - 関数・変数名とその位置を表すテーブル
- 共有ライブラリ・ダイナミックリンク情報
- その他

## プロセス情報
- 一意なプロセスID
  - プロセスが終了した場合そのプロセスIDは別のプロセスに再利用される可能性がある
- 独立した仮想アドレス空間
  - 仮想アドレス空間と物理アドレス空間の紐付けは
    カーネル内の各プロセスごとのページテーブルによって管理される
- 実効ユーザーID / 実ユーザーID / 保存セットユーザーID
- 実効グループID / 実グループID / 保存セットグループID / 補助グループID群

## プロセスの制御関数
- 新しいプロセスの作成 - `fork`関数群
- プログラムの実行 - `exec`関数群
- プロセスの終了 - `exit`関数群
- 終了するプロセスの待ち合わせ - `wait`関数群

## プログラムとプロセス
- プログラムはファイルシステムの中に実行可能ファイルとして存在する
- 実行可能ファイルを実行するとプロセスが生成される
  - 関数`main`の先頭が呼ばれた時点
- プロセスはプログラム終了時消える
  - `exit`が呼ばれた時点
- ファイルを複数回実行すると複数の独立したプロセスが生成される

## プロセスの状態遷移
- ready状態
  - ready状態にあるプロセスの数が多い時は処理の待ち行列に入る
  - カーネルのスケジューリングアルゴリズムにより優先度の高い順にCPUが与えられる
- running状態
- 実行後
  - zombie状態
    - 親が`wait`することで消滅の手順に入る
    - 親はゾンビ状態の子プロセスのログをカーネル内のプロセステーブルからコピーし記録する
    - 子プロセスはプロセステーブルから削除され、完全に消滅する
  - ready状態
    - 実行時間が長くクオンタム(単位時間)を過ぎた場合、
      カーネルがプロセスからCPUを取り上げプロセスをready状態に戻す
    - 次のプロセススケジューリングのタイミングで再びrunning状態になる
  - wait状態
    - プロセスが`sleep`を呼び出した場合など、
      カーネルがプロセスからCPUを取り上げプロセスをwait状態にする
    - `sleep`時間が経過したり他のプロセスからwakeupされるとプロセスはready状態になる
  - stop状態
    - プロセスへsuspend signalが送信された場合、
      カーネルがプロセスからCPUを取り上げプロセスをstop状態にする
    - resume signalが送信されるとプロセスはready状態になる

### 割り込み可能 / 不可のスリープ
- `TASK_INTERRUPTIBLE`
  - プロセスが何らかのイベント(端末からの入力、パイプへの書き込みetc)を待っている
  - この状態でプロセスへシグナルが送信されると
    スリープ状態は割り込まれ、プロセスはウェイクアップされる
- `TASK_UNINTERRUPTIBLE`
  - プロセスが特定のイベント(ディスクIOの完了etc)を待っている
  - この状態でプロセスへシグナルが送信されると
    状態が遷移するまで受信されない
- `TASK_KILLABLE`
  - `TASK_UNINTERRUPTIBLE`と同じ
  - 強制的にプロセスを終了させるシグナルが送信された場合終了する

## プロセスID
- プロセスを一意に識別するための整数
- LinuxにおいてプロセスIDはデフォルトで32767以下
  - `/proc/sys/kernel/pid_max`に定義されている
  - 32767を超えると300以上の使用可能な値にリセットされる
- システムの全プロセスはプロセスID 1(`init`)をルートとした木構造
- `PID 0` - スケジューラプロセス / スワッパー
  - カーネルの一部・システムプロセス
- `PID 1` - `init`プロセス(`/sbin/init`プログラムから生成される)
  - ブート手続きの最後にカーネルが起動するプロセス
  - システム依存の初期化ファイル群を読み取り、システムを起動させる
  - 孤児プロセスが発生した場合の親となる

## プロセスアカウンティング
- プロセスアカウンティングを有効にすると、プロセス終了時に
  そのプロセスの統計情報をプロセスアカウンティングファイルへ記録することができる
  - プロセス終了順に記録される
- `acct(2)`でプロセスアカウンティングファイルを指定することで有効化する
- カーネルのオプション機能であり、`CONFIG_BSD_PROCESS_ACCT`を有効化する必要がある
- 新しいファイルフォーマットを利用する場合は`CONFIG_BSD_PROCESS_ACCT_V3`を有効化する必要がある

## リソースリミット
- 各プロセスにはリソースの制限がある
  - 使用可能メモリの最大サイズ
  - コアファイルのバイト単位の最大サイズ
  - CPU時間の秒単位の最大量 など
- `getrlimit(2)` - リソースリミットを取得
- `setrlimit(2)` - リソースリミットを変更
```c
struct rlimit {
  rlim_trlim_cur; // ソフトリミット - 現在値
  rlim_trlim_max; // ハードリミット - 上限
};
```
- プロセスは自身のハードリミットまでソフトリミットを変更できる
- プロセスは自身のソフトリミットまでハードリミットを減少できる
- スーパーユーザーがハードリミットを増加させることができる

## シェルの入出力リダイレクト
- `fork` `exec`におけるファイルディスクリプタの引き継ぎを利用して実現されている
```
(1) 親プロセスがコマンドを受け取る
(2) 親プロセスが子プロセスをfork
(3) 子プロセスは親プロセスのファイルディスクリプタを引き継ぐ
(4) 子プロセスがリダイレクトに不要なファイルディスクリプタを閉じる
(5) 子プロセスがリダイレクトに必要なファイルディスクリプタを開く
(6) 子プロセスが親プロセスから引き継いだコマンドを実行
```

## `init`(現在は`systemd`に代替される)
- 全てのプロセスの先祖
- 孤児プロセスは`init`が親プロセスとなり`wait`する
  - 孤児プロセス - 自身の終了前に親プロセス(プロセスグループリーダー)が終了したプロセス
    - 同一セッション内の他プロセスグループ内に親プロセスを持つメンバープロセスが存在しないプロセスグループが孤児になる

## カーネルプロセス
- カーネルの中にあるプログラムの動作
  - プロセススケジューリングを行うプロセス
  - 仮想記憶に関する処理を行うプロセス など

## プロセススケジューリング
- プロセスは自身のナイス値を上げることによりスケジューリング優先度を下げることができる
  - スーパーユーザーのみがナイス値を下げることができる
- 子プロセスは親プロセスからナイス値を継承する
- `nice(2)` - -20~20の範囲で指定された値にナイス値を変更
- `getpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を取得
- `setpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を変更

## 特権プロセス
- 実効ユーザーID`0`(スーパーユーザー)のプロセス
- 特権プロセスが作成したプロセス
