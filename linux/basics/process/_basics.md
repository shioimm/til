# プロセス
- 参照: 例解UNIX/Linuxプログラミング教室P185-224
- 参照: 詳解UNIXプログラミング第3版 7. プロセスの環境 / 8. プロセスの制御 / 9. プロセスの関係
- 参照: Linuxによる並行プログラミング入門 第2章 プロセスの変身とシェル 2.3
- 参照: Linuxプログラミングインターフェース 2章 / 6章 / 24章

## TL;DR
- プログラムの実行中の姿
  - 「プログラムの実行に必要なシステムリソースを割り当てるため、カーネルが定義する抽象エンティティ」
  - プログラム - 実行中にどのようなプロセスが作成されるかを記したファイル
  - プログラムが起動される
    -> カーネルがプログラムの実行コードを仮想メモリにロードする
    -> カーネルがプログラム内の変数の領域を割り当てる
    -> カーネルがプロセスに関する様々な情報を管理するカーネル内のデータを更新する
  -  プログラムが終了する
    - カーネルがプロセスの使用していたリソースを解放する

## カーネルから見てプロセスを構成するもの
- ユーザー空間メモリ
  - プログラムコード
  - 変数など
- プロセスの状態を管理するカーネルデータ
  - プロセスに関する各種識別子
  - 仮想メモリテーブル
  - ファイルディスクリプタテーブル
  - シグナル配送 / ハンドラ情報
  - リソース消費・上限
  - カレントワーキングディレクトリ
  - その他

## プログラムに含まれる内容
- バイナリ形式種別
  - ELFが使用される(過去には`a.out` -> COFFが使用されていた)
- 機械語命令
- 実行開始アドレス
- データ
- シンボル、リロケーションテーブル
  - 関数・変数名とその位置を表すテーブル
- 共有ライブラリ・ダイナミックリンク情報
- その他

## プロセス情報
- 一意なプロセスID
  - プロセスが終了した場合そのプロセスIDは別のプロセスに再利用される可能性がある
- 独立した仮想アドレス空間
  - 仮想アドレス空間と物理アドレス空間の紐付けは
    カーネル内の各プロセスごとのページテーブルによって管理される
- 実効ユーザーID / 実ユーザーID / 保存セットユーザーID
- 実効グループID / 実グループID / 保存セットグループID / 補助グループID群

## プロセスの制御関数
- 新しいプロセスの作成 - `fork`関数群
- プログラムの実行 - `exec`関数群
- プロセスの終了 - `exit`関数群
- 終了するプロセスの待ち合わせ - `wait`関数群

## プログラムとプロセス
- プログラムはファイルシステムの中に実行可能ファイルとして存在する
- 実行可能ファイルを実行するとプロセスが生成される
  - 関数`main`の先頭が呼ばれた時点
- プロセスはプログラム終了時消える
  - `exit`が呼ばれた時点
- ファイルを複数回実行すると複数の独立したプロセスが生成される

## プロセスの状態遷移
- ready状態
  - ready状態にあるプロセスの数が多い時は処理の待ち行列に入る
  - カーネルのスケジューリングアルゴリズムにより優先度の高い順にCPUが与えられる
- running状態
- 実行後
  - zombie状態
    - 親が`wait`することで消滅の手順に入る
    - 親はゾンビ状態の子プロセスのログをカーネル内のプロセステーブルからコピーし記録する
    - 子プロセスはプロセステーブルから削除され、完全に消滅する
  - ready状態
    - 実行時間が長くクオンタム(単位時間)を過ぎた場合、
      カーネルがプロセスからCPUを取り上げプロセスをready状態に戻す
    - 次のプロセススケジューリングのタイミングで再びrunning状態になる
  - wait状態
    - プロセスが`sleep`を呼び出した場合など、
      カーネルがプロセスからCPUを取り上げプロセスをwait状態にする
    - `sleep`時間が経過したり他のプロセスからwakeupされるとプロセスはready状態になる
  - stop状態
    - プロセスへsuspend signalが送信された場合、
      カーネルがプロセスからCPUを取り上げプロセスをstop状態にする
    - resume signalが送信されるとプロセスはready状態になる

### 割り込み可能 / 不可のスリープ
- `TASK_INTERRUPTIBLE`
  - プロセスが何らかのイベント(端末からの入力、パイプへの書き込みetc)を待っている
  - この状態でプロセスへシグナルが送信されると
    スリープ状態は割り込まれ、プロセスはウェイクアップされる
- `TASK_UNINTERRUPTIBLE`
  - プロセスが特定のイベント(ディスクIOの完了etc)を待っている
  - この状態でプロセスへシグナルが送信されると
    状態が遷移するまで受信されない
- `TASK_KILLABLE`
  - `TASK_UNINTERRUPTIBLE`と同じ
  - 強制的にプロセスを終了させるシグナルが送信された場合終了する

## プロセスID
- プロセスを一意に識別するための整数
- LinuxにおいてプロセスIDはデフォルトで32767以下
  - `/proc/sys/kernel/pid_max`に定義されている
  - 32767を超えると300以上の使用可能な値にリセットされる
- システムの全プロセスはプロセスID 1(`init`)をルートとした木構造
- `PID 0` - スケジューラプロセス / スワッパー
  - カーネルの一部・システムプロセス
- `PID 1` - `init`プロセス(`/sbin/init`プログラムから生成される)
  - ブート手続きの最後にカーネルが起動するプロセス
  - システム依存の初期化ファイル群を読み取り、システムを起動させる
  - 孤児プロセスが発生した場合の親となる

## リソースリミット
- 各プロセスにはリソースの制限がある
  - 使用可能メモリの最大サイズ
  - コアファイルのバイト単位の最大サイズ
  - CPU時間の秒単位の最大量 など
- `getrlimit(2)` - リソースリミットを取得
- `setrlimit(2)` - リソースリミットを変更
```c
struct rlimit {
  rlim_trlim_cur; // ソフトリミット - 現在値
  rlim_trlim_max; // ハードリミット - 上限
};
```
- プロセスは自身のハードリミットまでソフトリミットを変更できる
- プロセスは自身のソフトリミットまでハードリミットを減少できる
- スーパーユーザーがハードリミットを増加させることができる

## シェルの入出力リダイレクト
- `fork` `exec`におけるファイルディスクリプタの引き継ぎを利用して実現されている
```
(1) 親プロセスがコマンドを受け取る
(2) 親プロセスが子プロセスをfork
(3) 子プロセスは親プロセスのファイルディスクリプタを引き継ぐ
(4) 子プロセスがリダイレクトに不要なファイルディスクリプタを閉じる
(5) 子プロセスがリダイレクトに必要なファイルディスクリプタを開く
(6) 子プロセスが親プロセスから引き継いだコマンドを実行
```

## `init`(現在は`systemd`に代替される)
- 全てのプロセスの先祖
- 孤児プロセスは`init`が親プロセスとなり`wait`する
  - 孤児プロセス - 自身の終了前に親プロセスが終了したプロセス

## カーネルプロセス
- カーネルの中にあるプログラムの動作
  - プロセススケジューリングを行うプロセス
  - 仮想記憶に関する処理を行うプロセス など

## プロセスグループ
- 参照: 例解UNIX/Linuxプログラミング教室P366-
- プロセスグループ - プロセスの集まり
  - 同一ジョブに関連づけられ、同一端末からシグナルを受け取る
  - 同じプロセスグループに属するプロセスは同じシグナルを受け取る
  - グループ内に最低一つのプロセスがあればグループは存在し続ける

### プロセスグループの種類
- フォアグラウンドプロセスグループ   - 端末を介してユーザーと対話中のプロセスグループ(一セッションにつき一つ)
  - `tcgetpgrp(3)` - フォアグラウンドプロセスグループIDを取得
  - `tcsetpgrp(3)` - フォアグラウンドプロセスグループを変更
  - 端末ドライバに対して入出力を行うことができる
  - 端末ドライバは端末生起シグナル(`SIGINT` / `SIGQUIT` / `SIGSTP`)を送信できる
- バックグラウンドプロセスグループ - フォアグラウンドプロセスグループ以外の全てのプロセスグループ

  - 端末ドライバからの読み取りで`SIGTTIN`を生起する
  - 端末ドライバへの書き出しで`SIGTTOU`を生起する

### プロセスグループリーダー
- プロセスIDとプロセスグループIDが等しいプロセス
- グループ内にプロセスを作成し、終了できる
- `getpgid(2)` - 自プロセスのプロセスグループリーダーのプロセスIDを取得
- `setpgid(2)` - 新しいプロセスグループを作り、そこに移動する
  - プロセスグループを作ったプロセスがプロセスグループリーダーになる

### ジョブ
- プロセスの集まり
- プロセスグループのうち、ユーザーが端末から実行したコマンド
  - パイプ`|`でつなげたコマンド同士は一つのジョブ(一つのプロセスグループ)
  - アンパサンド`&`でつなげたコマンド同士は別のジョブ(別のプロセスグループ)

#### ジョブ制御
- ユーザーが単体の端末から複数のジョブを操作し、
  どのジョブに端末へのアクセスを許し、
  どのジョブをバックグラウドで動かすかを制御する
  - `^Z` - フォアグラウンドのジョブをバックグラウンドにして一時中断
  - `bg(1)` - 一時中断状態のジョブをバックグラウンドで実行再開
  - `fg(1)` - バックグラウンドのジョブをフォアグラウンドで実行
- ジョブ制御はシグナルを利用して行われる
  - `SIGCHID` - 子プロセスが停止 / 終了
  - `SIGCONT` - 停止していたプロセスが再開
  - `SIGSTOP` - 停止シグナル(補足も無視もできない)
  - `SIGTSTP` - 対話的停止シグナル
    - Ctrl + Z -> フォアグラウンドプロセスグループ内の全メンバに送信される
  - `SIGTTIN` - バックグラウンドプロセスグループのメンバが制御端末を読み取る
  - `SIGTTOUT` - バックグラウンドプロセスグループのメンバが制御端末に書き出す

## セッション
- プロセスグループの集まり
  - 端末上でジョブ制御の影響が及ぶ範囲
  - 一つのセッション内には1個のフォアグラウンドプロセスグループと
    0個以上のバックグラウンドプロセスグループが入っている
- セッションは1個の制御端末を持つことができる
  - ユーザーが端末ログインした端末装置
  - ユーザーがネットワークログインした擬似端末装置
- 制御プロセス - 制御端末との接続を確立しているセッションリーダープロセス
- デーモンプロセス - 制御端末を持たないプロセス
- ログイン時や`init`起動時に自動的に新しいセッションが作られ、制御端末が設定される
- `setsid(2)` - 新しいセッションを作る
  - `setsid(2)`を読んだプロセスがプロセスグループリーダーでない場合、
    -> 当該プロセスは新たなセッションのセッションリーダーとなる
    -> 当該プロセスは新たなプロセスグループのプロセスリーダーとなる
    -> 当該プロセスの制御端末を解除する
  - `setsid(2)`を読んだプロセスがプロセスグループリーダーの場合、エラーを返す
  - デーモンプロセスや端末エミュレータを作る時に使用する

### 制御端末とフォアグラウンドプロセスグループの関係
- セッションに制御端末がある場合、そのセッションには一つのフォアグラウンドプロセスグループがある
  - セッション内の別のプロセスグループはすべてバックグラウンドプロセスグループになる
- フォアグラウンドプロセスグループ中のプロセスは制御端末への入出力が可能
- 制御端末から`^C` / `^\` / `^Z`を押すと
  制御端末はフォアグラウンドプロセスグループ中の全プロセスへ
  `SIGINT` / `SIGQUIT` / `SIGTSTP` を送信する

### 制御端末とバックグラウンドプロセスグループの関係
- バックグラウンドプロセスグループ中のプロセスは制御端末への入出力が不可能
- 制御端末からデータを入力する場合、制御端末はそのプロセスに`SIGTTIN`を送信する
  - `SIGTTIN`のデフォルトの動作は一時中断
- 制御端末への出力が許されるかどうかは端末の設定による

### 制御端末と制御プロセスの関係
- (遠隔操作等で)制御端末が切断を検出すると、
  カーネルは制御プロセス(セッションリーダー)へ`SIGHUP`を送信する
  - `SIGHUP`のデフォルトの動作は終了
- 制御プロセスが終了すると、
  カーネルは制御プロセスを切り離してフォアグラウンドプロセスグループへ`SIGHUP`を送信する
- フォアグラウンドプロセスグループが終了した後、
  孤児になったバックグラウンドプロセスグループが発生した場合、
  かつ孤児プロセスグループ中に一時中断したプロセスがある場合
  カーネルは孤児プロセスグループへ`SIGHUP`と`SIGCONT`を送信する
- バックグラウンドプロセスはそのまま動作を続ける

### `session`構造体
- 各セッションごとに割り付けられる
```c
struct session {
  int          s_count  // プロセスグループの個数 / 0になると構造体を解放
  struct proc *s_leader // セッションリーダー構造体procへのポインタ
  struct vnode *s_ttyvp  // 制御端末構造体vnodeへのポインタ
  struct tty   *s_ttyp   // 制御端末構造体ttyへのポインタ
  pid_t         s_sid    // セッションID
};
```

### `tty`構造体
```c
struct tty {
  struct session *t_session; // この端末を制御端末とするsession構造体
  struct pgrp    *t_pgrp;    // フォアグラウンドプロセスグループのpgrp構造体
  struct termios  t_termios; // 当該端末に関する情報を集めたtermios構造体
  struct winsize  t_winsize; // 端末ウィンドウサイズを収めたwinsize構造体
};
```

### `pgrp`構造体
```c
struct pgrp {
  pid_t              pg_id;      // プロセスグループID
  struct session    *pg_session; // プロセスグループが属するセッションのsession構造体
  LIST_HEAD(, proc)  pg_members; // 当該プロセスグループのメンバに対するproc構造体のリストへのポインタ
};
```

### `proc`構造体
```c
struct proc {
  pid_t             p_pid;    // プロセスID
  struct proc      *p_pptr;   // 親プロセスのproc構造体へのポインタ
  struct pgrp      *p_pgrp;   // 当該プロセスが属するプロセスグループのpgrp構造体へのポインタ
  LIST_ENTRY(proc)  p_pglist; // プロセスグループの前後のプロセスへのポインタを収めたproc構造体
};
```

### `vnode`構造体
- 端末制御装置をオープンすると割り付けられる
- プロセスでの`/dev/tty`への参照は`vnode`構造体を介して行われる
```c
struct vnode {
  void *v_data;
};
```

## プロセスの実行記録
- プロセスが終了すると`/var/log/account/acct`に保存される
- `acct(2)` - プロセスの実行記録をON/OFF
```c
// <sys/acct.h>
struct acct {
    char      ac_flag;     // 実行中の事象を記録するフラグ
    u_int16_t ac_uid;      // 実ユーザーID
    u_int16_t ac_gid;      // 実グループID
    u_int16_t ac_tty;      // 制御端末
    u_int32_t ac_btime;    // 開始時間
    comp_t    ac_utime;    // ユーザーCPU時間
    comp_t    ac_stime;    // システムCPU時間
    comp_t    ac_etime;    // 経過時間
    comp_t    ac_mem;      // 平均使用メモリ量
    comp_t    ac_io;       // 読み書きによる転送バイト数
    comp_t    ac_rw;       // 読み書きしたブロック数
    char      ac_comm[17]; // 17文字
};

// ac_flag
//   AFORK - forkされたプロセスがexecを呼んでいない
//   ASU   - SU特権を使ったプロセス
//   ACORE - コアダンプしたプロセス
//   AXSIG - シグナルでkillされたプロセス
```

## プロセススケジューリング
- プロセスは自身のナイス値を上げることによりスケジューリング優先度を下げることができる
  - スーパーユーザーのみがナイス値を下げることができる
- 子プロセスは親プロセスからナイス値を継承する
- `nice(2)` - -20~20の範囲で指定された値にナイス値を変更
- `getpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を取得
- `setpriority(2)` - プロセス、プロセスグループ、ユーザのナイス値を変更

## 特権プロセス
- 実効ユーザーID`0`(スーパーユーザー)のプロセス
- 特権プロセスが作成したプロセス
