# 高度な入出力
- 参照: 詳解UNIXプログラミング第3版 14. 高度な入出力

## 非ブロック入出力
- IO待ちにて入出力操作を完了できない場合、操作をブロックする代わりにエラーを返す入出力
  - ファイルステータスフラグに`O_NONBLOCK`をON

## レコードロック(バイト範囲ロック)
- あるプロセスがファイルのある部分を読んだり修正しているとき、
  他プロセスが当該ファイルの当該部分を修正することを防ぐ能力
  - `fcntl(2)`の第二引数に`F_GETLK` / `F_SETLK` / `F_SETLKW`、
    第三引数に`flock`構造体へのポインタを渡す
```c
struct flock {
  short l_type;   // ロック種別 - F_RDLCK / F_WRLCK / F_UNLK
  short l_whence; // 範囲の開始バイトオフセット - SEEK_SET / SEEK_CUR / SEEK_END
  off_t l_start;  // 範囲の開始バイトオフセット - l_whence相対のバイトオフセット
  off_t l_len;    // 範囲のバイト単位の長さ
  pid_t l_pid;    // プロセスをブロックするロックを保持しているプロセスID
};
```
- 二つのプロセスが相手がロックしたリソースを互いに持ち合っている場合、デッドロックが発生する

### ロックコマンド
- `F_GETLK` - 指定のロックが他のロックでブロックされるかどうか調べる
- `F_SETLK` - 指定のロックを設定する / できない場合はエラーを返す
- `F_SETLKW` - 指定のロックを設定する / できない場合は処理をブロックする

### ロック種別
- 共有リードロック(`F_RDLCK`) / 排他ライトロック(`F_WRLCK`)
  - あるバイトに対して複数のプロセスが`F_RDLCK`を持てる
  - あるバイトに対して単一のプロセスが`F_WRLCK`を持てる
  - あるバイトに`F_RDLCK`がある場合当該のバイトに`F_WRLCK`はできない
  - あるバイトに`F_WRLCK`がある場合当該のバイトに`F_RDLCK`はできない
- 同じプロセスが同じバイトに対して複数のロックを保とうとする場合は新しいロックが既存のロックを上書きする

### 暗黙の継承と解放
- ロックはプロセスとファイルに付随する
  - プロセスが終了するとロックは解放される
  - ファイルディスクリプタを閉じると当該プロセスの当該ディスクリプタが参照するファイルの任意のロックが解放される
- ロックは`fork`をまたいで子プロセスには継承されない
  - 子プロセスは他プロセスとみなされる
- ロックは`exec`をまたいで新しいプログラムで継承される

## 入出力マルチプレクス
- 複数のディスクリプタから読み込む必要があるとき、
  関心のあるディスクリプタの一覧を作り、
  ディスクリプタの一つが入出力できるようになるまでブロックする
  - `select(2)` / `pselect(2)` / `poll(2)`

### `select(2)`
```c
#include <sys/select.h>

int select(int                      maxfdp1, // 最大ファイルディスクリプタ + 1
           fd_set         *restrict readfds,
           fd_set         *restrict writefds,
           fd_set         *restrict exceptfds,
           struct timeval *restrict tvptr);

// 入力値
//   どのディスクリプタに関心があるのか
//   各ディスクリプタのどのような状態に関心があるのか
//   どの程度待つのか
//
//   fd_set - ディスクリプタセット

// 出力値
//   準備できたディスクリプタの個数の合計
//   読み取り、書き出し、例外状態のどれでディスクリプタの準備ができているのか
```

### `poll(2)`
```c
#include <poll.h>

int poll(struct polld fdarray[],
         nfds_t       nfds,
         int          timeout);

// 入力値
//   polld構造体の配列・要素数・待つ期間
//     struct polld {
//       int   fd;      // 検査するディスクリプタ
//       short events;  // 待つイベント
//       short revents; // 発生したイベント
//     };

// 出力値
//   準備できたディスクリプタの個数の合計
//   polld構造体のreventsメンバの変化
```

## POSIX非同期IO(AIO)
- AIOによってアプリケーションは非同期に実行される入出力操作を一つ以上発行できる
```c
#include <aiocb.h>

struct aiocb {
    int             aio_fildes;     // ファイルディスクリプタ
    off_t           aio_offset;     // 入出力のファイルオフセット
    volatile void  *aio_buf;        // 入出力のバッファ
    size_t          aio_nbytes;     // 転送バイト数
    int             aio_reqprio;    // 優先度
    struct sigevent aio_sigevent;   // シグナル情報
    int             aio_lio_opcode; // 入出力のリストの操作
};
```
- `aio_read(2)` - 非同期読み取り
- `aio_write(2)` - 非同期書き込み
- `aio_fsync(2)` - 保留中の全ての非同期入出力を遅延なく書き出す
- `aio_error(2)` - 非同期IOの完了状態を調べる
- `aio_return(2)` - 非同期IOの返り値を取得する
- `aio_suspend(2)` - 非同期処理が未完の場合、完了するまでブロックする
- `aio_cancel(2)` - 非同期処理をキャンセルを試みる
- `aio_listio(2)` - AIO制御ブロックで記述した一連の入出力要求を発行

## メモリマップト入出力
- ディスク内のファイルをメモリ内のバッファにマップする
  - バッファからバイトを取得すると対応するファイルのバイトが読み取られる
  - バッファ内にデータを格納すると対応するバイト軍が自動的にファイルに書き出される
- `mmap(2)` - 指定のファイルを指定のメモリ領域にマップする
  - `SIGSEGV` - 使用できないメモリへのアクセスを試みた
  - `SIGBUS` - 参照時点では意味がないマップ領域を参照した
  - メモリマップ領域は`fork(2)`をまたいで子プロセスに継承される
- `mprotect(2)` - 既存のマップ領域を保護する
- `msync(2)` - 共有でマップしているページを変更した時、変更をマップ元のファイルへフラッシュする
- `munmap(2)` - マップ領域をアンマップする
