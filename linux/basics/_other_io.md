# 高度な入出力
- 参照: 詳解UNIXプログラミング第3版 14. 高度な入出力

## 非ブロック入出力
- IO待ちにて入出力操作を完了できない場合、操作をブロックする代わりにエラーを返す入出力
  - ファイルステータスフラグに`O_NONBLOCK`をON

## レコードロック(バイト範囲ロック)
- あるプロセスがファイルのある部分を読んだり修正しているとき、
  他プロセスが当該ファイルの当該部分を修正することを防ぐ能力
  - `fcntl(2)`の第二引数に`F_GETLK` / `F_SETLK` / `F_SETLKW`、
    第三引数に`flock`構造体へのポインタを渡す
```c
struct flock {
  short l_type;   // ロック種別 - F_RDLCK / F_WRLCK / F_UNLK
  short l_whence; // 範囲の開始バイトオフセット - SEEK_SET / SEEK_CUR / SEEK_END
  off_t l_start;  // 範囲の開始バイトオフセット - l_whence相対のバイトオフセット
  off_t l_len;    // 範囲のバイト単位の長さ
  pid_t l_pid;    // プロセスをブロックするロックを保持しているプロセスID
};
```
- 二つのプロセスが相手がロックしたリソースを互いに持ち合っている場合、デッドロックが発生する

### ロックコマンド
- `F_GETLK` - 指定のロックが他のロックでブロックされるかどうか調べる
- `F_SETLK` - 指定のロックを設定する / できない場合はエラーを返す
- `F_SETLKW` - 指定のロックを設定する / できない場合は処理をブロックする

### ロック種別
- 共有リードロック(`F_RDLCK`) / 排他ライトロック(`F_WRLCK`)
  - あるバイトに対して複数のプロセスが`F_RDLCK`を持てる
  - あるバイトに対して単一のプロセスが`F_WRLCK`を持てる
  - あるバイトに`F_RDLCK`がある場合当該のバイトに`F_WRLCK`はできない
  - あるバイトに`F_WRLCK`がある場合当該のバイトに`F_RDLCK`はできない
- 同じプロセスが同じバイトに対して複数のロックを保とうとする場合は新しいロックが既存のロックを上書きする

### 暗黙の継承と解放
- ロックはプロセスとファイルに付随する
  - プロセスが終了するとロックは解放される
  - ファイルディスクリプタを閉じると当該プロセスの当該ディスクリプタが参照するファイルの任意のロックが解放される
- ロックは`fork`をまたいで子プロセスには継承されない
  - 子プロセスは他プロセスとみなされる
- ロックは`exec`をまたいで新しいプログラムで継承される

## 入出力マルチプレクス
- 複数のディスクリプタから読み込む必要があるとき、
  関心のあるディスクリプタの一覧を作り、
  ディスクリプタの一つが入出力できるようになるまでブロックする
- `poll(2)`
- `pselect(2)`
- `select(2)`
