# POSIXスレッド
- 参照: 詳解UNIXプログラミング第3版 11. スレッド
- 参照: 詳解UNIXプログラミング第3版 12. スレッドの制御
- 参照: Linuxプログラミングインターフェース 29章 / 33章

## TL;DR
- プロセスは一つのスレッドを持つ(メインスレッド)
- プロセスはスレッドを追加で作成することができる
- シングルスレッド(スレッドベースモデル)
  - 単一のプロセスの中で一つのスレッドが逐次的に動作する
    -> 各プロセスは一つの処理を担う
- マルチスレッド
  - 単一のプロセスの中で複数のスレッドが並行に動作する
    -> 各プロセスは複数の処理を担う
    - マルチプロセッサシステムにおいては並列に動作する
- スレッドはプロセスと同じ状態遷移を持つ
- スレッドはプロセスと同じくカーネルによりスケジューリングと実行スレッドの切り替えが行われる

## プロセスとの比較
- プロセス作成よりもスレッド作成のほうが10倍以上高速
- マルチスレッド環境ではスレッド間で容易かつ高速に情報を共有できる
- マルチスレッド環境では処理がスレッドセーフである必要がある
  - スレッド間でデータを共有しているため、
    一スレッドでのバグが全スレッドに影響を及ぼす
- マルチスレッド環境では全スレッドがプロセス内の有限な仮想アドレス空間を奪い合う
- マルチスレッド環境下でのシグナルの扱いが難しい
- マルチスレッド環境では全スレッドが同じプログラムを実行する

### API
| プロセス  | スレッド               |
| -         | -                      |
| `fork`    | `pthread_create`       |
| `exit`    | `pthread_exit`         |
| `waitpid` | `pthread_join`         |
| `atexit`  | `pthread_cleanup_push` |
| `getpid`  | `pthread_self`         |
| `abort`   | `pthread_cancel`       |

## スレッドが共有する情報
- メモリ空間
- プロセスID / 親プロセスID
- プロセスグループID / セッションID
- 制御端末
- プロセス権限(UID / GID)
- ファイルディスクリプタ
- `fnctl(2)`によるレコードブロック
- シグナル動作
- ファイルシステム関連情報
- インターバルタイマ
- SystemVセマフォの`undo`
- リソース消費時間
- 消費したCPU時間
- 消費したリソース
- `nice`値

## スレッド固有の情報
- プロセス内での実行状況を表現するために必要な情報
  - スレッドID
  - 一連のレジスタ群の値
  - スタック(ローカル変数・関数コールリンケージ情報)
  - リアルタイムスケジューリングポリシー・優先度
  - シグナルマスク
  - シグナル処理専用スタック
  - スレッド固有の変数`errno`
  - スレッド固有のデータ(`thread-specific-data`)
  - CPUアフィニティ
  - ケーパビリティ
- 新規作成されたスレッドは呼び出し側のスレッドの浮動小数点数環境とシグナルマスクを継承する
  - 保留中のシグナルセットは破棄される

### スレッドスタック
- メインスレッド以外のスタックサイズはデフォルトでは2MB
- メインスレッドのスタックサイズはスタックの成長に備えるため2MBより大きく確保されている
- スレッドのスタックサイズは`pthread_attr_setstacksize(3)`で変更可能

## Pthreadsデータ型
- `pthread_t` - スレッドID
- `pthread_mutex_t` - mutex
- `pthread_mutexattr_t` - mutex属性オブジェクト
- `pthread_cond_t` - 条件変数
- `pthread_condattr_t` - 条件変数属性オブジェクト
- `pthread_key_t` - スレッド固有のデータのキー
- `pthread_once_t` - 一回のみの初期化処理
- `pthread_attr_t` - スレッド属性オブジェクト

## スレッドID
- スレッドの一意な識別子

## スレッド属性
- `pthread_attr_t`構造体
  - スタックのアドレスおよびサイズ
  - スレッドスケジューリングポリシーおよび優先度
  - join可能 / デタッチ済み状態

### `pthread_attr_t`構造体に含まれないスレッド属性
- キャンセル属性 - `pthread_cancel`時の動作

## Pthreads関数の返り値
- 成功時 - 数値0を返す
- エラー時 - `errno`の値を示す正の整数を返す

## Pthreadsプログラムのコンパイル
- コンパイル時に`-pthread`オプションを付加する
  - プリプロセッサマクロ`_PEENTRANT`を定義する
    リエントラント対応版のライブラリ関数宣言が有効になる
  - `libpthread`ライブラリとリンクする
    `-lpthread`オプションと等価

## スレッドの作成
- メインスレッド - プログラム実行開始時、プロセスの生成と共に生成される
- メインスレッド以外のスレッド - `pthread_create(3)`を使用する

## スレッドの終了
- スレッド関数がリターンする
- スレッドが`pthread_exit(3)`を実行する
- スレッドが`pthread_cancel(3)`により実行をキャンセルする
- プロセスが終了する
  - 任意のスレッドが`exit()`する
  - メインスレッドが`main`関数からリターンする

## スレッドの終了の待機
- `pthread_join(3)`を呼ぶ
  - デタッチしていないスレッドは`pthread_join(3)`によってjoinしないと
    ゾンビスレッド化する

## スレッドのデタッチ
- `pthread_detach(3)`を呼ぶ
  - 終了時にjoinをさせず、自動的に破棄させる
  - デタッチを設定するとjoinすることができなくなる
- デタッチしたスレッドはプロセスから独立するわけではなく、
  プロセス終了時には一緒に終了する

## スレッドのキャンセル
- 指定のスレッドに対して`pthread_cancel(3)`を呼ぶことでスレッドの実行をキャンセルできる

### キャンセル状態
- `pthread_setcancelstate(3)`でキャンセル状態を変更可能
  - キャンセル可
  - キャンセル不可

### キャンセル種類
- `pthread_setcanceltype(3)`でキャンセル種類を変更可能
  - 非同期キャンセル(使わない)
  - 遅延キャンセル

### キャンセルポイント
- キャンセル状態がキャンセル可能、かつキャンセル種類が遅延キャンセルの場合
  スレッドが実際にキャンセルを行う地点
- 通常はシステムによって定義された、スレッド動作を無限にブロックする可能性のある関数群
- `pthread_testcancel(3)`によって明示的にキャンセルポイントを指定することも可能

## スレッドクリーンアップハンドラ
- スレッド終了時に呼び出す関数群
- スレッドは複数個のクリーンアップハンドラを確立できる
- ハンドラはスタックに記録され、登録順とは逆順に実行される
- `pthread_cleanup_push(3)`によってハンドラの呼び出しをスケジュールする
- `pthread_cleanup_pop(3)`によって直近にスケジュールされたハンドラを削除する

### ハンドラが呼び出されるタイミング
- `pthread_exit(3)`
- `pthread_cancel(3)`
- `pthread_cleanup_pop(3)`

## 制限事項
- `PTHREAD_DESTRUCTOR_ITERATIONS` - 4回
  - スレッド終了時にスレッド固有データを破棄する実装の最大試行回数
- `PTHREAD_KEYS_MAX` - 1024個
  - スレッドが作成できるキーの最大個数
- `PTHREAD_STACK_MIN` - 16384バイト
  - スレッドスタックに使用可能な最小バイト数
- `PTHREAD_THREADS_MAX` - 無制限
  - プロセスで作成可能なスレッドの最大個数

## シグナル
- UNIXのシグナルモデルはプロセスモデルを念頭に置いているため、
  シグナルとスレッド間では生合成を維持できていない点が複数ある
  - マルチスレッドアプリケーションでのシグナル使用はできるだけ避けるべき
  - スレッドセーフが確保できないためシグナルハンドラの使用は避けるべき

### Pthreadsモデルから見たUNIXシグナルモデル
- シグナル動作およびシグナル動作の変更はプロセスワイド
- シグナルはプロセスに送信されるケースとスレッド別に送信されるケースがある
  - スレッド内で特定のハードウェア命令を実行した結果生成されたシグナル -> スレッド
  - スレッドが不正なパイプへ書き込もうとした結果生成された`SIGPIPE` -> スレッド
  - `pthread_kill(3)` / `pthread_sigqueue(3)`により生成されたシグナル -> スレッド
  - 上記以外の経緯で生成されたシグナル -> プロセス
- シグナルマスクおよびシグナル処理専用スタックは個々のスレッドが持つ
  - 新規スレッドは作成スレッドのシグナルマスクの複製を受け継ぐ
- シグナルハンドラを設定したマルチスレッドアプリケーションへシグナルを送信すると、
  シグナル送信先として任意の一スレッドが選択され、対象のスレッドに対してハンドラが実行される
- カーネルは保留中シグナルをスレッド別にも管理する
- シグナルハンドラが`pthread_mutex_lock(3)`に割り込んだ場合、
  `pthread_mutex_lock(3)`の実行は自動的に再開される

### 非同期シグナルとそのシグナルハンドラへの対応
- プロセスが受信する可能性のある非同期シグナルは全スレッドでブロックする
- シグナルを受信・処理する専用のスレッドを作成し、
  `sigwaitinfo(2)` / `sigtimedwait(2)` / `sigwait(2)`のいずれかを実行する

## `exec()`
- スレッドが`exec()`を実行するとプログラム全体が新規プログラムに置き換えられる
- `exec()`を実行したスレッドを除き、全スレッドがその場で消滅する
  プロセス内のmutexや条件変数も消滅する
- 消滅するスレッドの一切の終了処理は実行されない

## `fork(2)`
- スレッドが`fork(2)`を呼ぶと、自スレッドのみが複製され子プロセスとなる
- 子プロセス内では他のスレッドは消滅する
- 消滅するスレッドの一切の終了処理は実行されない

### `fork(2)`の問題
- `fork(2)`元スレッドのグローバル変数、mutex、条件変数の各状態は子プロセスへ継承される
  - 子プロセスは`fork(2)`元スレッドの兄弟スレッドと通信ができない
- 消滅するスレッドの終了処理が行われないため子プロセス内でメモリリークが発生する可能性がある
  - 子プロセス内からは消滅するスレッドが持っているメモリ領域の解放ができない

#### `fork(2)`の問題の回避方法
- `fork(2)`直後に`exec()`するケース以外では使用しない
- `fork(2)`前に`pthread_atfork(3)`でforkハンドラを設定しておく
  - `prepare`ハンドラ - `fork(2)`で子プロセスを作る前に`fork(2)`元スレッド側で呼ばれる
    - 親で定義している全てのロックを獲得する
  - `parent`ハンドラ - `fork(2)`で子プロセスを作り`fork(2)`から戻る前に`fork(2)`元スレッド側で呼ばれる
    - `prepare`が獲得したロックをアンロックする
  - `child`ハンドラ - `fork(2)`から戻る前にこの環境で呼ばれる
    - `prepare`が獲得したロックをアンロックする

## `exit(2)`
- スレッドが`exit(2)`を呼ぶと(またはメインスレッドが`return`すると)全スレッドがその場で消滅する
- 消滅するスレッドの一切の終了処理は実行されない

## スレッドモデル
### M:1スレッドモデル(ユーザーレベルスレッド)
- プロセス内(ユーザー空間のスレッドライブラリ)にてスレッドの動作を処理する
- カーネルはプロセス内に存在するスレッドについて関知しない

#### 利点
- 速度性能
  - カーネルモードへ遷移する必要がないため

#### 欠点
- スレッドがシステムコールを発行すると制御がカーネルへ移動する
  - システムコールにブロック処理が含まれていると、
    プロセス内の他のスレッドも全てブロックする
- カーネルはプロセス内のスレッドをスケジューリングできない
  - カーネルはプロセス内に存在するスレッドを認識していないため

### 1:1スレッドモデル(カーネルレベルスレッド)
- 一スレッドを一KSEにマッピングする
- カーネルは個別にスレッドをスケジューリングする
- カーネル内に実装されたシステムコールを用いてスレッド間の同期を行う
- LinuxThreads / NPTLにて採用されているモデル

#### 利点
- M:1スレッドモデルの欠点を解消する

#### 欠点
- 速度性能
  - カーネルモードへ遷移する必要があるため

### M:Nスレッドモデル(二段階スレッドモデル)
- 一プロセスが複数のKSEに対応する
- 複数のスレッドが一KSEに対応する
- カーネルが複数のスレッドを複数のCPUに分散させることができる

#### 利点
- M:1 / 1:1モデルの欠点を解消する

#### 欠点
- 複雑さ
  - スレッドスケジューリングがカーネル空間・ユーザー空間に跨り、
    情報交換しながら協調動作する必要がある

## LinuxのPOSIXスレッドライブラリ
- LinuxThreads - Linuxの元々のスレッドライブラリ
- NPTL - LinuxThreadsの後継として現在使用されているスレッドライブラリ
