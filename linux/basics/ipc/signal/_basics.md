# シグナル
- 参照: 例解UNIX/Linuxプログラミング教室P323-374
- 参照: 詳解UNIXプログラミング第3版 10. シグナル
- 参照: Linuxプログラミングインターフェース 20章

## TL;DR
- シグナルはプロセスに対して非同期的に送られる通知
  - ソフトウェア割り込み
    <-> ハードウェア割り込み
- シグナルは`<signal.h>`にマクロとして定義されており、コンパイル時に整数に展開される

## シグナルの生起条件
- 端末生起シグナル
  - `SIGINT`
- ハードウェア例外(カーネルがサブルーチンを起動 -> プロセスへシグナルを送出)
  - `SIGSEGV`
  - `SIGFPE`
  - `SIGILL`
- ソフトウェアイベント
  - `SIGURG`
  - `SIGPIPE`
  - `SIGALRM`
    - プロセスは一つのアラームクロックを持つ
    - `alarm(3)` - 指定された秒数が経過した後に`SIGALRM`を送信
- `kill(1)` / `kill(2)` / `raise(3)`
  - `kill`  - 指定のプロセス・プロセスグループに任意のシグナルを送信する
    - `pid > 0` - 指定したPIDを持つ子プロセス
    - `pid == 0` - 親プロセスと同じプロセスグループに属する子プロセス
    - `pid == -1` - 任意の子プロセス(`wait`と同じ)
    - `pid < -1` - プロセスグループIDが指定したPIDの絶対値に等しい子プロセス
  - `raise` - 自プロセスに任意のシグナルを送信する

## シグナルの種類
- 標準シグナル(`<signal.h>`内で定義された1-31までのマクロ定数)
- リアルタイムシグナル

## シグナルのライフサイクル
1. シグナルの生成
2. プロセススケジューリング都合上、
   あるいはプロセスがシグナルをブロックしている場合、保留
3. (保留が解除された場合)シグナルの配送
4. プロセスがシグナルを受信
5. プロセスが実行中かつシグナルマスクを持っている場合、保留
6. (シグナルマスクが存在しない場合)プロセスがシグナル受信時の動作を実行

## シグナル受信時の動作
- デフォルト動作
  - 無視
  - 終了
  - 終了 + コアダンプ(`core`ファイル生成)
  - プロセスの実行停止
  - プロセスの実行再開
- デフォルト動作以外への変更(`signal(2)` / `sigaction(2)`)
  - 無視
  - デフォルト動作の実行
  - シグナルハンドラ(プログラマ定義の関数)実行
- シグナル`SIGKILL` / `SIGSTOP`に対しては捕捉・無視ができない

## シグナルを送信する条件
- 送信側の実ユーザーIDあるいは実行ユーザーIDが
  受信側の実ユーザーIDあるいは保存セットユーザーIDに一致していること

## シグナルの割り込みに対する処理
- 特定のシステムコールにおいては、割り込み後プロセスがシグナルごとに自動的に再起動を行う
  - `ioctl(2)` / `read(2)` / `readv(2)` / `write(2)` / `writev(2)` / `wait(2)` / `waitpid(2)`
- プロセスがシグナルごとに自動再起動を停止することもできる

## シグナル待機
- `pause(3)` - シグナルが来るまで以降の操作をブロックする
  - `pause`する前にシグナルが届いた場合、ブロックが永遠に解除されない

### 特殊な状況でのシグナル待機
#### シグナルのブロックを解除し、ブロックしていたシグナルの以前の生起を`pause(3)`で待ちたい
- `sigsuspend(2)` - ブロックされたシグナルを一時的に変更
  - シグナルマスクを指定のマスクのセットに変更
  - プロセスはシグナルの到着あるいはプロセスの終了を待つ
  - シグナルを捕捉し、シグナルハンドラから戻るとシグナルマスクは元のセットに復元される
  - 返り値は常に-1

## race condition
- シグナルによる処理は非同期であるためrace conditionを招く場合がある
  - race condition   - プログラムの実行順やタイミングに依存して意図しない実行結果を招くこと
  - critical section - race conditionの原因となるプログラム部分
    - 排他制御・割り込みの禁止などを行いrace conditionを避けるようにする
  - atomicな処理     - 実行途中の状態を他のプロセス・スレッド・シグナルハンドラから見えないようにした処理

### グローバル変数へのアクセス
- `volatail`宣言 - `この変数は非同期的に変更されるため、最適化を行わない`とコンパイラに伝える
  - 最適化 -> レジスタへのキャッシュなど
  - グローバル変数に対して`volatail`をつける
- atomicにアクセスできるという保証がなければ、`sigprocmask`で囲んでシグナルをブロックするようにする

## シグナルハンドラ中に呼ぶことができる関数
- 非同期シグナル安全な関数
  - 再入可能関数 - ある関数を実行中に、更にその関数を呼び出すことができる関数(非破壊的関数)
  - シグナルが割り込めない関数

## シグナルのキュー
- `SIGQUEUE_MAX`数分のシグナルをキューすることができる
1. `sigaction`を使ってシグナルハンドラを設定する際に`SA_SIFINFO`をしていする
2. `sigaction`構造体の`sa_sigaction`メンバにシグナルハンドラを与える
3. `sigqueue`を使ってシグナルを送る
    - `sigqueue(2)` - 単一のプロセスにシグナルを送り、シグナルハンドラに指定の値を送る

## シグナル名・番号
- Linuxはシグナルの名前の文字列へのポインタの配列を持つ
```c
// 添字にシグナル番号が入る
extern char *sys_siglist[];
```
- `psignal(3)` - シグナル番号に対する文字列を表示
- `psiginfo(3)` - シグナル情報を表示
  - `sigaction`を介して`siginfo`構造体がある場合
- `strsignal(3)` - シグナル情報を説明する文字列へのポインタを取得
