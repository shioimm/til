# System V IPC
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信
- 参照: Linuxネットワークプログラミング Chapter7 プロセス間通信 7-8
- 参照: Linuxによる並行プログラミング入門 第6章 相互排除とセマフォ 6.2
- 参照: Linuxプログラミングインターフェース 45章 / 46章

## TL;DR
- SystemV メッセージキュー / SystemVセマフォ / SystemV共有メモリの総称
- System V IPCオブジェクトは削除するかシャットダウンするまでカーネル内に存在する
  - システム上に保持できるIPCオブジェクト数は種類ごとに上限が設けられている
  - IPCオブジェクトはシステム全体で共有される
  - IPCオブジェクトにはIPCIDでアクセスする

## API

| インターフェース | メッセージキュー          | セマフォ            | 共有メモリ                 |
| -                | -                         | -                   | -                          |
| ヘッダファイル   | `<sys/msg.h>`             | `<sys/sem.h>`       | `<sys/shim.h>`             |
| 対応構造体       | `msqid_ds`構造体          | `semid_ds`構造体    | `shmid_ds`構造体           |
| get操作          | `msgget(2)`               | `semget(2)`         | `shmget(2)` + `shimat(2)`  |
| 削除操作         | なし                      | なし                | `shmdt(2)`                 |
| 制御             | `msgctl(2)`               | `semctl(2)`         | `shmctl(2)`                |
| 通信             | `msgsnd(2)` / `msgrcv(2)` | `semop(2)`          | メモリへのアクセス         |
| オブジェクト一覧 | `/proc/sysvipc/msg`       | `/proc/sysvipc/sem` | `/proc/sysvipc/sem`        |

### get操作
- オブジェクトが存在しない場合: 指定のIPCキーのオブジェクトを新規に作成し、IPCIDを返す
- オブジェクトが存在する場合: 指定IPCキーに対応するオブジェクトのIPCIDを返す

### IPCID
- カーネル内における各IPCオブジェクトの識別子
- プロセスにおけるファイルディスクリプタに該当する概念
- IPCIDはIPCオブジェクト自身の属性であり、システム全体から参照可能

### IPCキー
- `key_t`型の整数
- get操作は一意なIPCキーを一意なIPCIDへ変換する
- 一意なIPCキーは`IPC_PRIVATE`か`ftok(3)`を使用することで得られる
  - `IPC_PRIVATE` - 新規IPCオブジェクト生成時にキーとして指定できるマクロ定数
  - `ftok(3)` - ファイルパスから得られるi-node番号を利用してIPCキーを生成する

### IPC対応構造体
- カーネルは内部でSystem V IPCオブジェクトそれぞれに対応する構造体を管理する
- 構造体は各IPCオブジェクトのヘッダファイルにて定義される
- 構造体はget操作のシステムコールが作成時に初期化する
- 各構造体は、各IPCオブジェクトに共通する構造体`ipc_perm`を内包する

```c
include <sys/ipc.h>

struct ipc_perm {
  key_t          __key; // getに指定したキー
  uid_t          uid;   // 所有者の実効ユーザーID
  gid_t          gid;   // 所有者の実効グループID
  uid_t          cuid;  // 作成者の実効ユーザーID
  gid_t          cgid;  // 作成者の実効グループID
  unsigned short mode;  // パーミッション
  unsigned short __seq; // シーケンス番号
};
```

## カーネル内におけるSystem V IPCの構造
- カーネルはIPC種類ごとに`ipc_ids`構造体を作成する
  カーネルはIPC種類ごとの全IPCオブジェクトに関するグローバルな情報を管理する
- `ipc_ids`構造体はポインタのダイナミック配列`entries`を持ち、
  各IPCオブジェクトに対応する構造体を指す

## IPCオブジェクトの管理
- `ipcs(1)` - System V IPCにおける`ls(1)`
- `ipcrm(1)` - System V IPCにおける`rm(1)`

## System V メッセージキュー
- メッセージ形式のデータをプロセス間で交換する機構
  - メッセージキューを表すハンドルは`msgget(2)`が返すIPCID
  - メッセージキューによる通信はメッセージ指向
  - メッセージは区切り・種類を持つ
- 新規作成するアプリケーションではSystem Vメッセージキューの代わりに
  他のIPC手段を使用するべき

### System V メッセージキューの欠点
- メッセージキューの参照に独自のIPCIDを使用しているため、
  ファイルディスクリプタベースのIOを使用できない
- キーによってオブジェクトを識別するためプログラムの複雑性が増す
- コネクションレスであり、カーネルはキューが参照するプロセス数を管理しない
- メッセージキューの総数、メッセージ数、ここのキューの容量に上限がある

### API
- `msgget(2)` - 新規メッセージキューの作成または既存のメッセージキューのIDを返す
- `msgctl(2)` - メッセージキューに対する各種操作を行う
- `msgsnd(2)` - メッセージキューの末尾にメッセージを書き込む
- `msgrcv(2)` - メッセージキューからメッセージを読み取る
  - `mtype`フィールドを指定して任意の種別のメッセージを取り出すことが可能

```c
// msgsnd(2) / msgrcv(2)では
// メッセージを表現するプログラマ定義の構造体を介して
// キューに対する操作を行う

struct mymsg {
  long mtype;
  char mtext[];
};
```

```c
// msqid_ds構造体 - メッセージキューを表す

#include <sys/msg.h>

struct msqid_ds {
  struct ipc_perm msg_perm;   // 所有権とパーミッション
  msgqnum_t       msg_qnum;   // キュー内のメッセージの数
  msglen_t        msg_qbytes; // キュー内の最大バイト数
  pid_t           msg_lspid;  // 最終msgsnd(2)実行PID
  pid_t           msg_lrpid;  // 最終msgrcv(2)実行PID
  time_t          msg_stime;  // 最終msgsnd(2)時刻
  time_t          msg_rtime;  // 最終msgrcv(2)時刻
  time_t          msg_ctime;  // 最終変更時刻
};
```

```c
// 各メッセージを次の要素を持つ構造体として定義する

struct msgbuf {
  long mtype;      // 正のメッセージ種別
  char mtext[512]; // メッセージデータ
};
```

## System Vセマフォ
- 複数のプロセス間で同期を取る機構
- カーネルが内部で管理する整数(数値0以上)として実装されている
- System Vセマフォはセマフォセット単位で割り当てられる

### System Vセマフォの欠点
- セマフォの参照に独自のIPCIDを使用しているため、
  ファイルディスクリプタベースのIOを使用できない
- キーによってオブジェクトを識別するためプログラムの複雑性が増す
- 新規作成と初期化を独立したシステムコールにより行う必要があるため、
  作成時に潜在的な競合状態を抱える
- カーネルはセマフォセットが使用するプロセス数を管理しない
- セマフォ操作には様々なリソース上限が設けられている

### セマフォ操作
- 絶対値への代入
- 絶対値への加算
- 絶対値からの減算
  - 減算した結果が数値0を下回る場合、自プロセスをブロックする
  - 他プロセスによってセマフォの値が変更されるとブロックを解除する
- 値が数値0になるのを待つ
  - 自プロセスをブロックする
  - 他プロセスによってセマフォの値が変更されるとブロックを解除する

### 使用手順
1. セマフォの新規作成または既存のセマフォのオープン(`semget(2)`)
2. セマフォの初期化(`semctl(2)`)
3. セマフォの操作(`semop(2)`)
4. セマフォの削除(`semctl(2)`)

### API
- `semget(2)` - 新規セマフォセットの作成または既存のセマフォセットのIDを返す
- `semctl(2)` - セマフォセットもしくはセット内の個々のセマフォに対する各種操作を行う
- `semop(2)` - 指定のセマフォセット内のセマフォ(複数可)に対する各種操作をアトミックに行う
  - `semtimedop(2)` - 制限時間付きの`semop(2)`

```c
// semid_ds構造体 - セマフォを表す

struct semid_ds {
  struct ipc_perm sem_perm;  // 所有権と許可
  unsigned long   sem_nsems; // セット内のセマフォの数
  time_t          sem_otime; // 最後のsemop(2)時刻
  time_t          sem_ctime; // 最終変更時刻
};
```

### バイナリセマフォの実装
- `獲得` / `解放`の2操作によって`使用可能` / `使用不可`の2値を取るセマフォ
- System Vセマフォに追加実装することによりSystem Vセマフォの利便性を上げる

## 共有メモリ
- 複数プロセスで同じメモリ領域を共有するための仕組み
- 二つ以上のプロセス群が同じメモリ空間にアクセスできるようにする
  - セマフォなどを利用して当該領域への複数プロセス群のアクセスを同期する必要がある
- `shmget(2)` - 共有メモリ識別子の取得(IPC資源の確保)
- `shmctl(2)` - 共有メモリに対する操作(IPC資源の削除を含む)
- `shmat(2)` - プロセスメモリ空間から共有メモリへの接続
- `shmdt(2)` - プロセスメモリ空間から共有メモリへの切断

```c
// 各共有メモリセグメントに対してカーネルが管理するshmid_ds構造体

struct shmid_ds {
    struct ipc_perm shm_perm;    // 所有権と許可
    size_t          shm_segsz;   // セグメントのバイト長
    time_t          shm_atime;   // 最終接続時刻
    time_t          shm_dtime;   // 最終切断時刻
    time_t          shm_ctime;   // 最終変更時刻
    pid_t           shm_cpid;    // 作成者のPID
    pid_t           shm_lpid;    // 最後にshmat(2)/shmdt(2)したPID
    shmatt_t        shm_nattch;  // 接続個数
};
```

## 結論
- パイプとFIFOを使う
- メッセージキュー、セマフォは新しいアプリケーションでの使用を避ける
  - 代わりに全二重パイプとレコードロックを考慮する
- 共有メモリは`mmap(2)`で代替えできる
