# System V IPC
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信
- 参照: Linuxネットワークプログラミング Chapter7 プロセス間通信 7-8
- 参照: Linuxによる並行プログラミング入門 第6章 相互排除とセマフォ 6.2
- 参照: Linuxプログラミングインターフェース 45章 / 46章

## TL;DR
- SystemV メッセージキュー / SystemVセマフォ / SystemV共有メモリの総称
- System V IPCオブジェクトは削除するかシャットダウンするまでカーネル内に存在する
  - システム上に保持できるIPCオブジェクト数は種類ごとに上限が設けられている
  - IPCオブジェクトはシステム全体で共有される
  - IPCオブジェクトにはIPCIDでアクセスする

## API

| インターフェース | メッセージキュー          | セマフォ            | 共有メモリ                 |
| -                | -                         | -                   | -                          |
| ヘッダファイル   | `<sys/msg.h>`             | `<sys/sem.h>`       | `<sys/shim.h>`             |
| 対応構造体       | `msqid_ds`構造体          | `semid_ds`構造体    | `shmid_ds`構造体           |
| get操作          | `msgget(2)`               | `semget(2)`         | `shmget(2)` + `shimat(2)`  |
| 削除操作         | なし                      | なし                | `shmdt(2)`                 |
| 制御             | `msgctl(2)`               | `semctl(2)`         | `shmctl(2)`                |
| 通信             | `msgsnd(2)` / `msgrcv(2)` | `semop(2)`          | メモリへのアクセス         |
| オブジェクト一覧 | `/proc/sysvipc/msg`       | `/proc/sysvipc/sem` | `/proc/sysvipc/sem`        |

### get操作
- オブジェクトが存在しない場合: 指定のIPCキーのオブジェクトを新規に作成し、IPCIDを返す
- オブジェクトが存在する場合: 指定IPCキーに対応するオブジェクトのIPCIDを返す

### IPCID
- カーネル内における各IPCオブジェクトの識別子
- プロセスにおけるファイルディスクリプタに該当する概念
- IPCIDはIPCオブジェクト自身の属性であり、システム全体から参照可能

### IPCキー
- `key_t`型の整数
- get操作は一意なIPCキーを一意なIPCIDへ変換する
- 一意なIPCキーは`IPC_PRIVATE`か`ftok(3)`を使用することで得られる
  - `IPC_PRIVATE` - 新規IPCオブジェクト生成時にキーとして指定できるマクロ定数
  - `ftok(3)` - ファイルパスから得られるi-node番号を利用してIPCキーを生成する

### IPC対応構造体
- カーネルは内部でSystem V IPCオブジェクトそれぞれに対応する構造体を管理する
- 構造体は各IPCオブジェクトのヘッダファイルにて定義される
- 構造体はget操作のシステムコールが作成時に初期化する
- 各構造体は、各IPCオブジェクトに共通する構造体`ipc_perm`を内包する

```c
include <sys/ipc.h>

struct ipc_perm {
  key_t          __key; // getに指定したキー
  uid_t          uid;   // 所有者の実効ユーザーID
  gid_t          gid;   // 所有者の実効グループID
  uid_t          cuid;  // 作成者の実効ユーザーID
  gid_t          cgid;  // 作成者の実効グループID
  unsigned short mode;  // パーミッション
  unsigned short __seq; // シーケンス番号
};
```

## カーネル内におけるSystem V IPCの構造
- カーネルはIPC種類ごとに`ipc_ids`構造体を作成する
  カーネルはIPC種類ごとの全IPCオブジェクトに関するグローバルな情報を管理する
- `ipc_ids`構造体はポインタのダイナミック配列`entries`を持ち、
  各IPCオブジェクトに対応する構造体を指す

## IPCオブジェクトの管理
- `ipcs(1)` - System V IPCにおける`ls(1)`
- `ipcrm(1)` - System V IPCにおける`rm(1)`

## System V メッセージキュー
- メッセージ形式のデータをプロセス間で交換する機構
  - メッセージキューを表すハンドルは`msgget(2)`が返すIPCID
  - メッセージキューによる通信はメッセージ指向
  - メッセージは区切り・種類を持つ
- 新規作成するアプリケーションではSystem Vメッセージキューの代わりに
  他のIPC手段を使用するべき

### System V メッセージキューの欠点
- メッセージキューの参照に独自のIPCIDを使用しているため、
  ファイルディスクリプタベースのIOを使用できない
- キーによってオブジェクトを識別するためプログラムの複雑性が増す
- コネクションレスであり、カーネルはキューが参照するプロセス数を管理しない
- メッセージキューの総数、メッセージ数、ここのキューの容量に上限がある

### API
- `msgget(2)` - 新規メッセージキューの作成または既存のメッセージキューのIDを返す
- `msgctl(2)` - メッセージキューに対する各種操作を行う
- `msgsnd(2)` - メッセージキューの末尾にメッセージを書き込む
- `msgrcv(2)` - メッセージキューからメッセージを読み取る
  - `mtype`フィールドを指定して任意の種別のメッセージを取り出すことが可能

```c
// msgsnd(2) / msgrcv(2)では
// メッセージを表現するプログラマ定義の構造体を介して
// キューに対する操作を行う

struct mymsg {
  long mtype;
  char mtext[];
};
```

```c
// msqid_ds構造体 - メッセージキューを表す

#include <sys/msg.h>

struct msqid_ds {
  struct ipc_perm msg_perm;   // 所有権とパーミッション
  msgqnum_t       msg_qnum;   // キュー内のメッセージの数
  msglen_t        msg_qbytes; // キュー内の最大バイト数
  pid_t           msg_lspid;  // 最終msgsnd(2)実行PID
  pid_t           msg_lrpid;  // 最終msgrcv(2)実行PID
  time_t          msg_stime;  // 最終msgsnd(2)時刻
  time_t          msg_rtime;  // 最終msgrcv(2)時刻
  time_t          msg_ctime;  // 最終変更時刻
};
```

```c
// 各メッセージを次の要素を持つ構造体として定義する

struct msgbuf {
  long mtype;      // 正のメッセージ種別
  char mtext[512]; // メッセージデータ
};
```

## System V セマフォ
- 複数のプロセス間で同期を取る仕組み
- 実体はカーネルが内部で管理する整数
  - `enter_region`操作と`exit_region`操作の組み合わせによって同期を取る
    - `enter_region`操作(down操作) - 危険領域に入る操作を求める
      許可されない場合は許可されるまでwait
      許可される場合は他のプロセスが危険領域に入ることを不許可にして操作を終える
    - `exit_region`操作(up操作) - 他のプロセスが危険領域に入ることを許可して操作を終える
  - pthreadのミューテックスは2値セマフォ
- 複数プロセスによるデータオブジェクトへの読み書きタイミングを合わせるために使用するカウンタ
- `semget(2)` - セマフォIDの取得(IPC資源の確保)
  - `semget(2)`で作成されたセマフォセットは未初期化状態
  - アプリケーションはセマフォセットの中の各セマフォ値を初期化する必要がある
- `semctl(2)` - セマフォに対する操作(セマフォの初期化・IPC資源の削除を含む)↲
- `semop(2)` - セマフォの操作・セマフォセットに一連の操作を不可分に適用

```c
// カーネルは各セマフォセットごとにsemid_ds構造体を管理する

struct semid_ds {
  struct ipc_perm sem_perm;  // 所有権と許可
  unsigned long   sem_nsems; // セット内のセマフォの数
  time_t          sem_otime; // 最後のsemop(2)時刻
  time_t          sem_ctime; // 最終変更時刻
};
```

- 同期基本操作であり、IPCとしてではなく共有リソースへのアクセスの同期を取るために使用される

#### 種類
- バイナリセマフォ
- XSIセマフォ

#### 共有リソースの獲得
- リソースを制御するセマフォを検査
  - セマフォの値が正 - プロセスはリソースを使える
    - セマフォの値を1減らす(リソースの1単位を使用中)
  - セマフォの値が0 - セマフォの値が0より大きくなるまでプロセスは休眠する -> 検査に戻る
- セマフォで制御する共有リソースを使い終えたらセマフォの値を1増やす

## 共有メモリ
- 複数プロセスで同じメモリ領域を共有するための仕組み
- 二つ以上のプロセス群が同じメモリ空間にアクセスできるようにする
  - セマフォなどを利用して当該領域への複数プロセス群のアクセスを同期する必要がある
- `shmget(2)` - 共有メモリ識別子の取得(IPC資源の確保)
- `shmctl(2)` - 共有メモリに対する操作(IPC資源の削除を含む)
- `shmat(2)` - プロセスメモリ空間から共有メモリへの接続
- `shmdt(2)` - プロセスメモリ空間から共有メモリへの切断

```c
// 各共有メモリセグメントに対してカーネルが管理するshmid_ds構造体

struct shmid_ds {
    struct ipc_perm shm_perm;    // 所有権と許可
    size_t          shm_segsz;   // セグメントのバイト長
    time_t          shm_atime;   // 最終接続時刻
    time_t          shm_dtime;   // 最終切断時刻
    time_t          shm_ctime;   // 最終変更時刻
    pid_t           shm_cpid;    // 作成者のPID
    pid_t           shm_lpid;    // 最後にshmat(2)/shmdt(2)したPID
    shmatt_t        shm_nattch;  // 接続個数
};
```

## 結論
- パイプとFIFOを使う
- メッセージキュー、セマフォは新しいアプリケーションでの使用を避ける
  - 代わりに全二重パイプとレコードロックを考慮する
- 共有メモリは`mmap(2)`で代替えできる
