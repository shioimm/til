# System V IPC
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信
- 参照: Linuxネットワークプログラミング Chapter7 プロセス間通信 7-8
- 参照: Linuxによる並行プログラミング入門 第6章 相互排除とセマフォ 6.2
- 参照: Linuxプログラミングインターフェース 45 - 48章

## TL;DR
- System V メッセージキュー / System Vセマフォ / System V共有メモリの総称
- System V IPCオブジェクトは削除するかシャットダウンするまでカーネル内に存在する
  - システム上に保持できるIPCオブジェクト数は種類ごとに上限が設けられている
  - IPCオブジェクトはシステム全体で共有される
  - IPCオブジェクトにはIPCIDでアクセスする

## API

| インターフェース | メッセージキュー          | セマフォ            | 共有メモリ                 |
| -                | -                         | -                   | -                          |
| ヘッダファイル   | `<sys/msg.h>`             | `<sys/sem.h>`       | `<sys/shim.h>`             |
| 対応構造体       | `msqid_ds`構造体          | `semid_ds`構造体    | `shmid_ds`構造体           |
| get操作          | `msgget(2)`               | `semget(2)`         | `shmget(2)` + `shimat(2)`  |
| 削除操作         | なし                      | なし                | `shmdt(2)`                 |
| 制御             | `msgctl(2)`               | `semctl(2)`         | `shmctl(2)`                |
| 通信             | `msgsnd(2)` / `msgrcv(2)` | `semop(2)`          | メモリへのアクセス         |
| オブジェクト一覧 | `/proc/sysvipc/msg`       | `/proc/sysvipc/sem` | `/proc/sysvipc/sem`        |

### get操作
- オブジェクトが存在しない場合: 指定のIPCキーのオブジェクトを新規に作成し、IPCIDを返す
- オブジェクトが存在する場合: 指定IPCキーに対応するオブジェクトのIPCIDを返す

### IPCID
- カーネル内における各IPCオブジェクトの識別子
- プロセスにおけるファイルディスクリプタに該当する概念
- IPCIDはIPCオブジェクト自身の属性であり、システム全体から参照可能

### IPCキー
- `key_t`型の整数
- get操作は一意なIPCキーを一意なIPCIDへ変換する
- 一意なIPCキーは`IPC_PRIVATE`か`ftok(3)`を使用することで得られる
  - `IPC_PRIVATE` - 新規IPCオブジェクト生成時にキーとして指定できるマクロ定数
  - `ftok(3)` - ファイルパスから得られるi-node番号を利用してIPCキーを生成する

### IPC対応構造体
- カーネルは内部でSystem V IPCオブジェクトそれぞれに対応する構造体を管理する
- 構造体は各IPCオブジェクトのヘッダファイルにて定義される
- 構造体はget操作のシステムコールが作成時に初期化する
- 各構造体は、各IPCオブジェクトに共通する構造体`ipc_perm`を内包する

```c
include <sys/ipc.h>

struct ipc_perm {
  key_t          __key; // getに指定したキー
  uid_t          uid;   // 所有者の実効ユーザーID
  gid_t          gid;   // 所有者の実効グループID
  uid_t          cuid;  // 作成者の実効ユーザーID
  gid_t          cgid;  // 作成者の実効グループID
  unsigned short mode;  // パーミッション
  unsigned short __seq; // シーケンス番号
};
```

## カーネル内におけるSystem V IPCの構造
- カーネルはIPC種類ごとに`ipc_ids`構造体を作成する
  カーネルはIPC種類ごとの全IPCオブジェクトに関するグローバルな情報を管理する
- `ipc_ids`構造体はポインタのダイナミック配列`entries`を持ち、
  各IPCオブジェクトに対応する構造体を指す

## IPCオブジェクトの管理
- `ipcs(1)` - System V IPCにおける`ls(1)`
- `ipcrm(1)` - System V IPCにおける`rm(1)`

## System V メッセージキュー
- メッセージ形式のデータをプロセス間で交換する機構
- メッセージキューを表すハンドルは`msgget(2)`が返すIPCID
- メッセージキューによる通信はメッセージ指向
- メッセージは種類を持つ
- キュー内のメッセージを読み取る順序は先入れ先出し
  - メッセージ種類を特定し特定のメッセージのみの読み取りも可能
- 新規作成するアプリケーションではSystem Vメッセージキューの代わりに
  他のIPC手段を使用するべき

### System V メッセージキューの欠点
- メッセージキューの参照に独自のIPCIDを使用しているため、
  ファイルディスクリプタベースのIOを使用できない
- キーによってオブジェクトを識別するためプログラムの複雑性が増す
- コネクションレスであり、カーネルはキューが参照するプロセス数を管理しない
- メッセージキューの総数、メッセージ数、ここのキューの容量に上限がある

### API
- `msgget(2)` - 新規メッセージキューの作成または既存のメッセージキューのIDを返す
- `msgctl(2)` - メッセージキューに対する各種操作を行う
- `msgsnd(2)` - メッセージキューの末尾にメッセージを書き込む
- `msgrcv(2)` - メッセージキューからメッセージを読み取る
  - `mtype`フィールドを指定して任意の種別のメッセージを取り出すことが可能

```c
// msgsnd(2) / msgrcv(2)では
// メッセージを表現するプログラマ定義の構造体を介して
// キューに対する操作を行う

struct mymsg {
  long mtype;
  char mtext[];
};
```

```c
// msqid_ds構造体 - メッセージキューを表す

#include <sys/msg.h>

struct msqid_ds {
  struct ipc_perm msg_perm;   // 所有権とパーミッション
  msgqnum_t       msg_qnum;   // キュー内のメッセージの数
  msglen_t        msg_qbytes; // キュー内の最大バイト数
  pid_t           msg_lspid;  // 最終msgsnd(2)実行PID
  pid_t           msg_lrpid;  // 最終msgrcv(2)実行PID
  time_t          msg_stime;  // 最終msgsnd(2)時刻
  time_t          msg_rtime;  // 最終msgrcv(2)時刻
  time_t          msg_ctime;  // 最終変更時刻
};
```

```c
// 各メッセージを次の要素を持つ構造体として定義する

struct msgbuf {
  long mtype;      // 正のメッセージ種別
  char mtext[512]; // メッセージデータ
};
```

## System Vセマフォ
- 複数のプロセス間で同期を取る機構
- カーネルが内部で管理する整数(数値0以上)として実装されている
- System Vセマフォはセマフォセット単位で割り当てられる

### System Vセマフォの欠点
- セマフォの参照に独自のIPCIDを使用しているため、
  ファイルディスクリプタベースのIOを使用できない
- キーによってオブジェクトを識別するためプログラムの複雑性が増す
- 新規作成と初期化を独立したシステムコールにより行う必要があるため、
  作成時に潜在的な競合状態を抱える
- カーネルはセマフォセットが使用するプロセス数を管理しない
- セマフォ操作には様々なリソース上限が設けられている

### セマフォ操作
- 絶対値への代入
- 絶対値への加算
- 絶対値からの減算
  - 減算した結果が数値0を下回る場合、自プロセスをブロックする
  - 他プロセスによってセマフォの値が変更されるとブロックを解除する
- 値が数値0になるのを待つ
  - 自プロセスをブロックする
  - 他プロセスによってセマフォの値が変更されるとブロックを解除する

### 使用手順
1. セマフォの新規作成または既存のセマフォのオープン(`semget(2)`)
2. セマフォの初期化(`semctl(2)`)
3. セマフォの操作(`semop(2)`)
4. セマフォの削除(`semctl(2)`)

### API
- `semget(2)` - 新規セマフォセットの作成または既存のセマフォセットのIDを返す
- `semctl(2)` - セマフォセットもしくはセット内の個々のセマフォに対する各種操作を行う
- `semop(2)` - 指定のセマフォセット内のセマフォに対する各種操作をアトミックに行う
  - セマフォセット内のセマフォに任意の値を加算・減算する
  - `semtimedop(2)` - 制限時間付きの`semop(2)`

```c
// semid_ds構造体 - セマフォを表す

struct semid_ds {
  struct ipc_perm sem_perm;  // 所有権と許可
  unsigned long   sem_nsems; // セット内のセマフォの数
  time_t          sem_otime; // 最後のsemop(2)時刻
  time_t          sem_ctime; // 最終変更時刻
};
```

### バイナリセマフォの実装
- `獲得` / `解放`の2操作によって`使用可能` / `使用不可`の2値を取るセマフォ
- System Vセマフォに追加実装することによりSystem Vセマフォの利便性を上げる

## 共有メモリ
- 複数プロセスが物理メモリの同じ領域(セグメント)を共有する機構
- 共有メモリセグメントはプロセスのユーザーメモリ空間の一部となる
  - カーネルを介したIPCとは異なり、IPCのためにカーネルへ送受信を要求する必要がない
  - プロセスから共有メモリへデータを転送するだけで
    同じセグメントを共有する他プロセスから参照可能となる

### System V共有メモリの欠点
- 複数プロセスが同時に共有メモリへアクセスするのを防ぐ同期機構が必要
  - System Vセマフォ、POSIXセマフォ、ファイルロック
- プロセスの仮想アドレス空間のどこへアタッチするかはカーネルが決定する
  - プロセスが異なれば仮想アドレスも異なる
  - セグメント内のアドレス参照は絶対アドレスではなく
    セグメントの先頭アドレスからの相対アドレスを使用する必要がある

### 使用手順
1. 共有メモリセグメントの新規作成または既存のセマフォのオープン(`shmget(2)`)
2. 共有メモリセグメントのアタッチ(`shmat(2)` - 自プロセスの仮想メモリ空間の一部とする)
3. 共有メモリセグメントの操作(共有メモリセグメントのアドレスへアクセスする)
4. 共有メモリセグメントのデタッチ(`shmdt(2)`)
5. 共有メモリセグメントの削除(`shmctl(2)`)

### 共有メモリマッピング
- 共有メモリセグメントは仮想メモリ空間のうち
  スタック(下位へ成長する)とヒープ(上位へ成長する)の間にアタッチされる
  - `0x40000000`以降
  - `/proc/PID/mapsから確認できる`

### API
- `shmget(2)` - 新規共有メモリセグメントの作成または既存の共有メモリセグメントのIDを返す
- `shmat(2)` - 共有メモリセグメントを自プロセスの仮想アドレス空間へアタッチ
- `shmdt(2)` - 共有メモリセグメントを自プロセスの仮想アドレス空間からデタッチ
- `shmctl(2)` - 共有メモリセグメントに対する各種操作を行う

```c
// shmid_ds構造体 - 共有メモリセグメントを表す

struct shmid_ds {
  struct ipc_perm shm_perm;   // 所有権と許可
  size_t          shm_segsz;  // セグメントサイズ
  time_t          shm_atime;  // 最終アタッチ時刻
  time_t          shm_dtime;  // 最終デタッチ時刻
  time_t          shm_ctime;  // 最終変更時刻
  pid_t           shm_cpid;   // 作成者PID
  pid_t           shm_lpid;   // 最後にアタッチ / デタッチしたPID
  shmatt_t        shm_nattch; // アタッチ中のプロセス数
};
```
