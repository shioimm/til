# パイプ
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信
- 参照: Linuxネットワークプログラミング Chapter7 プロセス間通信 7-7
- 参照: Linuxによる並行プログラミング入門 第4章 リダイレクトとパイプ 4.5
- 参照: Linuxプログラミングインターフェース 44章

## TL;DR
- 共通先祖を持つプロセス間でのデータ通信機構
  - 親子プロセス、親孫プロセス、兄弟プロセス
- パイプの実体はカーネルが管理するバッファ
- プロセスはパイプへ読み書きするためのファイルディスクリプタを持つ
- プロセスからのファイルディスクリプタが全てクローズされるとパイプは消滅する

```
データの流れ

プロセスの書き込み用ファイルディスクリプタ
  -> カーネル内のパイプの読み込み端点(ファイルディスクリプタ)
  -> カーネル内のパイプの書き込み端点(ファイルディスクリプタ)
  -> プロセスの読み込み用ファイルディスクリプタ
```

- コマンドラインのパイプ(`|`)もパイプの仕組みを利用している

## パイプの性質
### バイトストリーム
- メッセージ区切りが存在しない
- パイプを読み取るプロセスは書き込みプロセスが書き込んだブロックサイズとは無関係に
  任意のバイトサイズのデータブロックを読み取る
- バイトストリームは書き込んだ順に読み取られる

### バッファ
- パイプのバッファが上限に達している状態で書き込もうとした場合、
  またはパイプのバッファが空の状態で読み込もうとした場合、
  読み書きができるようになるまで操作がブロックされる
- 読み取りプロセスはパイプ内の全データを読み取り後、EOFを読み取る
- 複数プロセスが同じパイプへ書き込んでも書き込みデータは混ざらない
  (`PIPE_BUF`を超えない限り)

#### `PIPE_BUF`
- 4096バイト
- サイズが`PIPE_BUF`より大きなデータをパイプへ書き込む場合、
  カーネルはデータを分割し、読み取りプロセスがパイプからデータを読み取り後に
  後続データを転送する
  - 複数プロセスが書き込みを待っている場合、分割時にデータが混ざる可能性がある

### 単方向性
- パイプのデータの流れは入力 -> 出力の一方通行(半二重)

## パイプの作成と使用
```
Ex. 親プロセス -> 子プロセスへの通信を行う場合

1. 親プロセスがカーネル内にパイプを生成
    - 親プロセスは生成したパイプへの読み書きファイルディスクリプタを得る
2. 親プロセスが`fork`する
    - 親プロセスの持つファイルディスクリプタをコピーする子プロセスが生成される
3. 親プロセスが読み取りファイルディスクリプタを閉じる
4. 子プロセスが書き込みファイルディスクリプタを閉じる
5. 親プロセスがパイプへ書き込む -> 子プロセスがパイプから読み取る
```

## API
### `pipe(2)`
- パイプを作成する
- パイプへの読み書きファイルディスクリプタを要素に持つ配列を取得する

#### 引数
- `filedes[2]`を指定する
  - `filedes[2]`- パイプへの読み書きディスクリプタを格納するための配列

#### 返り値
- 数値0を返す
  - エラー時は数値-1を返す

### `popen(3)`
- パイプを作成し、`fork`してシェルコマンドを`exec`する
  - 標準入出力ファイルポインタを返す
  - プロセスがパイプを作成
    -> `fork`
    -> 子プロセスで使用しないパイプの端点を閉じてシェルを起動
    -> シェル上でコマンドを`exec`

### `pclose(3)`
- `popen(3)`で開いた標準入出力ストリームを閉じ、コマンドの終了を待ち、シェルの終了状態を返す

## 使用上の注意
- 閉じたパイプへの読み書き
  - 書き込みプロセスがファイルディスクリプタを閉じた後、読み取りプロセスが読み取る
    -> EOFが発生する
  - 読み取りプロセスがファイルディスクリプタを閉じた後、書き込みプロセスが書き込む
    -> SIGPIPEが発生する
- ファイルディスクリプタの閉じ忘れ
  - 読み取りプロセスによる書き込みファイルディスクリプタの閉じ忘れ
    -> 読み取り後もEOFが発生せず、readがブロックされる
  - 書き込みプロセスによる読み取りファイルディスクリプタの閉じ忘れ
    -> パイプのバッファが溢れ、writeがブロックされる
