# IO多重化
- 参照: Linuxネットワークプログラミング

## TL;DR
- 一つのプロセスで複数の入出力を扱う
  - サーバーソケットは`accept(2)`や`read(2)`の段階で
    クライアントプロセスからの入力待ちになる可能性がある
  - 複数のソケットディスクリプタを監視する場合、
    準備ができたディスクリプタを特定する必要がある
- `select(2)` - 監視する対象のディスクリプタ群を指定し、準備ができたディスクリプタ数を返す
  - `fd_set readfds`  - 読み込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set writefds` - 書き込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set errorfds` - エラーになった際に通知する対象のディスクリプタ群
  - `fd_set`型 - 複数のディスクリプタを保持できるシステムデータ型
    - `FD_ZERO`  - 指定した`fd_set`型のデータの全ビットを0にする
    - `FD_SET`   - `fd_set`にディスクリプタを追加する
    - `FD_CLR`   - `fd_set`からディスクリプタを削除する
    - `FD_ISSET` - `fd_set`にディスクリプタが含まれていれば0以外、含まれていなければ0を返す

## 非ブロック / 非同期入出力
- 入出力できるデータがない場合、ソケットは処理をブロックする
- ソケットを非ブロックモードにすると、ブロックせず`errno`に`EWOULDBLOCK` / `EAGAIN`を設定する
  - `poll(2)` / `select(2)`でデータの送受信ができるタイミングを判定する

### 非同期入出力
- ソケットからデータを読み取れるようになった時
  あるいはソケットの出力キューに空きができた時
  シグナル`SIGIO`を送る
  - 適切なプロセスにシグナルが配送されるよう、ソケットの所有者を設定する必要がある
    - `fcntl(2)`にコマンド`F_SETOWN` / `FIOSETOWN`を使用
    - `ioctl(2)`にコマンド`SIOCSPGRP`を使用
  - 入出力操作がブロックしない時にシグナルを送るよう、ソケットに指示する必要がある
    - `fcntl(2)`にコマンド`F_SETFL`を使いファイルフラグ`O_ASYNC`を有効化
    - `ioctl(2)`にコマンド`FIOASYNCを使用`

## IO多重化
- 参照: Linuxネットワークプログラミング Chapter8 複数のソケットを使う 8-1

### `epoll` API
- IOイベント通知機能
  - 複数のソケットを扱う際、ソケット群を監視し、読み書きの準備ができたソケットを通知する

#### `epoll_create(2)`
- `epoll`で使用するためのインスタンスをカーネル内に生成し、そのファイルディスクリプタを返す

#### `epoll_ctl(2)`
- 準備待ちを行うファイルディスクリプタと
  `epoll_create(2)`で作成した`epoll`ファイルディスクリプタ・IOイベントの関連付けを行う
- その他`epoll`に対する操作

```c
// イベントを表現するepoll_event構造体

typedef union epoll_data {
  void        *ptr;
  int          fd;
  uint32_t     u32;
  uint64_t     u64;
} epoll_data_t;

struct epoll_event {
  uint32_t     events; // epoll イベント
  epoll_data_t data;   // ユーザーデータ変数
};
```

#### `epoll_wait(2)`
- `epoll`ファイルディスクリプタに対してIOイベントの準備待ちを行う
  - 受信待ち / 送信待ち / エラーの有無 / タイムアウト
- イベント待ちの結果を`epoll_event`構造体の配列に格納する
- ブロッキングAPI
  - シグナルでデッドロックを回避する
  - ソケットペアでデッドロックを回避する

### `select(2)` / `poll(2)`
- `epoll` APIと同じ機能を果たすが重い
- 後方互換性のため`epoll`の代わりに使用されることがある

### `select`と`epoll`の違い
- 引用: [I/O多重化の方法(selectとepollの違い)](http://portaltan.hatenablog.com/entry/2015/11/12/145840)
  - 参照: [epollの使い方 ~I/O Multiplexing~](http://kamiyasu2.blog.fc2.com/blog-entry-45.html)

#### `select`
- 監視するファイルディスクリプタのサイズに制限がある
- ファイルディスクリプタを一件ずつ確認する
- カーネルが全てのファイルディスクリプタの状態を確認する

```
1. selectが監視するファイルディスクリプタのリストを持つ
2. selectがIO処理のリクエストを受け付ける
3. selectがファイルディスクリプタのリストをカーネルへ送る
4. カーネルが受け取ったリストから全てのファイルディスクリプタの状態を確認・更新する
5. カーネルが確認・更新し終わったらselectへリストを返す
6. selectが返ってきたリストをチェックし、Ready状態のファイルディスクリプタを探す
7. 見つかったReady状態のファイルディスクリプタに対してIO処理が実行される
```

#### `epoll`
- 監視するファイルディスクリプタのサイズに制限がない
- カーネルがファイルディスクリプタの状態を管理する
  どのファイルディスクリプタがReady状態かわかる

```
1. epollがカーネルに対して監視して欲しいファイルディスクリプタのリストを送る
2. カーネルがリスト内のファイルディスクリプタを常時監視し、状態を保存する
3. epollがIO処理のリクエストを受け付ける
4. epollがカーネルに対してReady状態のファイルディスクリプタを問い合わせる
5. カーネルがReady状態のファイルディスクリプタのリストを返す
6. 返ってきたReady状態のファイルディスクリプタに対してIO処理が実行される
```
