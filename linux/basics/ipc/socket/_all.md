# ソケット
- 参照: 例解UNIX/Linuxプログラミング教室P291-322
- 参照: 詳解UNIXプログラミング第3版 16. ネットワークIPC: ソケット
- 参照: Linuxプログラミングインターフェース 56章

## TL;DR
- ネットワークを跨いだプロセス間通信を行う双方向インターフェース
  - ソケットに書く   -> 他のプロセスにデータが送信される
  - ソケットから読む -> 他のプロセスからデータを受信する
- ソケットディスクリプタ - プロセスとソケットを結びつける記述子
  - ソケットディスクリプタはファイルディスクリプタとして実装される
  - ソケットにはファイルオフセットの概念がない
- ソケットはバイトストリームを送受信する
  - ファイルと違い、位置決めはできない

## 操作
#### サーバープロセスが使用するシステムコール
1. `socket`
2. `bind`
3. `listen`
4. `accept`
5. `read` / `recv` / `write` / `send`
6. `shutdown`
7. `close`

#### クライアントプロセスが使用するシステムコール
1. `socket`
2. `connect`
3. `read` / `recv` / `write` / `send`
4. `shutdown`
5. `close`

### `socket(2)`
- プロセスに新しいソケットを一つ作成し、ソケットディスクリプタを返す
  - アドレス形式 - 通信領域(通信手段)
    - `AF_INET`  - INET領域(IPv4によるTCP/IPを使用したプロセス間通信)
    - `AF_INET6` - INET6領域(IPv6によるTCP/IPを使用したプロセス間通信)
    - `AF_UNIX`  - UNIX領域(同一コンピュータ内のプロセス間通信)
    - `AF_UNSPEC` - 規定なし
    - 通信領域によってプロトコルファミリとアドレスファミリが決定する
  - ソケット種別 - 通信形式
    - `SOCK_STREAM` - 順序・信頼性・双方向・コネクション型バイトストリーム
    - `SOCK_DGRAM`  - 固定長・非信頼性・コネクションレス型データグラム
  - プロトコル
    - ソケット種別によりデフォルトプロトコルが決まる
- ソケットを作成した時点で相手となるプロセス(入出力する対象)は指定されない

### `bind(2)`
- プロセスが紐づいているソケットに固有のアドレスを対応づける
  - IPアドレス - ポート番号の組
  - 接続受け付け時、相手となるプロセスが送信先を決定する際に必要となる
- クライアントリクエストが到着するサーバーのソケットには基地のアドレスをつける必要がある
- `bind(2)`を呼ぶ前にソケット固有のアドレスのデータ(`sockaddr`構造体)を作成する必要がある
  - プロセスが動くコンピュータにおいて正当なアドレス
  - ソケットを作成したときのアドレスファミリで扱える形式のアドレス
  - ポート番号が1024以上

#### IPアドレス
- `INADDR_ANY` (`<netinet/in.h>`)
  - ソケット端点にシステム上のすべてのネットワークインターフェースを対応づけたマクロ
  - システムに装着された任意のネットワークインターフェースからパケットを受け取る
  - 自ホストが複数のIPアドレスを持っている場合、
    どのアドレス宛て入力でもポート番号が合っていれば受け付ける
    - ネットワークインターフェースにつけられているIPアドレス
    - ループバックアドレス(自ホストのIPアドレス)
- `getsockname(2)` - ソケットにつけられたアドレスを探す
- `getpeername(2)` - 相手と接続されているソケットを通じて相手のアドレスを探索する

### サーバー: `listen(2)`
- クライアントプロセスからの接続を受け付ける
  - ソケットに接続要求を入れるための待ち行列を付け、受付を開始する
  - 保留中の接続要求の待ち行列の長さを指定する

### サーバー: `accept(2)`
- 保留中の接続要求の待ち行列から一つを取り出し、コネクションを確立する
  - クライアントプロセスからの接続要求は一度待ち行列に入り、
    サーバープロセスが`accept`を呼ぶ度に先頭から順に受け入れられる
  - 待ち行列が空の場合、要求が来るまでサーバープロセスは待ち状態になる
  - クライアントプロセスからの接続要求を受け入れると、
    `accept`がそのコネクションが繋がった新しいサーバーソケット(接続済みソケット)を作り、
    そのソケットディスクリプタを返す(コネクションの確立)
  - 元のサーバーソケット(接続待ちソケット)は次の接続要求に対して`accept`を呼ぶ
    - 以下繰り返し
  - 予めクライアントソケットの名前を受け取るためのメモリ領域を確保しておき、
    接続要求を受け入れた際にクライアントソケットの名前を保存する
- 接続するソケットは元のソケット(listen socket)と同じソケット種別・アドレスファミリ
- `accept(2)`はクライアントのアドレスをバッファに納める
- 保留中の接続要求がない場合は処理をブロックする
  - `poll(2)` / `select(2)`を使って接続要求を待つこともできる

### クライアント: `connect(2)`
- サーバープロセスに接続要求を出す
  - 接続先のサーバーソケット固有のアドレスを指定する
  - 接続要求に使用されたソケットが直接サーバーソケットとコネクションを確立する
    - クライアントプロセスでは新しいソケットは作成されない
- 接続先のマシンが稼働中で、
  接続先のソケットに指定のアドレスが紐づいており、
  接続保留キューに空きがある場合のみ接続要求が成功する

### `read(2)` / `recv(2)` / `write(2)` / `send(2)`
#### 読み込み
- ソケットから読めるデータがない場合、システムコールの呼び出しがブロックする
- ストリームから1バイトも読み込めなかった場合、EOFを意味する
- `read(2)` - ファイルと同じように操作できる
- `recv(2)` - `read(2)`と同じ
  - データをどのように受診するかを制御するオプションを指定できる
- `recvfrom(2)` - `recv(2)`と同じ
  - データを送ってきた送信元アドレスを取得する
  - コネクションレスソケットに使用する
- `recvmsg(2)` - `msghdr`構造体を利用しデータを複数バッファに受け取

#### 書き出し
- ネットワークにデータを送信するため、
  書き出し用システムコールはカーネル内にあるネットワーク用バッファにデータを置く
- 利用できるバッファがない場合、システムコールの呼び出しがブロックする
- `write(2)` - ファイルと同じように操作できる
- `send(2)` - `write(2)`と同じ
  - 送出するデータの扱い方を変更するフラグを指定できる
- `sendto(2)` - `send(2)`と同じ
  - 送信先アドレスを指定できる
  - コネクションレスソケットに使用する
- `sendmsg(2)` - `msghdr`構造体を利用しデータを複数バッファで送信する

```c
struct msghdr {
  void         *msg_name;       // 追加のアドレス
  socklen_t     msg_namelen;    // アドレスのバイトサイズ
  struct iovec *msg_iov;        // 入出力バッファの配列
  size_t        msg_iovlen;     // msg_iovの要素数
  void         *msg_control;    // 補助データ
  size_t        msg_controllen; // 補助データバッファ長
  int           msg_flags;      // 受診メッセージ用フラグ
};
```

### `shutdown(2)`
- 指定したソケットの入出力を停止する
  - `SHUT_RD` - 受信の停止
  - `SHUT_WR` - 送信の停止
  - `SHUT_RDWR` - 送受信の停止

#### `close(2)`との違い
- `shutdown(2)`はソケットを参照する使用中のディスクリプタの個数に関係なくソケットを非活性化できる
  - `close(2)`は使用中の最後の参照がクローズされた時にのみネットワークの端点を解放する
- `shutdown(2)`はソケットの一方向の通信を止めることができる

### `close(2)`
- ソケットディスクリプタを閉じる
  - ソケットを参照している全てのソケットディスクリプタが閉じると
    ソケットは廃棄される

## 並行サーバー
### マルチプロセス
1. サーバープロセスが接続待ちソケットに対して`accept(2)`を行い、
   サーバープロセスがクライアントプロセスからの接続要求を待つ
2. サーバープロセスとクライアントプロセス間のコネクションが確立し、
   `accept(2)`が接続済みソケットを返す
3. サーバープロセスがforkし子サーバープロセスを作成する
4. 子サーバープロセスが接続待ちソケットディスクリプタを`close(2)`する
5. 子サーバープロセスが接続済みソケットでクライアントプロセスと通信する
6. 子サーバープロセスは通信が終了すると`exit(2)`する
   親サーバープロセスは接続済みソケットディスクリプタを閉じる

### 入出力の多重化
- 一つのプロセスで複数の入出力を扱う
  - サーバーソケットは`accept(2)`や`read(2)`の段階で
    クライアントプロセスからの入力待ちになる可能性がある
  - 複数のソケットディスクリプタを監視する場合、
    準備ができたディスクリプタを特定する必要がある
- `select(2)` - 監視する対象のディスクリプタ群を指定し、準備ができたディスクリプタ数を返す
  - `fd_set readfds`  - 読み込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set writefds` - 書き込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set errorfds` - エラーになった際に通知する対象のディスクリプタ群
  - `fd_set`型 - 複数のディスクリプタを保持できるシステムデータ型
    - `FD_ZERO`  - 指定した`fd_set`型のデータの全ビットを0にする
    - `FD_SET`   - `fd_set`にディスクリプタを追加する
    - `FD_CLR`   - `fd_set`からディスクリプタを削除する
    - `FD_ISSET` - `fd_set`にディスクリプタが含まれていれば0以外、含まれていなければ0を返す

## 非ブロック / 非同期入出力
- 入出力できるデータがない場合、ソケットは処理をブロックする
- ソケットを非ブロックモードにすると、ブロックせず`errno`に`EWOULDBLOCK` / `EAGAIN`を設定する
  - `poll(2)` / `select(2)`でデータの送受信ができるタイミングを判定する

### 非同期入出力
- ソケットからデータを読み取れるようになった時
  あるいはソケットの出力キューに空きができた時
  シグナル`SIGIO`を送る
  - 適切なプロセスにシグナルが配送されるよう、ソケットの所有者を設定する必要がある
    - `fcntl(2)`にコマンド`F_SETOWN` / `FIOSETOWN`を使用
    - `ioctl(2)`にコマンド`SIOCSPGRP`を使用
  - 入出力操作がブロックしない時にシグナルを送るよう、ソケットに指示する必要がある
    - `fcntl(2)`にコマンド`F_SETFL`を使いファイルフラグ`O_ASYNC`を有効化
    - `ioctl(2)`にコマンド`FIOASYNCを使用`

## IO多重化
- 参照: Linuxネットワークプログラミング Chapter8 複数のソケットを使う 8-1

### `epoll` API
- IOイベント通知機能
  - 複数のソケットを扱う際、ソケット群を監視し、読み書きの準備ができたソケットを通知する

#### `epoll_create(2)`
- `epoll`で使用するためのインスタンスをカーネル内に生成し、そのファイルディスクリプタを返す

#### `epoll_ctl(2)`
- 準備待ちを行うファイルディスクリプタと
  `epoll_create(2)`で作成した`epoll`ファイルディスクリプタ・IOイベントの関連付けを行う
- その他`epoll`に対する操作

```c
// イベントを表現するepoll_event構造体

typedef union epoll_data {
  void        *ptr;
  int          fd;
  uint32_t     u32;
  uint64_t     u64;
} epoll_data_t;

struct epoll_event {
  uint32_t     events; // epoll イベント
  epoll_data_t data;   // ユーザーデータ変数
};
```

#### `epoll_wait(2)`
- `epoll`ファイルディスクリプタに対してIOイベントの準備待ちを行う
  - 受信待ち / 送信待ち / エラーの有無 / タイムアウト
- イベント待ちの結果を`epoll_event`構造体の配列に格納する
- ブロッキングAPI
  - シグナルでデッドロックを回避する
  - ソケットペアでデッドロックを回避する

### `select(2)` / `poll(2)`
- `epoll` APIと同じ機能を果たすが重い
- 後方互換性のため`epoll`の代わりに使用されることがある

### `select`と`epoll`の違い
- 引用: [I/O多重化の方法(selectとepollの違い)](http://portaltan.hatenablog.com/entry/2015/11/12/145840)
  - 参照: [epollの使い方 ~I/O Multiplexing~](http://kamiyasu2.blog.fc2.com/blog-entry-45.html)

#### `select`
- 監視するファイルディスクリプタのサイズに制限がある
- ファイルディスクリプタを一件ずつ確認する
- カーネルが全てのファイルディスクリプタの状態を確認する

```
1. selectが監視するファイルディスクリプタのリストを持つ
2. selectがIO処理のリクエストを受け付ける
3. selectがファイルディスクリプタのリストをカーネルへ送る
4. カーネルが受け取ったリストから全てのファイルディスクリプタの状態を確認・更新する
5. カーネルが確認・更新し終わったらselectへリストを返す
6. selectが返ってきたリストをチェックし、Ready状態のファイルディスクリプタを探す
7. 見つかったReady状態のファイルディスクリプタに対してIO処理が実行される
```

#### `epoll`
- 監視するファイルディスクリプタのサイズに制限がない
- カーネルがファイルディスクリプタの状態を管理する
  どのファイルディスクリプタがReady状態かわかる

```
1. epollがカーネルに対して監視して欲しいファイルディスクリプタのリストを送る
2. カーネルがリスト内のファイルディスクリプタを常時監視し、状態を保存する
3. epollがIO処理のリクエストを受け付ける
4. epollがカーネルに対してReady状態のファイルディスクリプタを問い合わせる
5. カーネルがReady状態のファイルディスクリプタのリストを返す
6. 返ってきたReady状態のファイルディスクリプタに対してIO処理が実行される
```
