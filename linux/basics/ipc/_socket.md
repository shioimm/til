# ソケット
- 参照: 例解UNIX/Linuxプログラミング教室P291-322
- 参照: 詳解UNIXプログラミング第3版 16. ネットワークIPC: ソケット

## TL;DR
### ソケット
- ネットワークを跨いだプロセス間通信を行う双方向インターフェース
  - ソケットに書く   -> 他のプロセスにデータが送信される
  - ソケットから読む -> 他のプロセスからデータを受信する
- ソケットディスクリプタ - プロセスとソケットを結びつける記述子
  - ソケットディスクリプタはファイルディスクリプタとして実装される
  - ソケットにはファイルオフセットの概念がない
- ソケットはバイトストリームを送受信する
  - ファイルと違い、位置決めはできない

## 操作
#### サーバープロセスが使用するシステムコール
1. `socket`
2. `bind`
3. `listen`
4. `accept`
5. `read` / `recv` / `write` / `send`
6. `shutdown`
7. `close`

#### クライアントプロセスが使用するシステムコール
1. `socket`
2. `connect`
3. `read` / `recv` / `write` / `send`
4. `shutdown`
5. `close`

### `socket(2)`
- プロセスに新しいソケットを一つ作成し、ソケットディスクリプタを返す
  - アドレス形式 - 通信領域(通信手段)
    - `AF_INET`  - INET領域(IPv4によるTCP/IPを使用したプロセス間通信)
    - `AF_INET6` - INET6領域(IPv6によるTCP/IPを使用したプロセス間通信)
    - `AF_UNIX`  - UNIX領域(同一コンピュータ内のプロセス間通信)
    - `AF_UNSPEC` - 規定なし
    - 通信領域によってプロトコルファミリとアドレスファミリが決定する
  - ソケット種別 - 通信形式
    - `SOCK_STREAM` - 順序・信頼性・双方向・コネクション型バイトストリーム
    - `SOCK_DGRAM`  - 固定長・非信頼性・コネクションレス型データグラム
  - プロトコル
    - ソケット種別によりデフォルトプロトコルが決まる
- ソケットを作成した時点で相手となるプロセス(入出力する対象)は指定されない

### `bind(2)`
- プロセスが紐づいているソケットに固有のアドレスを対応づける
  - IPアドレス - ポート番号の組
  - 接続受け付け時、相手となるプロセスが送信先を決定する際に必要となる
- クライアントリクエストが到着するサーバーのソケットには基地のアドレスをつける必要がある
- `bind(2)`を呼ぶ前にソケット固有のアドレスのデータ(`sockaddr`構造体)を作成する必要がある
  - プロセスが動くコンピュータにおいて正当なアドレス
  - ソケットを作成したときのアドレスファミリで扱える形式のアドレス
  - ポート番号が1024以上

#### IPアドレス
- `INADDR_ANY` (`<netinet/in.h>`)
  - ソケット端点にシステム上のすべてのネットワークインターフェースを対応づけたマクロ
  - システムに装着された任意のネットワークインターフェースからパケットを受け取る
  - 自ホストが複数のIPアドレスを持っている場合、
    どのアドレス宛て入力でもポート番号が合っていれば受け付ける
    - ネットワークインターフェースにつけられているIPアドレス
    - ループバックアドレス(自ホストのIPアドレス)
- `getsockname(2)` - ソケットにつけられたアドレスを探す
- `getpeername(2)` - 相手と接続されているソケットを通じて相手のアドレスを探索する

### サーバー: `listen(2)`
- クライアントプロセスからの接続を受け付ける
  - ソケットに接続要求を入れるための待ち行列を付け、受付を開始する
  - 保留中の接続要求の待ち行列の長さを指定する

### サーバー: `accept(2)`
- 保留中の接続要求の待ち行列から一つを取り出し、コネクションを確立する
  - クライアントプロセスからの接続要求は一度待ち行列に入り、
    サーバープロセスが`accept`を呼ぶ度に先頭から順に受け入れられる
  - 待ち行列が空の場合、要求が来るまでサーバープロセスは待ち状態になる
  - クライアントプロセスからの接続要求を受け入れると、
    `accept`がそのコネクションが繋がった新しいサーバーソケット(接続済みソケット)を作り、
    そのソケットディスクリプタを返す(コネクションの確立)
  - 元のサーバーソケット(接続待ちソケット)は次の接続要求に対して`accept`を呼ぶ
    - 以下繰り返し
  - 予めクライアントソケットの名前を受け取るためのメモリ領域を確保しておき、
    接続要求を受け入れた際にクライアントソケットの名前を保存する
- 接続するソケットは元のソケット(listen socket)と同じソケット種別・アドレスファミリ
- `accept(2)`はクライアントのアドレスをバッファに納める
- 保留中の接続要求がない場合は処理をブロックする
  - `poll(2)` / `select(2)`を使って接続要求を待つこともできる

### クライアント: `connect(2)`
- サーバープロセスに接続要求を出す
  - 接続先のサーバーソケット固有のアドレスを指定する
  - 接続要求に使用されたソケットが直接サーバーソケットとコネクションを確立する
    - クライアントプロセスでは新しいソケットは作成されない
- 接続先のマシンが稼働中で、
  接続先のソケットに指定のアドレスが紐づいており、
  接続保留キューに空きがある場合のみ接続要求が成功する

### `read(2)` / `recv(2)` / `write(2)` / `send(2)`
#### 読み込み
- ソケットから読めるデータがない場合、システムコールの呼び出しがブロックする
- ストリームから1バイトも読み込めなかった場合、EOFを意味する
- `read(2)` - ファイルと同じように操作できる
- `recv(2)` - `read(2)`と同じ
  - データをどのように受診するかを制御するオプションを指定できる
- `recvfrom(2)` - `recv(2)`と同じ
  - データを送ってきた送信元アドレスを取得する
  - コネクションレスソケットに使用する
- `recvmsg(2)` - `msghdr`構造体を利用しデータを複数バッファに受け取

####書き出し
- ネットワークにデータを送信するため、
  書き出し用システムコールはカーネル内にあるネットワーク用バッファにデータを置く
- 利用できるバッファがない場合、システムコールの呼び出しがブロックする
- `write(2)` - ファイルと同じように操作できる
- `send(2)` - `write(2)`と同じ
  - 送出するデータの扱い方を変更するフラグを指定できる
- `sendto(2)` - `send(2)`と同じ
  - 送信先アドレスを指定できる
  - コネクションレスソケットに使用する
- `sendmsg(2)` - `msghdr`構造体を利用しデータを複数バッファで送信する

```c
struct msghdr {
  void         *msg_name;       // 追加のアドレス
  socklen_t     msg_namelen;    // アドレスのバイトサイズ
  struct iovec *msg_iov;        // 入出力バッファの配列
  size_t        msg_iovlen;     // msg_iovの要素数
  void         *msg_control;    // 補助データ
  size_t        msg_controllen; // 補助データバッファ長
  int           msg_flags;      // 受診メッセージ用フラグ
};
```

### `shutdown(2)`
- 指定したソケットの入出力を停止する
  - `SHUT_RD` - 受信の停止
  - `SHUT_WR` - 送信の停止
  - `SHUT_RDWR` - 送受信の停止

#### `close(2)`との違い
- `shutdown(2)`はソケットを参照する使用中のディスクリプタの個数に関係なくソケットを非活性化できる
  - `close(2)`は使用中の最後の参照がクローズされた時にのみネットワークの端点を解放する
- `shutdown(2)`はソケットの一方向の通信を止めることができる

### `close(2)`
- ソケットディスクリプタを閉じる
  - ソケットを参照している全てのソケットディスクリプタが閉じると
    ソケットは廃棄される

## アドレシング
- 通信先となるプロセスを識別する
  - ネットワークアドレス - ネットワーク上のコンピュータを識別
  - ポート番号 - コンピュータ上の特定のプロセスの識別

### バイトオーダー
- マルチバイトデータ型のバイトの配置順序
- プロセッサアーキテクチャによって変わる
  - リトルエンディアン - 最高位バイトアドレスが最上位バイト(MSB)
  - ビッグエンディアン - 最高位バイトアドレスが最下位バイト(LSB)
  - TCP/IPプロトコルはビッグエンディアン
    - 通信時、ホストバイトオーダーをネットワークバイトオーダーにに合わせる必要がある
- `htonl(3)` - ネットワークバイトオーダーでの32ビット整数を返す
- `htons(3)` - ネットワークバイトオーダーでの16ビット整数を返す
- `ntohl(3)` - ホストバイトオーダーでの32ビット整数を返す
- `ntohs(3)` - ホストバイトオーダーでの16ビット整数を返す

### アドレス形式
- 特定の通信ドメイン内のソケット端点を識別する
- サーバーソケット・クライアントソケットで同じ型の構造体を使用する

```c
// sockaddr構造体 - ソケット固有のアドレスのデータを保存する汎用アドレス構造体
// 16バイト

struct sockaddr {
  sa_family_t sa_family; // アドレスファミリ
  char        sa_data[]; // 可変長アドレス
};
```

```c
// sockaddr_in構造体 - TCP(IPv4)を使用する際に使用するsockaddr構造体
// 16バイト

struct sockaddr_in {
  sa_family_t    sin_family;  // アドレスファミリ(AF_INET)
  in_port_t      sin_port;    // ポート番号
  struct in_addr sin_addr;    // IPv4アドレス(INADDR_ANY)
};

// INET6領域のアドレスファミリを使用する場合はsockaddr_in6構造体(28バイト)
// UNIX領域のアドレスファミリを使用する場合はsockaddr_un構造体を使用する
```

```c
// in_addr構造体 - IPアドレスを記述する構造体

struct in_addr {
  inaddr_t s_addr; // IPv4アドレス
};

// IPv6アドレスを扱う場合はin6_addr構造体を使用する

// sin_portとs_addrはマルチバイト整数・ビッグエンディアン(ネットワークバイトオーダ)
```
- `inet_ntop(3)` - ネットワークバイトオーダーのバイナリアドレスをテキスト文字列に変換
- `inet_pton(3)` - テキスト文字列をネットワークバイトオーダーのバイナリアドレスに変換

```c
// 受信時にバイト数が不明の場合
// 128バイト

struct sockaddr_storage {
  sa_family_t ss_family; // アドレスファミリ
};
```

### アドレス探索
#### ネットワーク構成情報
- ネットワーク構成情報は様々な場所に格納されうる
  - `/etc/services` / `/etc/hosts`
  - DNS
  - NIS
- `gethostent(3)` - 当該コンピュータシステムのホストデータベースファイルを取得

```c
struct hostent {
  char  *h_name;      // ホスト名
  char **h_aliases;   // ホスト別名配列へのポインタ
  int    h_addtype;   // アドレス種別
  int    h_length;    // アドレスのバイト長
  char **h_addr_list; // ネットワークアドレスの配列へのポインタ
};
```

- `getnetbyaddr(3)` - ホスト名ではなくネットワーク名からネットワークアドレスを得る

```c
struct netent {
  char      *n_name;     // ネットワーク名
  char     **n_aliases;  // ネットワーク別名配列へのポインタ
  int        n_addrtype; // アドレス種別
  uint32_t   n_net;      // ネットワーク番号
};
```

- `getprotobyname(3)` / `getprotobynumber(3)` / `getprotent(3)` - プロトコル名と番号のマップ

```c
struct protent {
  char  *p_name;    // プロトコル名
  char **p_aliases; // プロトコル別名配列へのポインタ
  int    p_proto;   // プロトコル番号
};
```

- `getservbyname(3)` / `getservbyport` / `getservent` - サービス名とポート番号のマップ

```c
struct servent {
  char  *s_name;    // サービス名
  char **s_aliases; // サービス別名配列へのポインタ
  int    s_port;    // ポート番号
  char  *s_proto;   // プロトコル名
};
```

- `getaddrinfo(3)` - ホスト名とサービス名をアドレスにマップする
- `getnameinfo(3)` - アドレスをホスト名とサービス名に変換する
  - アドレスの情報を格納する`addrinfo`構造体の連結リストを返す
  - プロトコルファミリに依存しないため、`gethostbyname(3)`に代わって使用される

```c
// 48バイト

struct addrinfo {
  int             ai_flags;      // 振る舞いを指定
  int             ai_family;     // アドレスファミリ(AF_UNSPEC)
  int             ai_socktype;   // ソケットの型
  int             ai_protocol;   // プロトコル
  socklen_t       ai_addrlen;    // アドレスのバイト長
  struct sockaddr *ai_addr;      // sockaddr構造体(ソケットアドレス)へのポインタ
  char            *ai_canonname; // 正規ホスト名
  struct addrinfo *ai_next;      // アドレスリンクリストの次の要素
};

// ai_flagsにAI_PASSIVEを指定することで
// INADDR_ANY / inaddr6anyの切り分けや
// sockaddr_in構造体 / sockaddr_in6構造体の切り分けが不要になる
```

### プロトコル独立な実装
- 特定のアドレスファミリに依存しない実装

```c
// 参照: 例解UNIX/Linuxプログラミング教室P320

#include <sys/types.h>  // socket, connect, read, write, freeaddrinfo, getaddrinfo, gai_strerror
#include <sys/socket.h> // socket, connect, shutdown, freeaddrinfo, getaddrinfo, gai_strerror
#include <stdio.h>
#include <stdlib.h>
#include <string.h>     // memset
#include <sys/uio.h>    // read, write
#include <unistd.h>     // close, read, write
#include <netdb.h>      // reeaddrinfo, getaddrinfo, gai_strerror

char *httpreq = "GET / HTTP/1.0 \r\n\r\n";

int main()
{
  int             s, cc;
  struct addrinfo hints, *addrs;
  char            buf[1024];

  memset(&hints, 0, sizeof(hints));
  hints.ai_family   = AF_UNSPEC;   // アドレスファミリの規定なし
  hints.ai_socktype = SOCK_STREAM; // コネクション型バイトストリーム

  if ((cc = getaddrinfo("localhost", "http", &hints, &addrs)) != 0) {
    fprintf(stderr, "getaddrinfo' %s\n", gai_strerror(cc));
  }

  if ((s = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol)) < 0) {
    perror("socket");
    exit(1);
  }

  if (connect(s, addrs->ai_addr, addrs->ai_addrlen) < 0) {
    perror("connect");
    exit(1);
  }

  freeaddrinfo(addrs);

  write(s, httpreq, strlen(httpreq));

  while ((cc = read(s, buf, sizeof(buf))) > 0) {
    write(1, buf, cc);
  }

  shutdown(s, SHUT_RDWR);
  close(s);

  return 0;
}
```

## 並行サーバー
### マルチプロセス
1. サーバープロセスが接続待ちソケットに対して`accept(2)`を行い、
   サーバープロセスがクライアントプロセスからの接続要求を待つ
2. サーバープロセスとクライアントプロセス間のコネクションが確立し、
   `accept(2)`が接続済みソケットを返す
3. サーバープロセスがforkし子サーバープロセスを作成する
4. 子サーバープロセスが接続待ちソケットディスクリプタを`close(2)`する
5. 子サーバープロセスが接続済みソケットでクライアントプロセスと通信する
6. 子サーバープロセスは通信が終了すると`exit(2)`する
   親サーバープロセスは接続済みソケットディスクリプタを閉じる

### 入出力の多重化
- 一つのプロセスで複数の入出力を扱う
  - サーバーソケットは`accept(2)`や`read(2)`の段階で
    クライアントプロセスからの入力待ちになる可能性がある
  - 複数のソケットディスクリプタを監視する場合、
    準備ができたディスクリプタを特定する必要がある
- `select(2)` - 監視する対象のディスクリプタ群を指定し、準備ができたディスクリプタ数を返す
  - `fd_set readfds`  - 読み込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set writefds` - 書き込み可能になった際に通知する対象のディスクリプタ群
  - `fd_set errorfds` - エラーになった際に通知する対象のディスクリプタ群
  - `fd_set`型 - 複数のディスクリプタを保持できるシステムデータ型
    - `FD_ZERO`  - 指定した`fd_set`型のデータの全ビットを0にする
    - `FD_SET`   - `fd_set`にディスクリプタを追加する
    - `FD_CLR`   - `fd_set`からディスクリプタを削除する
    - `FD_ISSET` - `fd_set`にディスクリプタが含まれていれば0以外、含まれていなければ0を返す

## ホスト名からIPアドレスへの変換
- `gethostbyname(3)` - 指定したホスト名をIPアドレスに変換し`hostent`構造体へのポインタを返す
  - IPv4の名前解決しかできない
```c
// hostent構造体
struct  hostent {
  char *h_name;       // ホストの正式名
  char **h_aliases;   // ホストの別名の配列
  int  h_addrtype;    // アドレスファミリ(AF_INET)
  int  h_length;      // アドレスのバイト数(4)
  char **h_addr_list; // IPアドレスの配列
};

// エラーコード
// HOST_NOT_FOUND ホストが存在しない
// NO_DATA        適切なIPアドレスが見つからない
// NO_RECOVERY    検索中のエラー
// TRY_AGAIN      要再試行
```

## ソケットオプション
### 種類
- 全てのソケット種別に適用できる汎用オプション
- 下位プロコトルに依存し、ソケットレベルで管理されるオプション
- 個々のプロトコル特有のオプション

### オプションを設定する
- `setsockopt(2)` - ソケットオプションの設定
  - プロトコルの識別
  - オプションのON/OFF

### オプションの状態を問い合わせる
- `getsockopt(2)` - オプションの現在値を取得

## 優先配送データ
- 通常よりも高い優先度で配送できるオプション
- 転送のためにキューに入っているデータに先駆けて配送される
- TCPのみ
- `send`関数群にフラグ`MSG_OOB`を指定すると緊急データ扱いになる
  - シグナル`SIGURG`を配送する
- 現在ある緊急データを読み取る前に別に緊急データが到着すると
  現在の緊急データは破棄される

### 緊急マーク
- データストリームの中で緊急データが占める位置
  - ソケットオプション`SO_OOBINLINE`で通常データに埋め込まれた
    緊急データを受け取ることができる

## 非ブロック / 非同期入出力
- 入出力できるデータがない場合、ソケットは処理をブロックする
- ソケットを非ブロックモードにすると、ブロックせず`errno`に`EWOULDBLOCK` / `EAGAIN`を設定する
  - `poll(2)` / `select(2)`でデータの送受信ができるタイミングを判定する

### 非同期入出力
- ソケットからデータを読み取れるようになった時
  あるいはソケットの出力キューに空きができた時
  シグナル`SIGIO`を送る
  - 適切なプロセスにシグナルが配送されるよう、ソケットの所有者を設定する必要がある
    - `fcntl(2)`にコマンド`F_SETOWN` / `FIOSETOWN`を使用
    - `ioctl(2)`にコマンド`SIOCSPGRP`を使用
  - 入出力操作がブロックしない時にシグナルを送るよう、ソケットに指示する必要がある
    - `fcntl(2)`にコマンド`F_SETFL`を使いファイルフラグ`O_ASYNC`を有効化
    - `ioctl(2)`にコマンド`FIOASYNCを使用`
