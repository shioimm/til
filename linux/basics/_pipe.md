# パイプ
- 参照: 例解UNIX/Linuxプログラミング教室P257-289

## TL;DR
- プロセス間通信の仕組みの一つ
  - パイプにおけるデータの流れは入力 -> 出力の一方通行
  - パイプは同じマシンのプロセスとのみ通信を行う

### 読み書き
- パイプは書き込み口と読み込み口を持つ
  - 書き込み口と読み込み口はプログラム中においてファイルディスクリプタとして表現される

### バッファ
- パイプに書き込んだデータはパイプ自身が持つバッファに書き込まれる
  - バッファが上限に達している状態で書き込もうとした場合
    またはバッファが空の状態で読み込もうとした場合、
    読み書きができるようになるまで操作がブロックされる

## パイプの操作
### 作成
- `pipe(2)` - パイプを作成し、パイプ両端のファイルディスクリプタ(読み込み口・書き込み口)を返す

#### コマンドを実行してパイプでつなぐ
- `popen(3)`  - パイプを作成してコマンドを実行し、パイプにストリームを返す
  - プロセスがパイプを作成 -> fork -> 子プロセスでシェルを起動 -> シェル上でコマンドを実行
- `pclose(3)` - `popen(3)`で開いたパイプを閉じる

## パイプによるプロセス間通信
親プロセス -> 子プロセスへの通信を行う場合

1. 親プロセスがパイプを生成
    - 親プロセスと書き込み口・読み込み口がつながったパイプが生成される
2. 親プロセスがフォークする
    - 子プロセスが親プロセスからパイプに対して書き込み口・読み込み口を受け継ぐ
3. 親プロセスがパイプからの読み込み口を閉じる
4. 子プロセスがパイプへの書き込み口を閉じる
5. 親プロセスから子プロセスへ通信可能な状態になる

## 使用上の注意
- 閉じたパイプへの読み書き
  - 書き手がパイプを閉じた後に読み手がパイプを読む -> EOF
  - 読み手がパイプを閉じた後に書き手がパイプに書く -> SIGPIPE
- パイプの閉じ忘れ
  - 書き込み口の閉じ忘れ -> 読み手にEOFが来ずreadがブロックされる
  - 読み込み口の閉じ忘れ -> パイプのバッファが溢れてwriteがブロックされる
