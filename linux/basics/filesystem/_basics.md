# ファイルシステム
- 参照: 例解UNIX/Linuxプログラミング教室P225-269 / P375-432
- 参照: 詳解UNIXプログラミング第3版 4. ファイルとディレクトリ
- 参照: Linuxネットワークプログラミング Chapter10 TCPサーバプログラミング 10-4
- 参照: [試して理解]Linuxのしくみ 第7章 ファイルシステム
- 参照: Linuxプログラミングインターフェース 14章

## TL;DR
- カーネルが提供しているファイル操作の仕組み
  - データの格納・ファイルの名前付け・ファイルの属性の保持・ファイルの整理などの機能
- ハードディスクの中に作られたファイル、ディレクトリの集合体
  - ファイル、ディレクトリ、属性情報
- ファイル抽象
  - Unixのファイルシステムにおいては多くの対象をファイルとしてみな
  - ファイルは抽象化された共通の操作方法を持つ

## ファイルシステムが扱うファイルの種類
- ファイル `S_ISREG`
  - バイト列を格納するファイル
- ディレクトリ `S_ISRDIR`
  - ファイルシステムの構造を作るファイル
- 文字型特殊ファイル(端末など) `S_ISCHR`
  - 1バイトごとに入出力する装置を表すファイル
- ブロック型特殊ファイル(ディスクなど) `S_ISBLK`
  - 512バイトごとに入出力する装置を表すファイル
- シンボリックリンク `S_ISLNK`
  - ファイルを別の名前で参照するためのファイル
- FIFO(名前付きパイプ) `S_ISFIFO`
  - プロセス間通信を行うためのファイル
- ソケット `S_ISSOCK`
  - プロセス間通信を行うためのファイル

## アクセス制御
- ファイルに対する操作が許可されるかどうかはプロセスの属性とファイルの属性によって決まる

### プロセスの属性
- 各プロセスは実効ユーザーIDと実効グループIDを持つ
  - 実効ユーザーID(`uid_t`型) - そのプロセスを実行したユーザーのユーザーID
  - 実効グループID(`gid_t`型) - そのプロセスを実行したユーザーのグループID

### ファイルの属性
- 各ファイルはユーザーID、グループID、アクセス許可ビットを持つ
  - ユーザーID - そのファイルを作ったプロセスのユーザーID(ファイルの所有者)
  - グループID - そのファイルを作ったプロセスのユーザーのグループID(ファイルの所有グループ)
  - アクセス許可ビット - 誰にどのような操作を許可するかを決める9ビットのビットフラグ
    - `S_IRUSR` / `S_IWUSR` / `S_IXUSR` - ユーザーの読み取り / 書き取り / 実行
    - `S_IRGSR` / `S_IWGSR` / `S_IXGSR` - グループの読み取り / 書き取り / 実行
    - `S_IROSR` / `S_IWOSR` / `S_IXOSR` - 他ユーザーの読み取り / 書き取り / 実行
    - ファイル実行時、ファイルパスに現れる全てのファイルに対してアクセス許可が検査される
      - `/dev/tty` -> `/` + `/dev` + `/dev/tty`

```
// アクセス許可ビット Ex.

rwx r-x r-x

所有者       - プロセスの実効ユーザーIDとファイルの所有者が等しい
所有グループ - プロセスの実効グループIDとファイルの所有グループが等しい
他ユーザー

r 読み取り
w 書き取り
x 実行
```

### ファイルモード作成時マスク
- プロセスはファイルモード作成時マスクを持つ
- ファイルモード作成時マスクはプロセスが新規ファイルや新規ディレクトリを作成する際に適用される
- 新規ファイルを作成する場合、適切なアクセス許可ビットが有効になっていることを保障するため
  プログラム実効中にumask値を明示的に設定する必要がある

#### `umask(1)` / `umask(2)`
- プロセスのファイルモード作成時マスクを設定し、直前の設定を返す
  - デフォルトのumask値は通常ログイン時にシェルの起動ファイルで設定される
  - プロセスのファイルモード作成時マスクを変更しても親プロセスのマスクには影響しない

### ディレクトリ
- ディレクトリはデータ領域にディレクトリエントリを持つ
  - ディレクトリエントリ - ファイル名 / i-node番号の組み
- 各ディレクトリエントリは一つのi-nodeを指す
  - エントリがi-node番号を持つ時、エントリを格納するディレクトリは当該i-nodeへリンクしている
    - Ex. ディレクトリ`A`がディレクトリエントリ`A'`を持ち、
      ディレクトリエントリ`A'`がi-node`A"`を指しているとき、
      ディレクトリ`A`はi-node`A"`にリンクしている

#### ハードリンク
- ディレクトリエントリがi-node番号を持つ(i-nodeを指す)こと
- 同じi-node番号を指す複数のエントリが生成されうる(`ln(1)`)
  - i-nodeは自身を指すエントリの数(リンク数)をデータとして持つ
  - カーネルはディレクトリエントリを削除する際、i-nodeのリンク数を減らしてゆく
    リンク数が0になったときi-nodeと実データを削除する
    (ファイルに割り付けていたデータブロックを解放できる)
  - パーティションが異なるディレクトリからのリンクは作成できない
    - 同じパーティションの中ではi-node番号は一意になるが、
      パーティションを跨ぐと 一意になるとは限らないため
  - ディレクトリへのリンクは作成できない

#### シンボリックリンク
- ハードリンクと同じ機能を提供しつつ、ハードリンクのような制約を持たない
  - リンク元ファイルと同一のファイルシステム上でなくても作成できる
  - スーパーユーザー以外でもディレクトリへのハードリンクを作れる
  - 実体が存在していなくても作成することができる
- リンクしたいファイル名へのポインタを格納するi-nodeのi-node番号を持つエントリ
  - i-nodeを共有しないため、リンク先のファイルとは別のファイルとなる
- ファイルやディレクトリ構造全体をシステム上の他の場所へ移動するために使用される場合が多い

## ディレクトリの情報
- ディレクトリはデータ領域にデータを持ち、そこにディレクトリエントリ(i-node番号 - ファイル名)を持つ
- ディレクトリの実際の形式は実装と設計に依存する
  - `read(2)`でディレクトリの内容にアクセスすることは禁止されている
- ディレクトリはディレクトリストリームによってディレクトリの開閉・取得を行う
  - `DIR`構造体 - ディレクトリストリーム / 読み取り中のディレクトリに関する情報を管理する内部構造

```c
// dirent構造体 - ディレクトリエントリの情報を格納する構造体 / 実装に依存する

struct dirent {
  ino_t          d_ino;       // i-node番号
  unsigned short d_reclen;    // このレコードの長さ
  unsigned char  d_type;      // ファイル種別
  char           d_name[256]; // NULL終端のファイル名
};
```
- `opendir(3)`   - ディレクトリを開く
- `readdir(3)`   - ディレクトリ項目を読み込み、`dirent`構造体に値を設定する
- `closendir(3)` - ディレクトリを閉める

## カレントワーキングディレクトリ
- 各プロセスはカレントワーキングディレクトリを持つ
- ログイン時点でのカレントワーキングディレクトリは
  `etc/passwd`の6番目のフィールドで指定されている(ホームディレクトリ)
  - カレントワーキングディレクトリ - プロセスの属性
  - ホームディレクトリ             - ログイン名の属性
- `getcwd(3)` - カレントワーキングディレクトリの取得
- `chdir(2)`  - カレントワーキングディレクトリの変更
  - `chdir(2)`を実行するプロセスと`chdir(2)`を実行するプロセスを起動したプロセスは別のプロセスであるため
    後者のカレントワーキングディレクトリには影響を及びさない
- `fchdir(2)` - 渡されたファイルディスクリプタを参照するディレクトリをカレントワーキングディレクトリとする

## ディレクトリの書き換え
### ディレクトリエントリの追加
- ファイルの追加
- 既存のファイルに対してリンクを追加
  - `link(2)`    - ハードリンクの生成
  - `symlink(2)` - シンボリックリンクの生成
- ディレクトリの追加
  - `mkdir(2)` - ディレクトリを作成し、親ディレクトリに新しいディレクトリエントリとして追加する
    - `.` / `..`のディレクトリは自動生成する
- 新しいディレクトリエントリの作成とリンクカウントの増加は不可分操作となる

### ディレクトリエントリの削除
- その名前のディレクトリエントリをディレクトリから削除する = リンクを取り除く
  - `unlink(2)`  - ディレクトリ項目を削除する
    - i-nodeを指すリンクを削除する
    - リンク数が0になった時i-nodeとi-nodeが指す実データ領域を解放する
    - プロセスが当該ファイルをオープンしている場合は削除できない
      当該ファイルをオープンしているプロセスの数が0になり、リンクカウントが0になると削除される
  - `rmdir(2)` - 親ディレクトリから空のディレクトリ項目(ディレクトリそのもの)を削除する
    - 空のディレクトリエントリ - `.` / `..`のディレクトリだけを持つディレクトリ

## ファイルの属性の取得
- i-nodeに格納されているファイルの属性を取得し`stat`構造体に格納する
```c
// stat構造体 - stat(2) / lstat(2) / fstat(2)の結果を格納する構造体

#include <sys/stat.h>

struct stat {
  mode_t st_mode;             // ファイルの種類とファイルモードをそれぞれ示すビットフラグ
  ino_t  st_ino;              // i-node番号
  dev_t  st_dev;              // ファイル名・対応するi-nodeを収めたファイルシステムのデバイス番号
  dev_t  st_rdev;             // 特殊ファイルのデバイス番号
  gid_t  st_gid;              // 所有者のグループID
  off_t  st_size;             // ファイルのバイトサイズ
  nlink_t st_link;            // ハードリンクカウント
  struct timespec st_atim;    // 最終アクセス時刻
  struct timespec st_mtim;    // 最終修正時刻
  struct timespec st_ctim;    // i-node状態の最終変更時刻
  blksize_t       st_blksize; // ファイルの入出力において望ましいブロックサイズ
  blkcnt_t        st_blocks;  // 実際に割付済みのディスクブロック数
                              // (512バイト長ブロック単位の個数)
```
- `stat(2)` / `lstat(2)` / `fstat` - ファイルの属性を`stat`構造体で返す

### ファイルモード
- 以下を合わせた12ビットの情報
  - アクセス許可ビット(9ビット)
  - セットユーザーIDビット(1ビット)
  - セットグループIDビット(1ビット)
  - スティッキービット(1ビット)

## ファイルの属性の変更
- ファイルの属性のうちファイルモード・所有者・所有グループは変更可能
  - `chmod(2)` / `fchmod(2)`  - ファイルモードの変更
  - `chown(2)` / `fchown(2)` / `fchownat(2)` / `lchown(2)`- ファイルの所有者・所有グループを変更
- プロセスの実効ユーザーIDがファイルの所有者IDに等しいか
  プロセスにスーパーユーザー特権がある場合に実行可能

## ファイルシステムのマウント
- `mount(2)` / `unmount(2)`

## Unixドメインソケットの操作
- `socket(2)` / `bind(2)`

## ルートディレクトリの変更
- `chroot(2)`
  - そのプロセスとそこから派生する子プロセス群に対するルートディレクトリを仮想敵に変更する
    - 仮想環境の構築
    - ファイルシステムにおいてアクセスできる範囲を制限
  - root権限を持っているユーザーのみ抜けることができる

## 名前の変更
- `rename(2)` / `renameat(2)`
  - 変更後の名前が既存である場合、削除するためにアクセス許可が必要

## ファイルのアクセス時刻の変更
  - `futimens(2)` / `utimensat(2)` - `timespec`構造体を使用して時刻を変更

## デバイスファイルのファイルシステム
- デバイスファイル(キャラクタデバイス / ブロックデバイス)のうち、ブロックデバイスは
  ファイルシステムを作成・マウントすることによってファイルシステム経由で使用する
  - Ex. HDD、SSD

## メモリベースのファイルシステム
- `tmpfs` - メモリ上に作成されるファイルシステム
  - `/tmp`や`/var/run`以下にマウントされる
- 揮発性
- 高速にアクセス可能

## ネットワークファイルシステム
- `nfs` - ネットワークを介して繋がったリモートホスト上のファイルシステム

## 仮装ファイルシステム
- `procfs`
  - システムに存在するプロセスについての情報を格納する仮想的なファイルシステム
  - `/proc`以下にマウントされる
  - `/proc/PID`以下に各プロセスの情報を格納する
- `sysfs`
  - カーネルのプロセスに関するもの以外の雑多な情報を格納する仮想的なファイルシステム
  - Ex. システムに搭載されているデバイスに関する情報、各種ファイルシステムに関する情報
- `cgroupfs`
  - 一つあるいは複数個のプロセスからなるグループにリソース使用量の制限をかける
    `cgroup`を管理する仮想的なファイルシステム
    - `cgroup`で制限をかけられるリソース: Ex. CPU、メモリ
