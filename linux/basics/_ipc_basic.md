# IPC
- 参照: 例解UNIX/Linuxプログラミング教室P257-289
- 参照: 詳解UNIXプログラミング第3版 15. プロセス間通信

## パイプ
- プロセス間通信の仕組みの一つ
  - パイプにおけるデータの流れは入力 -> 出力の一方通行(半
  二重)
  - パイプは共通先祖を持つプロセス間でのみ使える(Ex. 親 <-> 子)
- カーネルがパイプを持ち、プロセスはパイプへのファイルディスクリプタを持つ
  - データはプロセスの書き込み用ファイルディスクリプタ
    -> カーネル内のパイプの読み込み端点(ファイルディスクリプタ)
    -> カーネル内のパイプの書き込み端点(ファイルディスクリプタ)
    -> プロセスの読み込み用ファイルディスクリプタへ向かって流れる

#### 読み書き
- パイプは書き込み端点と読み込み端点を持つ
  - 書き込み端点と読み込み端点はプログラム中においてファイルディスクリプタとして表現される

#### バッファ
- パイプに書き込んだデータはパイプ自身が持つバッファに書き込まれる
  - バッファが上限に達している状態で書き込もうとした場合
    またはバッファが空の状態で読み込もうとした場合、
    読み書きができるようになるまで操作がブロックされる

### パイプの操作
- `pipe(2)` - パイプを作成し、パイプ両端のファイルディスクリプタ(読み込み端点・書き込み端点)を返す
- `popen(3)` - パイプを作成し、`fork`してシェルコマンドを`exec`し、標準入出力ファイルポインタを返す
  - プロセスがパイプを作成
    -> `fork`
    -> 子プロセスで使用しないパイプの端点を閉じてシェルを起動
    -> シェル上でコマンドを`exec`
- `pclose(3)` - `popen(3)`で開いた標準入出力ストリームを閉じ、コマンドの終了を待ち、シェルの終了状態を返す

### パイプによるIPC
Ex. 親プロセス -> 子プロセスへの通信を行う場合

1. 親プロセスがカーネル内にパイプを生成
    - 親プロセス自身のファイルディスクリプタに書き込み端点・読み込み端点がつながったパイプが生成される
2. 親プロセスが`fork`する
    - 親プロセスのファイルディスクリプタをコピーする子プロセスが生成される
3. 親プロセスがパイプからの読み込み端点を閉じる
4. 子プロセスがパイプへの書き込み端点を閉じる
5. 親プロセスから子プロセスへ書き込み、子プロセスが親プロセス肩読み込み可能になる

### 使用上の注意
- 閉じたパイプへの読み書き
  - 書き手がパイプを閉じた後、読み手がパイプを読む -> EOF
  - 読み手がパイプを閉じた後、書き手がパイプに書く -> SIGPIPE
- パイプの閉じ忘れ
  - 書き込み端点の閉じ忘れ -> 読み手にEOFが来ずreadがブロックされる
  - 読み込み端点の閉じ忘れ -> パイプのバッファが溢れてwriteがブロックされる

## FIFO(名前付きパイプ)
- FIFOは関連しないプロセス間でデータ交換できる
  - 名前なしパイプは共通先祖がパイプを作成した時に関係するプロセス間のみでデータ交換できる
- UnixのファイルシステムにおいてFIFOはファイルとして扱われる

### FIFOの操作
- `mkfifo(2)` / `mkfifoat(2)` - FIFOの作成
  - 作成したFIFOはファイルと同じように扱うことができる

### FIFOによるIPC
- シェルの一つのパイプラインから別のパイプラインへデータを渡す

```
Ex.

infile
  |
prog1
  |
tee - prog2
    |
    |- fifo - prog3
```

```
$ mkfifo fifo
$ prog3 < fifo &
$ prog1 < infile | tee fifo | prog2
```

- クライアント - サーバーシステムにおけるデータの待ち合わせ場所(ランデブー場所)とする

```
client1  ←   送信FIFO1
   ↓           ↑
  受信FIFO → server
   ↑           ↓
client2  ←   送信FIFO2
```

## XSI IPC共通
- カーネル内のIPC構造
  - メッセージキュー
  - セマフォ
  - 共有メモリ
- IPC構造はシステム全体におよび参照カウンタがない
- IPC構造にはファイルシステム内の名前がない
  - IPC構造にはファイルディスクリプタが使えない

### 識別子
- IPC識別子 - カーネル内の各IPCオブジェクトの内部名
- IPCキー - IPCオブジェクトの外部名

### アクセス許可構造
```c
include <sys/ipc.h>

struct ipc_perm {
  uid_t uid;   // 所有者の実効ユーザーID
  gid_t gid;   // 所有者の実効グループID
  uid_t cuid;  // 作成者の実効ユーザーID
  gid_t cgid;  // 作成者の実効グループID
  mode_t mode; // アクセスモード
};
```
- `msgctl(2)` / `semctl(2)` / `shmctl(2)`で操作可能

## メッセージキュー
- カーネル内に収められたメッセージの連結リスト
- メッセージキュー識別子で識別される
  - キュー - メッセージキュー
  - キューID - メッセージキュー識別子
  - メッセージ - キューイングされたメッセージ
    - 種別フィールド
    - 非負の長さ
    - 実際のデータバイト
- `msgget(2)` - 新しいキューを作成
- `msgsnd(2)` - キューの末尾に新しいメッセージを追加
- `msgrcv(2)` - メッセージをキューから取り出す
  - FIFOでメッセージを取り出す
  - メッセージの種別フィールドを指定してメッセージを取り出す
- `msgctl(2)` - キューに対する操作

```c
// キューの現在の状態を定義する msqid_ds構造体

struct msqid_ds {
  struct msqid_ds {
  struct ipc_perm msg_perm;   // 所有権と許可
  msgqnum_t       msg_qnum;   // キュー内のメッセージの数
  msglen_t        msg_qbytes; // キュー内の最大バイト数
  pid_t           msg_lspid;  // 最後のmsgsnd(2)のPID
  pid_t           msg_lrpid;  // 最後のmsgrcv(2)のPID
  time_t          msg_stime;  // 最後のmsgsnd(2)の時刻
  time_t          msg_rtime;  // 最後のmsgrcv(2) の時刻
  time_t          msg_ctime;  // 最後に変更が行われた時刻
};
```

```c
// 各メッセージ

struct mymesg {
  long mtype;      // 正のメッセージ種別
  char mtext[512]; // 長さnbytesのメッセージデータ
};
```

## セマフォ
- 複数プロセスがデータオブジェクトにアクセスするために使用するカウンタ
- `semget(2)` - セマフォIDの取得
- `semctl(2)` - セマフォに対する操作
- `semop(2)` - セマフォセットに一連の操作を不可分に適用

```c
// カーネルは各セマフォセットごとにsemid_ds構造体を管理する

struct semid_ds {
  struct ipc_perm sem_perm;  // 所有権と許可
  unsigned long   sem_nsems; // セット内のセマフォの数
  time_t          sem_otime; // 最後のsemop(2)時刻
  time_t          sem_ctime; // 最終変更時刻
};
```

#### 種類
- バイナリセマフォ
- XSIセマフォ

#### 共有リソースの獲得
- リソースを制御するセマフォを検査
  - セマフォの値が正 - プロセスはリソースを使える
    - セマフォの値を1減らす(リソースの1単位を使用中)
  - セマフォの値が0 - セマフォの値が0より大きくなるまでプロセスは休眠する -> 検査に戻る
- セマフォで制御する共有リソースを使い終えたらセマフォの値を1増やす

## 共有メモリ
- 二つ以上のプロセス群がメモリのある領域を共有できる
  - 当該領域への複数プロセス群のアクセスを同期する必要がある
- `shmget(2)` - 共有メモリ識別子の取得
- `shmctl(2)` - 共有メモリに対する操作
- `shmat(2)` - プロセスメモリ空間から共有メモリへの接続
- `shmdt(2)` - プロセスメモリ空間から共有メモリへの切断

```c
// 各共有メモリセグメントに対してカーネルが管理するshmid_ds構造体

struct shmid_ds {
    struct ipc_perm shm_perm;    // 所有権と許可
    size_t          shm_segsz;   // セグメントのバイト長
    time_t          shm_atime;   // 最終接続時刻
    time_t          shm_dtime;   // 最終切断時刻
    time_t          shm_ctime;   // 最終変更時刻
    pid_t           shm_cpid;    // 作成者のPID
    pid_t           shm_lpid;    // 最後にshmat(2)/shmdt(2)したPID
    shmatt_t        shm_nattch;  // 接続個数
};
```
