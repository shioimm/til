# 端末
- 参照: 例解UNIX/Linuxプログラミング教室P375-432

## TL;DR
- 端末(ターミナル) = キーボード + ディスプレイ
  - 「端末」の語源はテレタイプ端末
  - 端末エミュレータ - ソフトウェアで実装された端末
- 端末ではシェルが実行されている <-> シェルのデフォルトの標準入出力は端末
- 端末装置はカーネル内にある端末ドライバによって制御される

```
1. ユーザーがキーボードからコマンドを入力
2. 端末エミュレータがユーザーの入力値をシェルの標準入力に送信
3. シェルが入力値を実行し標準出力から端末エミュレータに送信
4. 端末エミュレータがシェルの出力値をキーボードに出力
```

### プログラマが行う端末処理
- 端末ラインディシプリン(端末回線規約)の設定の取得・変更
- エスケープシーケンスの取得・発行

### 端末入出力
- カノニカルモード入力処理
  - デフォルト
  - 端末入力は行として処理される
  - 端末ドライバは各読み取り要求ごとに多くても一行を返す
  - 入力された文字は改行されるまで一時的なバッファに蓄積する(入出力キュー)
  - カノニカル入力行は最大入力値を持つ
- 非カノニカルモード入力処理
  - 入力文字は行に組み上げられない
  - Ex. viなど

### 入出力キュー
- `echo`を有効にしていると入出力キューは暗黙に連結される
- 入力キューサイズは有限
- 出力キューサイズは有限
- `tcflush(3)` - 入出力キューをフラッシュする

## 端末ラインディシプリン
- カノニカル処理を行うモジュール
- カーネル内でデバイスドライバと汎用`read` / `write`関数群の間を取り持つ

```
ユーザープロセス
----------------
     |
read / write関数群
     |
端末ラインディシプリン
     |
端末デバイスドライバ
     |
----------------
物理装置
```

### 役割
- キーボード入力をディスプレイに書く(`echo(1)`する)
- 特殊制御文字の解釈
- 端末入力のバッファリング処理
- 改行文字の変換
- 上記の設定変更
  - `stty(1)` - 端末モードの変更コマンド
  - `tcgetattr(3)` - `termios`構造体を通じた端末モードの取得
  - `tcsetattr(3)` - `termios`構造体を通じた端末モードの変更

#### `termios`構造体
- 端末ラインディシプリンの設定内容
  - ユーザーが取得・変更できる端末装置情報

```c
struct termios {
  tcflag_t c_iflag;    // 入力モードのフラグ群
  tcflag_t c_oflag;    // 出力モードのフラグ群
  tcflag_t c_cflag;    // 制御モードのフラグ群(ICANON / ~ICANON / ISIG)
  tcflag_t c_lflag;    // ローカルモードのフラグ群
  cc_t     c_cc[NCCS]; // 特殊制御文字の配列
};

struct termios new, old;
tcgetattr(STDIN_FILENO, &old);
new = old:

new.c_lflag &= ~ECHO // エコーフラグを落とす
// |= xxx  xxxをON
// &= ~xxx xxxをOFF

tcsetattr(STDIN_FILENO, TCSANOW, &new);
// 必要な処理が終わった後は設定を戻す tcsetattr(STDIN_FILENO, TCSANOW, &old);
```

### `^C`
- 端末ラインディシプリンは端末から入力された`^C`を`SIGINT`に変換する

## デバイスファイル
- Unixにおいてはあらゆるものがファイルとして抽象化されている
  - デバイスファイル(特殊ファイル) - 端末 = デバイス
  - `isatty(3)` - 端末かファイルか確認する
  - `tty(1)`(`/dev/tty`) - 端末をデバイスファイルとして抽象化したものを取得する
```
$ echo hello > `tty`
hello

$ cat `tty`
hello
     1	hello
```
- デバイスファイルはエスケープシーケンスを解釈する
- デバイスファイルは端末ラインディシプリンを持つ
- デバイスファイルか通常のファイルかによって動作が異なるプログラムが存在する
  - Ex. デバイスファイル - 行バッファリング / 通常のファイル - フルバッファリング

### 擬似端末
- ファイルディスクリプタ(マスター)とファイルディスクリプタ(スレーブ)の間を
  パイプ二本で双方向通信させ、パイプのスレーブ側の一端に端末ラインディシプリンをつけたもの
  - スレーブ側に書いたデータはマスター側から読める
  - マスター側に書いたデータはスレーブ側から読める
  - スレーブ側のファイルディスクリプタは端末に見える(`isatty(3)`は真を返す)

#### 擬似端末を使う手順
1. 擬似端末マスター(`/dev/ptmx`)を開く(`open`)
2. 擬似端末スレーブを`chomod` / `chown`でアクセスできるようにする(`grantpt`)
3. 擬似端末の内部的なロックを解除(`unlockpt`)
4. 擬似端末スレーブのファイル名を取得(`ptsname`)
5. 擬似端末スレーブを開く(`open`)

## エスケープシーケンス
- 端末の画面を制御する特殊な文字列
  - 通常の文字では表現できない機能を表現する
```
echo ^V^[[7m abc ^V^[[0m # 反転したabcが表示される
```
- 文字コードを切り替える特殊な文字列
- エスケープシーケンスは標準化されておらず端末の種類によって変わる
  - `$ printenv TERM` - 端末の種類を表示

### `terminfo`
- 端末機能のDB、および端末機能のDBを処理するライブラリ・コマンド
- `infocmp(1)`        - バイナリ形式で格納されているterminfoをテキスト形式にして出力する
- `tic(1)`            - テキスト形式で格納されているterminfoをバイナリ形式にして出力する
- `tput(3)` `putp(3)` - エスケープシーケンスを端末上に出力する

## `curses`ライブラリ
- `termios`ライブラリや端末ラインディシプリンの操作をより簡単に行うことができる
```c
#include <curses.h>

int main()
{
  char buf[1024];
  initscr();                   // 端末の初期化
  noecho();                    // エコーをOFF
  getnstr(buf, sizeof(buf));   // fgets()のcurses版
  move(x, y);                  // 座標x, yにカーソルを移動
  attron(A_REVERSE);           // 文字属性の反転ON
  printw("input = %s\n", buf); // printfのcurses版
  refresh();                   // 画面の変更を適用する
  getch();                     // getcharのcurses版
  endwin();                    // 端末を元に戻す
}
```
- `initscr`で初期化し、`endwin`で終了する
- `refresh`で画面を更新
