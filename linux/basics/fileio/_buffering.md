# IOバッファリング
- 参照: Linuxプログラミングインターフェース 13章

## カーネルによるバッファリング
- `read(2)` / `write(2)`は
  ユーザー空間のバッファとカーネル空間のバッファに対するコピーの処理を行い、
  カーネルはバッファからディスクへの実際の読み書きを行う
- `read(2)` / `write(2)`はディスク処理と同期しない
- バッファキャッシュ - カーネル空間のバッファ
  - Linuxカーネルは必要に応じてバッファキャッシュにメモリページを割り当てる

### IO性能
- IOの所要時間には以下を含む
  - `read(2)` / `write(2)`システムコールの時間
  - ユーザー空間 - カーネル空間でのデータコピーの時間
  - カーネルバッファ - ディスク間でのデータコピーの時間(ディスクIO)
- IOの所要時間のうちほとんどの時間はディスクIOに費やされる(フラッシュを含む)
- サイズの大きいファイルをIOする際はバッファサイズを大きくすることで
  システムコール回数を削減でき、IO性能を向上させることができる

### カーネルによるバッファフラッシュ
- システムに常駐し、ダーティバッファ(更新されたカーネルバッファ)を
  自動的にディスクへフラッシュするカーネルスレッドが存在する
  - ファイル更新後30秒以上経過したダーティバッファを対象とする
  - 設定時間は`/proc/sys/vm/dirty_expire_centisecs`で変更可能
- 明示的に`fsync(2)` / `fdatasync(2)` / `sync(2)`を呼ぶことで
  出力ファイルのカーネルバッファを強制的にフラッシュできる

#### ファイル同期
- ファイルオープン(`open(2)`)時に`O_SYNC`フラグを付与することで
  バッファを使用せず毎回同期的にファイルを更新することができる

#### SUSv3における同期IOの完了
- 正常にデータを転送したか、エラーと判断されたか
  - データ保全の完了
  - ファイル保全の完了(データ + i-node保全の完了)

## stdioライブラリによるバッファリング
- stdioライブラリによる読み書きにおいては、
  データを大きくバッファリングし、システムコール回数を削減する
  - Ex. `fprintf(3)` / `fscanf(3)` / `fgets(3)` / `fputs(3)` / `fputc(3)` / `fgetc(3)`

### stdioライブラリによるバッファフラッシュ
- 明示的に`fflush(3)`を呼ぶことで強制的にフラッシュできる
- stdioバッファはストリーム(`FILE`)クローズ時に自動的にフラッシュされる
  - `stdin` / `stdout`が端末の場合、`stdin`からの読み取り時に内部で毎回`fflush(stdout)`を実行する
