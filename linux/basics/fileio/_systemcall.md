# システムコール
- 参照: 例解UNIX/Linuxプログラミング教室P107-148 / P271-275
- 参照: 詳解UNIXプログラミング第3版 3. ファイル入出力
- 参照: 詳解UNIXプログラミング第3版 4. ファイルとディレクトリ
- 参照: Linuxプログラミングインターフェース 4章

## TL;DR
- `open(2)` / `close(2)`(開け閉め)
- `read(2)` / `write(2)`(読み書き)
- `lseek(2)`(カレントファイルオフセットを移動させる操作)
- 低水準入出力 - システムコールを直接起動することによって提供される入出力機能
- 低水準入出力はバッファされない

## システムコール
### `open(2)`
- ファイルを開く
  - そのファイルをこれから使うということをカーネルに知らせる
- ファイル(レギュラーファイル)が既に存在し、書き込みが許可されているとき、
  `O_TRUNC`でファイルサイズを0に切り詰めることでファイルを空にすることができる

### `close(2)`
- ファイルを閉じる
  - ファイルに対してプロセスが保持していたリソースが解放される

### `read(2)`
- ファイルにあるバイト列をプロセスのメモリ領域に読み込む
  - バッファ - プロセスのメモリ領域
    - char型の配列としてプログラム上で用意する
  - EOF - ファイルの終わりの位置
    - 読み込む予定のバイト数よりも実際に読み込んだバイト数の方が少ない = EOF
  - 何も書かれていない部分のバイトは値0のバイトとして返す
- Ex. カレントファイルオフセットから10バイト分のバイト列を読む
  -> バッファに10バイト分のデータが入る
  -> カレントファイルオフセットが10バイト分移動する
- 要求バイト数より読み取るバイト数が少ない場合がある
  - 要求バイト数分読み取る前にファイル末尾に達した場合
  - 端末から読み取る場合
  - ネットワークから読み取る場合(ネットワークのバッファリング)
  - パイプから読み取る場合
  - シグナルによる割り込みが発生した場合

### `write(2)`
- バッファの内容をファイルに書き込む
  - 元々のデータは上書きされる
- カレントファイルオフセットから10バイト分のバッファをファイルに書き込む
  -> カレントファイルオフセットが10バイト分移動する(EOF)
- ディスクが満杯であったり、プロセスのファイルサイズの上限を越えるとエラーになる

### `lseek(2)`
- カレントファイルオフセットを明示的に移動させ、新しいファイルオフセットを返す
  - 0バイト移動によって現在のファイルオフセット値を得られる
  - 通常カレントファイルオフセットは`read(2)` `write(2)`によって読み書きしたデータ分移動する
  - `lseek(2)`では読み書きをせずにカレントファイルオフセットを移動させる
- 新しいファイルオフセットはその次の`read` `write`時に使用される
- 元のファイルサイズよりも大きい値を指定した場合、次の`write`時にファイル容量が拡張される(ファイルに隙間を作る)

### `truncate(2)` / `ftruncate(2)`
- 既存のファイルを指定のバイトサイズに切り詰める
  - 指定のバイトサイズが既存のファイルのバイトサイズよりも大きい場合
    ファイルサイズが増え、データが存在しない部分は穴となる(0埋めされる)

## バイトストリーム
- Unixにおけるファイル
- バイトが一列に並んだもの
  - ファイルオフセット - 各バイトの位置を示す整数
  - カレントファイルオフセット - ファイルの読み書き位置となるファイルオフセット

## 穴
- EOFを超えた位置にファイルオフセットを置き、データを書き込んだ場合
  元々あったデータの終端と新しく書き込んだデータの先端の中間に位置するバイト列
  - 中間のバイト列は'0'(NULL文字)で自動的に埋められる
