/*
 * 引用: Head First C
 * 第2章 メモリとポインタ
*/

/*
 * 変数宣言に*がついている場合、その変数はポインタとなる
*/

#include<stdio.h>

int main ()
{
  char *cards = "JQK";
  char a_card = cards[2];
  cards[2] = cards[1];
  cards[1] = cards[0];
  cards[0] = cards[2];
  cards[2] = cards[1];
  cards[1] = a_card;
  puts(cards);

  /*
   * このコードは次のエラーを発生させる
   *   [1]    86359 bus error  c/basics/02_memory/monte
   * -> 文字列リテラルは書き換え不可能
   *
   * このコードの実行順序
   *   1) コンピュータがメモリをロード
   *      定数領域に文字列"JQK"が格納される
   *   2) プログラムがスタック領域にchars変数を作成
   *   3) chars変数が文字列"JQK"のアドレスに設定される
   *      (スタック領域にあるchars変数が定数領域にある文字列"JQK"を参照する)
   *   4) コンピュータが文字列を変更しようとする
   *
   * 文字列を変更する場合は文字列をコピーする
   *   × char *cards = "JQK";
   *   ○ char cards[] = "JQK";
   * ポインタではなく配列として定義する
   * -> 変更可能なスタック領域にリテラルがコピーされる
   *   1) コンピュータがメモリをロード
   *      定数領域に文字列"JQK"が格納される
   *   2) プログラムがスタック領域に新しい配列の領域を確保
   *   3) プログラムが配列を初期化
   *      定数領域から文字列"JQK"をコピー
   *
   * ポインタにリテラルを設定したい場合は定数宣言を行う
   *   const char *s = "文字列";
   *   -> 変更しようとするとコンパイルエラーが発生
  */

  return 0;
}

/*
 * メモリ内の構造
 * - スタック領域   関数内で宣言した変数を保存する領域
 * - ヒープ領域     動的メモリ領域
 * - グローバル領域 関数外で宣言した変数を保存する領域
 * - 定数領域       定数を保存する領域(読み取り専用)
 * - コード領域     コードを保存する領域(読み取り専用)
*/

/*
 * char cards[]
 *   変数宣言の場合
 *     charの配列として定義される
 *     配列サイズが指定されていないため、その場で値の代入が必要
 *     char cards[] = "JQK";
 *
 *   関数引数の場合
 *     ポインタとして定義される
 *     void stack_deck(char cards[])
 *     -> void stack_deck(char *cards) と同じ
*/
