# シグナルドリブンIO
- 参照: Linuxプログラミングインターフェース 63章

## TL;DR
- 指定したファイルディスクリプタがIO可能になったことをシグナルにより通知する
- プロセスはシグナルを受信するまで他の処理を実行可能

## 手順
1. シグナルドリブンIOが送信するシグナルを処理するハンドラを設定(デフォルトでは`SIGIO`)
2. ファイルディスクリプタがIO可能になった時点でシグナルを送信する先のプロセスを設定する
    - `fcntl(fd, F_SETOWN, pid)`
    - `pid`には自プロセスを指定するのが一般的
3. オープンファイルステータスフラグへ`O_NONBLOCK`をセットし、ノンブロッキングIOとする
4. オープンファイルステータスフラグへ`O_ASYNC`をセットし、シグナルドリブンIOを有効にする
5. 自プロセスは他の処理を実行する
    - IO可能になるとカーネルがシグナルを送信し、`1`で設定したシグナルハンドラが実行される
6. シグナルドリブンIOはエッジトリガ通知
    - ノンブロッキングモードの場合`EAGAIN` / `EWOULDBLOCK`が発生するまでIOを繰り返すべき

## シグナル送信タイミング
#### 端末・疑似端末
- 入力時にシグナルが生成される
- EOF条件が発生した端末は読み取り可能を意図するシグナルが生成される(端末のみ)
  - 書き込み可能を意図するシグナルは生成されない
  - 端末の切断を意図するシグナルは生成されない

#### パイプ・FIFO
- 読み取り口の場合:
  - データがパイプへ書き込まれた(まだ読み取っていないデータがパイプ内に残っている)
  - パイプの書き込み口がクローズされた
- 書き込み口の場合:
  - 読み取りによるパイプの空き領域が増加し、ブロックせずに`PIPE_BUF`文のデータを書き込める状態になった
  - パイプの読み取り口がクローズされた

#### ソケット
- データグラムソケットの場合:
  - ソケットにデータグラムが届いた(まだ読み取っていないデータグラムがソケット内に残っている)
  - ソケットに非同期エラーが届いた
- ストリームソケットの場合:
  - リスニングソケットが接続要求を受信した
  - TCPの`connect(2)`要求が完了した(TCPのアクティブエンドが`ESTABLISHED`状態になった)
  - ソケットにデータが届いた(まだ読み取っていないデータがソケット内に残っている)
  - ピアソケットの送信チャネルが`shutdown(2)`された
  - ピアソケットの送信チャネル・受信チャネル共に`close(2)`された
  - ソケットが書き込み可能になった(ソケットの送信バッファに空き領域が生まれた)
  - ソケットに非同期エラーが発生した
