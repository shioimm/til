# コンテナ技術
- 参照: [コンテナ化とは何か](https://developer.ibm.com/jp/videos/new-builders-containerization/)
- 参照: [Linux コンテナの概要](https://www.redhat.com/ja/topics/containers)
- 参照: [コンテナーとは？ Kubernetesとは？ 導入や運用、ユースケースを解説](https://codezine.jp/article/detail/11336)
- 引用: [What is Kubernetes?](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)
- 翻訳参考: [DeepL](https://www.deepl.com/translator)

## 概要
- アプリケーションとランタイム環境全体(実行に必要なすべてのファイル)をパッケージ化し、分離させる技術
- コンテナは独自のファイルシステム、CPU、メモリ、プロセススペースなどを持つ
- 基盤となるインフラストラクチャから切り離されているため、クラウドやOSディストリビューション間での移植性がある
- ホストOS上に論理的な区画(コンテナ)を作り、個別のサーバーのように使うことができる
- ホストOSのリソースを論理的に分離し複数のコンテナで共有する

## 特徴
- VMイメージと比べ、コンテナイメージの方が作成が簡単で効率的
- イメージの不変性により、頻繁にコンテナイメージを構築することができ、
  迅速かつ簡単にロールバックしながらデプロイすることができる
- アプリケーションとインフラを分離することができる
  - デプロイ時ではなくビルド時・リリース時にアプリケーションのコンテナイメージを作成する
- 可観測性
- 環境の一貫性
- クラウドとOSディストリビューションの移植性
- リソース分割
- リソースの効率利用
- アプリケーションの実行に必要なモジュールをコンテナとしてまとめられる
  -> 複数のコンテナを組み合わせて一つのアプリケーションを構成するアーキテクチャとの親和性が高い
  -> マイクロサービスアーキテクチャ

## コンテナ作成の3段階プロセス
1. マニフェスト(ex. Dockerfile)
    - コンテナ自体の詳細の記述
2. イメージ本体(ex. Dockerイメージ)
    - アプリケーションの実行に必要なファイル群が格納されたディレクトリ
    - コンテナ本体のひな形
3. コンテナ本体
    - すべてのランタイム、ライブラリー、バイナリーが含まれる

## コンテナアプリケーション開発プロセス
1. コンテナアプリケーションのビルド(Build)
    - アプリケーションの実行に必要なプログラム本体／ライブラリ／ミドルウェア、
      OSやネットワークの設定をひとつにまとめてイメージを作成
    - あるいはパブリックレジストリから必要なイメージを取得
2. コンテナイメージの共有(Ship)
    - 開発に必要なイメージをレジストリで共有
3. コンテナアプリケーションの実行(Run)
    - コンテナの起動／停止／破棄
    - 複数のコンテナを起動することも可能
