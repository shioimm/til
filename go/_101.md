# 基本

```
$ brew install go
$ go version

# 実行 (実行ファイルは作成されない)
$ go run foo.go

# コンパイル -> 実行
$ go build foo.go
$ ./foo
```

```
# モジュールの作成 (go.modが作成される)
$ go mod init github.com/shioimm/foo

# パッケージのインストール (go.modにrequireが追加される)
$ go get github.com/shioimm/bar

$ cat go.mod
  1 module github.com/shioimm/foo
  2
  3 go 1.23.2
  4
  5 require github.com/shioimm/bar v0.0.1
```

```go
// main.go

// パッケージの宣言 (mainパッケージ = エントリーポイント)
package main

// パッケージのインポート
import (
    "fmt"
    "github.com/shioimm/foo"
)

func main() {
    // 変数宣言
    var foo string
    foo = "foo"

    // 以下同じ
    //   var foo string = "foo"
    //   var foo        = "foo"
    //   foo           := "foo"

    fmt.Println(foo)

    // 初期値を与えない場合はゼロ値がセットされる
    var result, max int // = 0
    var resultP    *int // = nil

    result = 0
    max, resultP = fn(5, &result)

    fmt.Println(max)
    fmt.Println(resultP)

    fmt.Println(float32(result)) // 型変換
    fmt.Printfmt("float32(result) type is %T", float32(result)) // => float32(result) type is float32

    foo.Foo()
}

// 関数宣言
func fn(max int, resultP *int) (int, *int) {
    // for文
    for i := 0; i < max; i++ {
        // if文
        if i % 2 == 0 {
            *resultP += i
        } else if i % 2 != 0 {
            *resultP -= i
        } else {
            // something is wrong
        }
    }

    return max, resultP
}

// 以下同じ
// func fn(max int, result *int) (max int, resultP *int) { // 返り値名 (変数宣言)
//     i := 0
//
//     for i < max {
//         switch n := i; n % 2 == 0 {
//         case true:
//             *resultP += n
//         case false:
//             *resultP -= n
//         default:
//             // something is wrong
//         }
//
//         i++
//     }
//
//     return
// }
```

- bool
- string
- int, int8, int16, int32, int64
- uint, uint8 (byte), uint16, uint32 (rune), uint64, uintptr
- float32, float64
- complex64, complex128

```go
package main

import "fmt"

// 構造体
type Foo struct {
    X int
    Y int
}

func main() {
    fmt.Println(Foo{1, 2}) // => {1 2}

    foo  := Foo{1, 2}
    foo.Y = 3
    fmt.Println(foo.X, foo.Y) // => 1 3

    fooP := &Foo{}
    fooP.X = 1
    fmt.Println(fooP.X, fooP.Y) // => 1 0
}
```

```go
package main

import "fmt"

func main() {
    // 配列
    arr := [5]int{1, 2, 3, 4, 5}
    fmt.Println(arr) // => [1 2 3 4 5]

    // スライス (配列への参照)
    var subArr []int
    subArr = arr[0:4] // [lowIndex:highIndex] lowIndexは含まれるがhighIndex (上限値は要素数) は含まれない

    // 以下同じ
    //   subArr []int := {} // = nil
    //   subArr = [:4]

    fmt.Println(subArr) // => [1 2 3]

    subArr[2] = 99
    fmt.Println(arr) // => [1 2 99 4 5]

    // len = 要素数
    // cap = スライスの最初の要素から数えて元となる配列の要素数
    fmt.Printf("len=%d cap=%d %v\n", len(arr),    cap(arr),    arr)    // => len=3 cap=5 [1 2 99]
    fmt.Printf("len=%d cap=%d %v\n", len(subArr), cap(subArr), subArr) // => len=5 cap=5 [1 2 99 4 5]

    // make関数で動的にスライスを作る
    foo := make([]int, 3, 5)
    fmt.Printf("len=%d cap=%d %v\n", len(foo), cap(foo), foo) // => len=3 cap=5 [0 0 0]

    // スライスに要素を足す
    foo = append(foo, 1); fmt.Println(foo) // => [0 0 0 1]
    foo = append(foo, 2); fmt.Println(foo) // => [0 0 0 1 2]
    foo = append(foo, 3); fmt.Println(foo) // => [0 0 0 1 2 3] より大きいサイズの配列を割り当て直す

    // range (インデックス、インデックスの位置にある要素のコピーを返す)
    var nums = []int{1, 2, 3}

    for i, v := range(nums) {
        fmt.Printf("%d=%d\n", i, v)
    }

    // 以下同じ
    //   for i := 0; i < 3; i++ {
    //      fmt.Printf("%d=%d\n", i, nums[i])
    //   }
}
```

```go
package main

import "fmt"

type Bar struct {
  X, Y int
}

func main() {
    // マップ
    // map[キーの型名] 値の型名

    var foo map[string]int         // マップ型([string:int])の変数fooを宣言
    foo = make(map[string] int, 2) // マップのメモリ割り当て (var foo = make(map[string] int, 2))
    foo["X"] = 1
    foo["Y"] = 2

    fmt.Println(foo) // => map[X:1 Y:2]

    x, ok := foo["X"]
    fmt.Println(x, ok) // => 1 true

    delete(foo, "Y")
    x, ok := foo["Y"]
    fmt.Println(y, ok) // => 0 false

    var bar = map[int]Bar{
        1: Bar{
            100, 200,
        },
        2: Bar{
            300, 400,
        },
    }

    fmt.Println(bar) // => map[1:{100 200} 2:{300 400}]
}
```

```go
package main

import "fmt"

func main() {
    add := func(x, y int) int { return x + y }

    fmt.Println(add(1, 2)) // => 3
    fmt.Println(add)       // => 0x48ec80
}
```
