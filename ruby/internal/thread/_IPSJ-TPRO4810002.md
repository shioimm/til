# Ruby用仮想マシンYARVにおける並列実行スレッドの実装
- Rubyスレッドとネイティブスレッドを1:1のマッピングにする
- ネイティブスレッドを並行並列に実行するための排他制御のためにGLを導入する
- 各ネイティブスレッドは自身のスレッドローカルストレージにそれぞれのスレッド管理データへのポインタを持つ

```c
struct thread_data {
  thread_id_t thread_id;            // pthread_tなど
  int status;                       // Rubyスレッドの実行状況
  struct thread_data *wait_nexr_id; // スレッドの合流時に待ちスレッドを登録
  lock_t lock;                      // ブロック解除関数で利用
  void (*unblock_func)();           // ブロック解除関数で利用
  cond_t sleep_cond;                // スレッドの一時停止時に利用
  // その他VM実行コンテキスト
};
```

### 制御
#### スレッドの生成 (`Thread.new`)
- `pthread_create`

#### スレッドの終了 (`Thread#exit`)
- ネイティブスレッド自体も終了 (オブジェクトは残る)

#### スレッドの合流 (`Thread#join`)
- スレッド管理データに待ちスレッドとして登録

#### 排他制御 (`Mutex#synchronize`)
- `pthread_mutex_lock` / `pthread_mutex_unlock`

### Rubyスレッドへの割り込み
- Rubyスレッドへの割り込みはVM内にポーリングポイントを設け、
  割り込みを行う際に対象のスレッドに対して割り込み要因を記述してから割り込みフラグをセットする
- 対象のスレッドはポーリングポイントで割り込みに気づいて割り込まれる

#### 割り込み対象のスレッドが一定時間以上ブロックしている場合は?
- スレッド管理データにブロック状態をキャンセルするブロック解除関数のポインタを設定しておく
- ブロックから無事に抜けた場合はブロック解除関数の登録を削除
- ブロックに割り込みたい場合はブロック解除関数を実行 -> ブロックを抜けたら割り込みフラグをチェック。
  - 例外発生も同様に取り扱う

### シグナル
- Rubyスレッドに割り当てるネイティブスレッドとは別に管理スレッド (タイマスレッド?) を用意
- 管理スレッド以外のネイティブスレッドにシグナルマスクの設定することで管理スレッドにのみシグナルを配送する
- シグナルを受信した管理スレッドはメインスレッドへ割り込みをかけてシグナルに対応

## GL
- スレッドセーフであることが明示的に示されていないネイティブスレッドの起動時にGLを獲得し、
  ネイティブスレッドの終了とともに解放する
  - ネイティブスレッドがスレッドセーフであることを明示するには`rb_define_method_ts`関数を利用する
    - `rb_define_method_ts`で定義されたメソッドは呼び出し時にGL獲得操作を行わない
- ネイティブスレッド実行中にRubyスクリプトで定義されたメソッドを呼び出す場合はGLを解放した上で実行し、
  メソッドの終了後に再びGLを獲得する
- Rubyスレッドがひとつしかない場合はGLによる排他制御は行わない
- GL獲得操作時、GLが別のネイティブスレッドによって獲得済みの場合はスピンロックによってGL獲得試行を行う
- GL獲得操作の競合を頻発させるRubyスレッド群はCPUアフィニティを設定し、利用できるCPUを制限

## 参照
- [Ruby用仮想マシンYARVにおける並列実行スレッドの実装](https://ipsj.ixsq.nii.ac.jp/ej/index.php?action=pages_view_main&active_action=repository_action_common_download&item_id=16500&item_no=1&attribute_id=1&file_no=1&page_id=13&block_id=8)
