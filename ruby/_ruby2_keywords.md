# キーワード引数の分離 (3.0~)
#### 変更前
```ruby
# 呼び出し元: ハッシュオブジェクト
# 呼び出し先: キーワード引数
# => キーワード引数からハッシュオブジェクトへの自動変換が行われる

def foo(arg); arg; end

foo(arg: 1) # => { arg: 1 }

# 呼び出し元: キーワード引数
# 呼び出し先: ハッシュオブジェクト
# => ハッシュオブジェクトからキーワード引数への自動変換が行われる

def foo(**arg); arg; end

foo({ arg: 1 }) # => 1
```

#### 変更後
```ruby
# 呼び出し元: ハッシュオブジェクト
# 呼び出し先: キーワード引数
# => キーワード引数からハッシュオブジェクトへの自動変換が行われる (変更なし)

def foo(arg) = arg

foo(arg: 1) # => { arg: 1 }

# 呼び出し元: キーワード引数
# 呼び出し先: ハッシュオブジェクト
# => キーワード引数を渡すべきところにハッシュオブジェクトが渡ったためArgumentErrorが発生

def foo(**arg) = arg

foo({ arg: 1 }) # => :in `foo': wrong number of arguments (given 1, expected 0) (ArgumentError)

# 呼び出し側が渡す引数のハッシュオブジェクトを明示的にキーワード引数へ展開することで回避できる
foo(**{ arg: 1 }) # => 1
```

```
def foo(*args, **kwargs)
  [args, kwargs]
end

foo(bar: 1)       # => [[], {:bar=>1}]
foo({ bar: 1 })   # => [[{:bar=>1}], {}]
foo({ bar: 1 })   # => [[{:bar=>1}], {}]
foo(**{ bar: 1 }) # => [[], {:bar=>1}]
```

### メソッドの委譲
#### 変更前
```ruby
# 呼び出し元(委譲先): 配列、キーワード引数
# 呼び出し元(委譲元): 配列
# 呼び出し先: ハッシュオブジェクト
# => キーワード引数はハッシュに変換された後、配列として展開されるべきだったが実際にはハッシュとして展開される

def foo(*args); bar(*args); end
def bar(*args, **kw); "#{args}, #{kw}"; end

foo(kw: 123) # => "[], {:k=>123}"
```

#### 変更後
```ruby
# 呼び出し元(委譲先): 配列、キーワード引数
# 呼び出し元(委譲元): 配列
# 呼び出し先: ハッシュオブジェクト
# => キーワード引数はハッシュに変換された後、配列として展開される

def foo(*args) = bar(*args)

def bar(*args, **kw) = "#{args}, #{kw}"

foo(kw: 123) # => "[{:kw=>123}], {}"

# キーワード引数をハッシュとして展開したい場合は明示的にruby2_keywordsを呼ぶ
ruby2_keywords :foo
foo(kw: 123) # => "[], {:kw=>123}"

# あるいは...で引数を丸ごと委譲する
def foo(...) = bar(...)
def bar(*args, **kw) = "#{args}, #{kw}"

foo(kw: 123) # => "[], {:kw=>123}"

# ...で先頭引数とハッシュを分離したい場合は明示的に先頭引数を示す
def foo(arg, ...) = bar(arg, ...)
def bar(*args, **kw) = "#{args}, #{kw}"

foo(k: 123)        # => "[{:k=>123}], {}"
foo({ k: 123 })    # => "[{:k=>123}], {}"
foo(1, { k: 123 }) # => "[1, {:k=>123}], {}"
foo(1, k: 123)     # => "[1], {:k=>123}"
```
