# サーバーアーキテクチャ
- 引用: Working with TCP Sockets P135-

## シリアルモデル
### ライフサイクル
1. クライアントからの接続
2. サーバープロセスが接続を受け入れ、クライアントにレスポンスを返す
3. `1`に戻る

### 特徴
- シンプルさ
- 複数リクエストに対応することができない

## マルチプロセスモデル
### ライフサイクル
1. クライアントからの接続
2. メインプロセスが接続を受け入れる
3. メインプロセスが新しいプロセスを`fork`する
4. メインプロセスは`1`に戻る
   子プロセスは並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- シンプルさ
- 複数リクエストに対応することができる
- 子プロセスの処理同士が分離されている
- 親プロセスから全リソースをコピーするためオーバーヘッドが大きい
- 新たに生成される子プロセスの数に上限が存在しない

### 事例
- [rtomayko/shotgun](https://github.com/rtomayko/shotgun)

## prefork型マルチプロセスモデル
### ライフサイクル
1. メインプロセスがリスニングソケットを作成
   新しいプロセスを必要数分`fork`する
2. クライアントからの接続
3. 各子プロセスがディスクリプタの共有されているリスニングソケット上で接続を受け入れる
4. メインプロセスは子プロセスを監視するループに入る
   各子プロセスはそれぞれ並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- 複数リクエストに対応することができる
  - 接続中に`fork`する必要がない
- 子プロセスの処理同士が分離されている
- 親プロセスから全リソースを事前にコピーするためオーバーヘッドが更に大きい
- 新たに生成される子プロセスの数に上限が設けられている

### 事例
- [Unicorn](https://yhbt.net/unicorn/)

## マルチスレッドモデル
### ライフサイクル
1. クライアントからの接続
2. メインスレッドが接続を受け入れる
3. メインスレッドが新しいスレッドを`Thread.new`する
4. メインスレッドは`1`に戻る
   子スレッドは並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- シンプルさ
- 複数リクエストに対応することができる
- メインスレッドとリソースを共有するためオーバーヘッドが小さい
- ロックや同期の問題が発生する可能性がある
  - 各接続を独立した単の一インスタンスに切り出すことによって回避
- 新たに生成されるスレッドの数に上限が存在しない

### 事例
- [ruby/webrick](https://github.com/ruby/webrick)
- [mongrel/mongrel](https://github.com/mongrel/mongrel)

## スレッドプール型マルチスレッドモデル
### ライフサイクル
1. メインスレッドがリスニングソケットを作成
   新しいスレッドを必要数分`Thread.new`する
2. クライアントからの接続
3. 各子スレッドがディスクリプタの共有されているリスニングソケット上で接続を受け入れる
3. メインスレッドはスリープ状態に入る
   各子スレッドはそれぞれ並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- 複数リクエストに対応することができる
  - 接続中に`Thread.new`する必要がない
- メインスレッドとリソースを共有するためオーバーヘッドが小さい
- ロックや同期の問題が発生する可能性がある
  - 各接続を独立した単の一インスタンスに切り出すことによって回避
- 新たに生成される子スレッドの数に上限が設けられている

### 事例
- [puma/puma](https://github.com/puma/puma)
