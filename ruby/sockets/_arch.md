# サーバーアーキテクチャ
- 引用: Working with TCP Sockets P135-

## シリアルモデル
### ライフサイクル
1. クライアントからの接続
2. サーバープロセスが接続を受け入れ、クライアントにレスポンスを返す
3. `1`に戻る

### 特徴
- シンプルさ
- 複数リクエストに対応することができない

## マルチプロセスモデル
### ライフサイクル
1. クライアントからの接続
2. メインプロセスが接続を受け入れる
3. メインプロセスが新しいプロセスを`fork`する
4. メインプロセスは`1`に戻る
   子プロセスは並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- シンプルさ
- 複数リクエストに対応することができる
- 子プロセスの処理同士が分離されている
- 親プロセスから全リソースをコピーするためオーバーヘッドが大きい
- 新たに生成される子プロセスの数に上限が存在しない

### 事例
- [rtomayko/shotgun](https://github.com/rtomayko/shotgun)

## prefork型マルチプロセスモデル
### ライフサイクル
1. メインプロセスがリスニングソケットを作成
   新しいプロセスを必要数分`fork`する
2. クライアントからの接続
3. 各子プロセスがディスクリプタの共有されているリスニングソケット上で接続を受け入れる
4. メインプロセスは子プロセスを監視するループに入る
   各子プロセスはそれぞれ並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- 複数リクエストに対応することができる
  - 接続中に`fork`する必要がない
- 子プロセスの処理同士が分離されている
- 親プロセスから全リソースを事前にコピーするためオーバーヘッドが更に大きい
- 新たに生成される子プロセスの数に上限が設けられている

### 事例
- [Unicorn](https://yhbt.net/unicorn/)

## マルチスレッドモデル
### ライフサイクル
1. クライアントからの接続
2. メインスレッドが接続を受け入れる
3. メインスレッドが新しいスレッドを`Thread.new`する
4. メインスレッドは`1`に戻る
   子スレッドは並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- シンプルさ
- 複数リクエストに対応することができる
- メインスレッドとリソースを共有するためオーバーヘッドが小さい
- ロックや同期の問題が発生する可能性がある
  - 各接続を独立した単の一インスタンスに切り出すことによって回避
- 新たに生成されるスレッドの数に上限が存在しない

### 事例
- [ruby/webrick](https://github.com/ruby/webrick)
- [mongrel/mongrel](https://github.com/mongrel/mongrel)

## スレッドプール型マルチスレッドモデル
### ライフサイクル
1. メインスレッドがリスニングソケットを作成
   新しいスレッドを必要数分`Thread.new`する
2. クライアントからの接続
3. 各子スレッドがディスクリプタの共有されているリスニングソケット上で接続を受け入れる
3. メインスレッドはスリープ状態に入る
   各子スレッドはそれぞれ並行して接続を処理し、クライアントにレスポンスを返す

### 特徴
- 複数リクエストに対応することができる
  - 接続中に`Thread.new`する必要がない
- メインスレッドとリソースを共有するためオーバーヘッドが小さい
- ロックや同期の問題が発生する可能性がある
  - 各接続を独立した単の一インスタンスに切り出すことによって回避
- 新たに生成される子スレッドの数に上限が設けられている

### 事例
- [puma/puma](https://github.com/puma/puma)

## イベント駆動(Reactor)モデル
### ライフサイクル
1. サーバーがリスニングソケットを作成
   サーバーが監視対象とする接続ソケット用のリストを作成
2. サーバーがリスニングソケットを監視
3. クライアントからの接続
4. サーバーが接続を受け入れ、接続ソケットをリストに追加
5. リストに追加された接続ソケットが読み取り可能であることがサーバーへ通知される
6. サーバーは対象の接続ソケットからデータをチャンクとして読み取り、
   関連するコールバックをディスパッチ
    - 接続ソケットがまだ読み込まれていることがサーバーへ通知された場合、
      サーバーは別のチャンクを読み込み、再度コールバックをディスパッチ
    - 接続ソケットが書き込み可能な状態になったことがサーバに通知された場合、
      接続ソケットはレスポンスを返す
    - 上記操作の間、クライアントから新しい接続があった場合、
      `4`以降が実行される
7. `2`に戻る

### 特徴
- 大量のリクエストに対して同時に対応することができる
- シングルプロセス・シングルスレッドで処理を行うため、共有メモリ、同期、暴走プロセスなどの問題が発生しない
- 低速なクライアントに対して対応を行う場合全てのストリームに対する処理が止まるため、
  ノンブロッキングIOで処理を行う
- 実装の自由度が低い

### 事例
- [eventmachine/eventmachine](https://github.com/eventmachine/eventmachine)

## ハイブリッドモデル
### 事例
- [nginx](https://nginx.org/)
  - prefork型マルチプロセスモデルを使用し、
    `fork`されたプロセスの内部でイベント駆動モデルを使用する
- [puma/puma](https://github.com/puma/puma)
  - スレッドプール型マルチスレッドモデルを使用し、
    Reactorの機構を利用してリクエストをプールへキューアップする
- [eventmachine/eventmachine](https://github.com/eventmachine/eventmachine)
  - イベント駆動モデルを使用していると同時にスレッドプールも用意しており、
    Reactorの速度を低下させるようなIOブロッキング操作を延期する
