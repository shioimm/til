# 引用: Working with TCP Sockets (Jesse Storimer)
# Socket SSL

require 'socket'
require 'openssl'

def main
  server = TCPServer.new(4481)

  # SSLコンテキストオブジェクトを生成
  ctx = OpenSSL::SSL::SSLContext.new

  # cert = 自分自身を証明する証明書
  # key = 証明書の公開鍵に対応する秘密鍵
  ctx.cert, stx.key = create_self_signed_cert(
    1024,
    [['CN', 'localhost']],
    "Generated by Ruby/OpenSSL"
  )

  # 検証モードをVERIFY_PEERに設定
  ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER

  ssl_server = OpenSSL::SSL::SSLServer.new(server, ctx)
  connection = ssl_server.accept

  connection.write('Bah now') # 接続ソケットにデータを書き込む
  connection.close
end

# 自己署名付きのSSL証明書を生成
def create_self_signed_cert(bits, cn, comment)
  # RSA 暗号鍵オブジェクトを生成
  rsa = OpenSSL::PKey::RSA.new(bits) { |p, n|
    case p
    when 0; $stderr.putc "."
    when 1; $stderr.putc "+"
    when 2; $stderr.putc "*"
    when 3; $stderr.putc "\n"
    else;   $stderr.putc "*"
    end
  }

  # X509証明書オブジェクトを生成
  cert = OpenSSL::X509::Certificate.new

  cert.version = 2
  cert.serial  = 1

  # X.500の識別名(DN, Distinguished Name)オブジェクトを生成
  name = OpenSSL::X509::Name.new(cn)

  cert.subject    = name
  cert.issuer     = name
  cert.not_before = Time.now
  cert.not_after  = Time.now + (365 * 24 * 60 * 60)
  cert.public_key = rsa.public_key

  # X.509 v3 証明書の拡張領域を行うオブジェクトを生成
  ef = OpenSSL::X509::ExtensionFactory.new(nil, cert)

  ef.issuer_certificate = cert
  cert.extensions = [
    ef.create_extension("basicConstraints", "CA:FALSE"),
    ef.create_extension("keyUsage", "keyEncipherment"),
    ef.create_extension("subjectKeyIdentifier", "hash" ),
    ef.create_extension ("extendedKeyUsage", "serverAuth"),
    ef.create_extension ("nsComment", comment ),
  ]
  aki = ef.create_extension("authorityKeyIdentifier", "keyid:always,issuer:always")
  cert.add_extension(aki)
  cert.sign (rsa, OpenSSL::Digest::SHA1.new)
  return [ cert , rsa ]
end

main
