# なるほどUNIXプロセス まとめ
- Jesse Storimer 著
- 島田浩二, 角谷信太郎 翻訳

## Chapter2
- Unixシステム
  - カーネル
    - ハードウェアを制御する
    - ユーザーはシステムコールによってカーネルの操作を行う
  - ユーザーランド
    - ユーザーの書いたプログラムの実行場所
  - システムコール
    - カーネルとユーザーランドの取次を行う
```
コマンドのセクションカテゴリ
- セクション1 誰もが実行できるユーザーコマンド
- セクション2 システムコール(カーネルが提供する関数)
- セクション3 サブルーチン(Cライブラリ関数)
- セクション4 デバイス(/dev ディレクトリのスペシャルファイル)
```

- あらゆるコードはプロセス上で実行される
  - コマンドラインからrubyを起動すると、コードを実行するためのプロセスが生まれる
  - コードを実行し終わったら、プロセスは終了する

## Chapter3
- プロセスは識別子(プロセスID = pid)を持っている

```
現在実行されているプロセスのpid

Process.#pid <=> getpid(2)
```

## Chapter4
- すべてのプロセスには親がいる
  - 親プロセスのプロセスIDはppid

```
現在実行されているプロセスのppid

Process.#ppid <=> getppid(2)
```

## Chapter5
### ファイルディスクリプタ
- Unixの世界では「全てがファイル」
  - デバイス、ソケット、パイプetc
    - 総称的な意味でのファイル -> リソース
    - 一般的な意味でのファイル -> ファイル
- 実行中のプロセスでリソースを開くと、ファイルディスクリプタ番号が割り当てられる
  - ファイルディスクリプタは関連しないプロセス間では共有できない
  - プロセスが終了するとファイルディスクリプタも終了する
- Rubyでは開いたリソースはIOオブジェクト
  - IOオブジェクトはファイルディスクリプタ番号を知っている

```
開いているリソースのファイルディスクリプタ番号

IO#fileno
```

- ファイルディスクリプタ番号は、開かれているリソースに対して、未使用の整数が昇順に割り当てられる
- リソースが閉じられると、閉じたリソースに割り当てられていたファイルディスクリプタ番号が再利用できるようになる
  - カーネルは開かれているリソースにだけファイルディスクリプタ番号を割り当てて管理する

#### 標準ストリームのファイルディスクリプタ
- 標準入力(STDIN) => 0
- 標準出力(STDOUT) => 1
- 標準エラー出力(ETDERR) => 2

## Chapter6
- 1プロセスが持てるファイルディスクリプタ数には制限がある
  - ソフトリミット => 変更可能な制限数
    - 制限を超えるとErrno::EMFILE例外が創出される
  - ハードリミット => 変更権限を持ったユーザーのみ変更可能な制限数

```
Process.getlimit <=> getlimit(2)
Process.setlimit <=> setlimit(2)
```

#### その他のリソースの制限
- プロセスのユーザーが持てる最大プロセス数
- プロセスが作成できるファイルサイズの最大値
- プロセススタックの最大サイズ

## Chapter7
- プロセスは環境変数を持っている
  - 環境変数 = プロセスで使えるデータ
    - key : value
  - 環境変数は親プロセスによって設定され、子プロセスに引き継がれる
  - 環境変数はプロセスごとに存在し、グローバルにアクセスできる

```
ENV => 環境変数を表す定数で、ハッシュと同じようにアクセスできるAPIを持つがハッシュではない

ENV['EDITOR'] <=> $EDITOR
```

## Chapter8
- プロセスには引数がある

```
Object::ARGV => コマンドラインからプロセスに渡された引数を表す配列
```

## Chapter9
- プロセスには名前がある

```
Kernel$$PROGRAM_NAME => 現在実行中の Ruby スクリプトの名前を表す文字列
グローバル変数なので変更可能
```

## Chapter10
- プロセスには終了コードがある

```
Kernel#exit => 明示的な終了
デフォルトの終了コードが0(正常終了)
終了前にKernel#at_exitで定義されたブロックを実行する
```
```
Kernel#exit! => 明示的な終了
デフォルトの終了コードが1(異常終了)
終了前にKernel#at_exitで定義されたブロックを実行しない
```
```
Kernel#abort! => 明示的な終了
デフォルトの終了コードが1(異常終了)
終了前にエラーメッセージをSTDERRに出力する
終了前にKernel#at_exitで定義されたブロックを実行する
```
```
Kernel#raise => 呼び出し元に向かって例外を送出する
例外が捕捉されなかった場合プロセスが終了する(終了コードは1)
終了前にエラーメッセージとバックトレースをSTDERRに出力する
終了前にKernel#at_exitで定義されたブロックを実行する
```

## Chapter11
- fork => 実行中のプロセス(親)から新しいプロセス(子)を生成する
  - 子プロセスは親プロセスで使われているメモリのコピーを持つ
    - コピーしたメモリは親の持つメモリとは独立して自由に変更できる
  - 子プロセスは親プロセスとファイルディスクリプタ番号を共有する
  - 子プロセスは固有のpidを持つ
- forkは1回の呼び出しで、親プロセスと子プロセスにそれぞれ戻り値を返す
  - 親プロセスには子プロセスのpidを返す
  - 子プロセスにはnilを返す

```
Kernel.#fork <=> fork(2)

fork do
  # 子プロセスで実行する処理
end

# 親プロセスで実行する処理
```

## Chapter12
- 親プロセスが子プロセスより先に死んだ場合、子プロセスは孤児化する(そのまま生き続ける)
  - デーモンプロセス => 意図的に孤児化されたプロセス
  - 端末セッションを持たないプロセスとの通信方法 => Unixシグナルを使用

## Chapter13
- コポーオンライト(CoW) => 親プロセスもしくは子プロセスからメモリへの変更が必要になるまで、子プロセスへのメモリコピーを遅らせる仕組み
  - 子プロセス側で必要となるデータのみコピーする

## Chapter14
- 子プロセス側で非同期に処理を行いたい場合は親プロセスが先に終了しても問題ない
- それ以外のケースでは子プロセスを定期的イン管理できる仕組みが必要

```
Process.#wait => 子プロセスのうちどれかひとつが終了するまで親プロセスの実行を待つ(ブロックする)
終了した子プロセスのpidを返す
```
```
Process.#wait2 => Process.#waitと同じく親プロセスの実行を待つ
終了した子プロセスのpidと終了コードを返す
終了コードはProcess::Statusクラスのインスタンス
```
```
Process.#waitpid => 指定した子プロセスが終了するまで親プロセスの実行を待つ(子プロセスはpidで指定する)
終了した子プロセスのpidを返す
```
```
Process.#waitpid2 => Process.#waitpidと同じく指定した子プロセスが終了するまで親プロセスの実行を待つ
終了した子プロセスのpidと終了コードを返す
```

- カーネルは終了したプロセスの情報をキューに入れておく
  - 親プロセスは子プロセスの終了情報を必ず受け取る

```
終了を待つ子プロセスのがない状態でProcess.#waitするとErrno::ECHILD例外が送出される
```
```
Process.#wait族 <=> waitpid(2)
```

## Chapter15
- 子プロセスの処理が終了後、親プロセスでwaitが実行されるとカーネルのリソースが解放される
- カーネルは、親プロセスがwaitを実行するまで終了した子プロセスの情報を持ち続ける
  - 親プロセスがwaitせずに終了した場合、子プロセスがゾンビ化する(処理は終了しているがwaitを待ち続ける)
    - 子プロセスがゾンビ化した場合、子プロセスをデタッチする必要がある

```
Process.#detach => 指定した子プロセスの終了を監視するスレッドを生成する
```

## Chapter16
- waitはブロッキング呼び出し(親プロセスは子プロセスが終了するまで処理を続行できない)
- 親プロセスは、:CHLDシグナルを捕捉することで子プロセスの終了を検知できる
  - > シグナルとは、実行中のプロセスに対して、さまざまなイベントを通知するために送出されるものである。
    - from https://shellscript.sunone.me/signal_and_trap.html
  - シグナルの配信は信用できない

```
Process.#wait(pid, Process::WNOHANG) => 終了を待つ子プロセスが存在しない場合、親プロセスの処理をブロックしない
```

- プロセスはシグナルを受信したらどんな時でもシグナルハンドラに処理を移す

#### シグナルの手引き
- プロセスはカーネルからシグナルを受けたとき、いずれかの処理を行なう
  - シグナルを無視する
  - 特定の処理を行なう
  - デフォルトの処理を行なう

#### 例
- `rails c`コマンドを実行
- コンソールが起動する前にCtrl + C
- シグナルSIGINT(キーボードによる中止)を検出してプロセスが終了する

#### シグナルの再定義
```
Kernel.#trap <=> sigaction(2)
シグナル名とシグナルハンドラを渡すことでシグナルの動作を再定義できる
※:KILLシグナルは再定義できない
※シグナルハンドラに'IGNORE'を渡すとシグナルを無視できる
```
```
Process.#kill <=> kill(2)
指定されたプロセスにシグナルを送る
```

## Chapter17
- プロセス間通信にはパイプとソケットがよく利用される

#### パイプ
- プロセスの片方の端を、別のプロセスの片方の端につなぐ
- パイプは単方向の通信

```
IO.pipe <=> pip(2)
読み込み側のプロセス、書き込み側のプロセスを配列にして返す
IOオブジェクトはFileオブジェクトのように扱える
```

- パイプはリソースであり、親子プロセスで共有される
  - 子プロセスにはファイルディスクリプタがコピーされるため、不要なファイルディスクリプタは閉じる必要がある
- パイプはストリーム(開始と終了の概念を持たずにデータの読み書きを行う)によって通信を行うため、区切り文字としてデリミタが必要

#### ソケット
- ストリームではなく、メッセージを使った通信を行う場合、ソケットが必要
  - メッセージ全体を読み書きするためデリミタは不要
- ソケットは双方向の通信

```
require 'socket'
Socket.pair <=> socketpair(2)
相互に結合されたソケットのペアを配列にして返す
```

#### リモートでプロセス間通信(IPC)する方法
- TCPソケットを使う
- RPCやZeroMQのようなメッセージングシステムを使う
- 分散システムを使う

## Chapter18
- デーモンプロセス => バックグラウンドで動作するプロセス(WebサーバやOSなど)
- カーネルは起動時にinitプロセス(pid = 1、ppid = 0)を生成する
- 孤児プロセスのppidは常に1(initプロセス)となる

```
Process.daemon => プロセスから制御端末を切り離し、 バックグラウンドでデーモンとして動作させる
```
```
Process.setsid
1. プロセスを新しいセッションのリーダーにする
2. プロセスを新しいプロセスグループのプロセスグループリーダーにする
3. プロセスから制御端末を切り離す
```

#### プロセスグループ
- 関連するプロセスが集まったもの
  - 親子のプロセス
  - 任意にグループ化されたプロセス
- 全てのプロセスはどこかのプロセスグループに属している
- 各プロセスグループに一意のIDが振られている
- プロセスグループリーダーは最初のプロセス
- 端末はシグナルを受け取るとプロセスグループに含まれるプロセス全般にシグナルを転送する

#### セッショングループ
- プロセスグループの集合

```
git log | grep shipped | less
↑ではコマンドごとに別のプロセスグループができる
↑はひとつのセッショングループに属している
```

- セッションリーダーはシグナルを受け取ると、そのセッションに属する全てのプロセスグループにシグナルを転送する
  - プロセスグループに届いたシグナルはプロセスグループに含まれるプロセス全般にシグナルを転送する

```
Process.getsid <=> getsid(2)
```

## Chapter19
- シェルアウト => 端末から外部コマンドを動かす
  - シェルアウトはfork(2) + execve(2)の応用
    - execve(2) => 現在のプロセスを別のプロセスに置き換える
      - 新しいプロセスは元のプロセスとメモリを共有しない
    - fork(2)で新しく子プロセスを生成して、execve(2)で任意のプロセスに置き換える

```
Kernel.#exec <=> execve(2)
指定されたコマンドを実行する
Kernel.#execはデフォルトで標準ストリーム以外のファイルディスクリプタを全て閉じるが、execveは閉じない
外部コマンドを文字列で渡すと、シェルが起動して文字列を解釈する
配列として渡すと、シェルは起動せずにARGVとして新しいプロセスに渡す
```
```
Kernel.#system <=> system(3)
引数を外部コマンドとして実行し、終了コードが0ならtrue、それ以外ならfalseを返す
```
```
Kernel#` => ``で囲んだ文字列を外部コマンドとして実行し、STDOUTを文字列にした結果を返す
```
```
Process.#spawn => 引数を外部コマンドとして実行し、子プロセスのpidを返す
親プロセスの実行をブロックしない
```
```
IO.popen <=> popen(3)
引数を外部コマンドとして実行し、そのプロセスのSTDOUTとの間に生成したパイプをIO オブジェクトとして返す
```
```
open3 => 引数を外部コマンドとして実行し、そのプロセスの標準入力・標準出力・ 標準エラー出力にパイプをつなぐ
```

## 感想
OSの話は抽象度の高いのでイメージしづらい印象があるのですが、「なるほどUnixプロセス」においては、日頃から扱っているRubyを用いて解説されているため、より具体化したイメージをつかむことができました。
