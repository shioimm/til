# なるほどUNIXプロセス まとめ
- Jesse Storimer 著
- 島田浩二・角谷信太郎 翻訳

## Chapter2
- Unixシステム
  - カーネル
    - ハードウェアを制御する
    - ユーザーはシステムコールによってカーネルの操作を行う
  - ユーザーランド
    - ユーザーの書いたプログラムの実行場所
  - システムコール
    - カーネルとユーザーランドの取次を行う
```
コマンドのセクションカテゴリ
- セクション1 誰もが実行できるユーザーコマンド
- セクション2 システムコール(カーネルが提供する関数)
- セクション3 サブルーチン(Cライブラリ関数)
- セクション4 デバイス(/dev ディレクトリのスペシャルファイル)
```

- あらゆるコードはプロセス上で実行される
  - コマンドラインからrubyを起動すると、コードを実行するためのプロセスが生まれる
  - コードを実行し終わったら、プロセスは終了する

## Chapter3
- プロセスは識別子(プロセスID = pid)を持っている

```
現在実行されているプロセスのpid

Process.#pid <-> getpid(2)
```

## Chapter4
- すべてのプロセスには親がいる
  - 親プロセスのプロセスIDはppid

```
現在実行されているプロセスのppid

Process.#ppid <-> getppid(2)
```

## Chapter5
### ファイルディスクリプタ
- Unixの世界では「全てがファイル」
  - デバイス、ソケット、パイプetc
    - 総称的な意味でのファイル -> リソース
    - 一般的な意味でのファイル -> ファイル
- 実行中のプロセスでリソースを開くと、ファイルディスクリプタ番号が割り当てられる
  - ファイルディスクリプタは関連しないプロセス間では共有できない
  - プロセスが終了するとファイルディスクリプタも終了する
- Rubyでは開いたリソースはIOオブジェクト
  - IOオブジェクトはファイルディスクリプタ番号を知っている

```
開いているリソースのファイルディスクリプタ番号

IO#fileno
```

- ファイルディスクリプタ番号は、開かれているリソースに対して、未使用の整数が昇順に割り当てられる
- リソースが閉じられると、閉じたリソースに割り当てられていたファイルディスクリプタ番号が再利用できるようになる
  - カーネルは開かれているリソースにだけファイルディスクリプタ番号を割り当てて管理する

#### 標準ストリームのファイルディスクリプタ
- 標準入力(STDIN) -> 0
- 標準出力(STDOUT) -> 1
- 標準エラー出力(ETDERR) -> 2

## Chapter6
- 1プロセスが持てるファイルディスクリプタ数には制限がある
  - ソフトリミット -> 変更可能な制限数
    - 制限を超えるとErrno::EMFILE例外が創出される
  - ハードリミット -> 変更権限を持ったユーザーのみ変更可能な制限数

```
ファイルディスクリプタのソフトリミット
Process.getlimit <-> getlimit(2)

ファイルディスクリプタのソフトリミットを引き上げる
Process.setlimit <-> setlimit(2)
```

- ソフトリミットを越えると`Errno::EMFILE`が送出される

#### その他のリソースの制限
```
プロセスのユーザーが持てる最大プロセス数
Process.getrlimit(:NPROC)

プロセスが作成できるファイルサイズの最大値
Process.getrlimit(:FSIZE)

プロセススタックの最大サイズ
Process.getrlimit(:STACK)
```

## Chapter7
- プロセスは環境変数を持っている
  - 環境変数 = プロセスで使えるデータ
    - key : value
  - 環境変数は親プロセスによって設定され、子プロセスに引き継がれる
  - 環境変数はプロセスごとに存在し、グローバルにアクセスできる

```
ENV -> 環境変数を表す定数で、ハッシュと同じようにアクセスできるAPIを持つがハッシュではない

ENV['EDITOR'] <-> $EDITOR
```
```
プロセスの環境変数

ENV <-> getenv(3)
```

## Chapter8
- プロセスには引数がある
```
Object::ARGV -> コマンドラインからプロセスに渡された引数を表す配列
```

## Chapter9
- プロセスには名前がある

```
Kernel$$PROGRAM_NAME -> 現在実行中の Ruby スクリプトの名前を表す文字列
グローバル変数なので変更可能
```

## Chapter10
- プロセスには終了コードがある
- 正常終了 -> 0
- 異常終了 -> 1

```
Kernel#exit -> 明示的な終了
デフォルトの終了コードが0(正常終了)
プロセス終了前にKernel#at_exitで定義されたブロックが実行される
```
```
Kernel#exit! -> 明示的な終了
デフォルトの終了コードが1(異常終了)
Kernel#at_exitで定義されたブロックは実行されない
```
```
Kernel#abort -> 明示的な終了
デフォルトの終了コードが1(異常終了)
問題のあったプロセスを終了させるときに使用する
終了前にエラーメッセージをSTDERRに出力する
プロセス終了前にKernel#at_exitで定義されたブロックが実行される
```
```
Kernel#raise -> 呼び出し元に向かって例外を送出する
例外が捕捉されなかった場合、結果的にプロセスが終了する(終了コードは1)
終了前にエラーメッセージとバックトレースをSTDERRに出力する
プロセス終了前にKernel#at_exitで定義されたブロックが実行される
```

## Chapter11
- fork -> 実行中のプロセス(親)から新しいプロセス(子)を生成する
  - 子プロセスは親プロセスで使われているメモリのコピーを持つ
    - コピーしたメモリは親の持つメモリとは独立して自由に変更できる
  - 子プロセスは親プロセスとファイルディスクリプタ番号を共有する
  - 子プロセスは固有のpidを持つ
- forkは1回の呼び出しで、親プロセスと子プロセスにそれぞれ戻り値を返す
  - 親プロセスには子プロセスのpidを返す
  - 子プロセスにはnilを返す
- forkを繰り返すとメモリの消費量が線形に増える(Fork爆弾)
```
プロセスを複製する

Kernel.#fork <-> fork(2)

fork do
  # 子プロセスでのみ実行したい処理を記述する
end
# ブロック内の処理が終了すると子プロセスも終了する

# 親プロセスでのみ実行したい処理を記述する
```

## Chapter12
- 親プロセスが子プロセスより先に終了する場合、親プロセスは子プロセスを道連れにしない
- 子プロセスの処理はそのまま続行される
- 子プロセスは端末からの制御を受け付けない場合がある
  - デーモンプロセス -> 意図的にプロセスを孤児化することで処理を続行させる
  - 端末セッションを持たないプロセスとの通信方法 -> Unixシグナルを使用

## Chapter13
- コポーオンライト(CoW) -> 書き込みが必要になるまで親プロセスから子プロセスへのメモリコピーを行わない仕組み
  - forkするとメモリは親から子へとコピーされるが、親子間でメモリへの変更が必要になるまで処理を遅延させる
  - 子プロセス側で必要となるデータのみコピーし、残りのデータは親子間で共有する

## Chapter14
- 子プロセス側で非同期に処理を行いたい場合は親プロセスが先に終了しても問題ない
- それ以外のケースでは子プロセスを定期的に管理できる仕組みが必要

```
Process.#wait -> 子プロセスのうちどれかひとつが終了するまで、親プロセスの実行をブロックする
返り値は終了した子プロセスのpid
```
```
Process.#wait2 -> 子プロセスのうちどれかひとつが終了するまで、親プロセスの実行をブロックする
返り値は終了した子プロセスのpidと終了ステータスの配列
終了ステータスはProcess::Statusクラスのインスタンス
```
```
Process.#waitpid -> pidで指定した子プロセスが終了するまで親プロセスの実行を待つ
返り値は終了した子プロセスのpid
```
```
Process.#waitpid2 -> pidで指定した子プロセスが終了するまで親プロセスの実行を待つ
返り値は終了した子プロセスのpidと終了ステータスの配列
```

- カーネルは終了したプロセスの情報をキューに入れておく
  - 親プロセスは子プロセスが終了した順に、順次終了した子プロセスの情報を処理することができる
- 終了を待つ子プロセスがない状態でwaitするとErrno::ECHILD例外が送出される
- prefork -> 子守プロセス、マスター/ワーカー
  - 用意した一つのプロセスから、並行処理のために複数の子プロセスを生成して、その後子プロセスの子守をする
  - Unicorn -> サーバー起動時にワーカープロセスをいくつ使うか指定し、親プロセスが死活監視する

```
子プロセスが終了するまで親プロセスの終了をブロックする

Process.#wait族 <-> waitpid(2)
```

## Chapter15
- カーネルは終了した子プロセスの情報を(親プロセスがwaitを実行するまで)持ち続ける
  - 親プロセスが子プロセスの終了を待たない場合(waitを使わない場合)、子プロセスをデタッチする必要がある
```
Process.#detach -> pidで指定された子プロセスの終了を待ち受けるスレッドを生成する
```
- 親プロセスに待たれずに終了した子プロセスは例外なくゾンビ化する

## Chapter16
- waitはブロッキング呼び出し
  - 親プロセスは子プロセスが終了するまで処理を続行できない
- 親プロセスは、:CHLDシグナルを捕捉することで子プロセスの終了を検知できる
  - > シグナルとは、実行中のプロセスに対して、さまざまなイベントを通知するために送出されるものである。
    - from https://shellscript.sunone.me/signal_and_trap.html
  - シグナルの配信は信用できない
    - CHLDシグナルの処理中に別の子プロセスが終了した場合、次のCHLDシグナルを捕捉できる保証はない
    - waitの呼び出しをループさせて、全ての子プロセスの終了通知を待ち受ける必要がある

```
Process.#wait(pid, Process::WNOHANG) -> 終了を待つ子プロセスが存在しない場合、親プロセスの処理をブロックしない
第二引数に定数Process::WNOHANGを渡す
```

- 終了を待つ子プロセスがない状態でwaitするとErrno::ECHILD例外が送出される
  - CHLDシグナルのハンドラではErrno::ECHILD例外を捕捉する必要がある

### シグナルの手引き
- プロセスはカーネルからシグナルを受けたとき、いずれかの処理を行なう
  - シグナルを無視する
  - 特定の処理を行なう
  - デフォルトの処理を行なう
- シグナルには送信元がある
  - シグナルはある特定のプロセスから別のプロセスへ、カーネルを介して送られる
  - プロセスには各シグナルを受信した際のデフォルトの動作がある

#### 例
- `rails c`コマンドを実行
- コンソールが起動する前にCtrl + C
- シグナルSIGINT(キーボードによる中止)を検出してプロセスが終了する

### シグナルの再定義
```
Kernel.#trap <-> sigaction(2)
引数でシグナル名、ブロックでシグナルハンドラを渡すことでシグナルの動作を再定義できる
※:KILLシグナルは再定義できない
※シグナルハンドラに'IGNORE'を渡すとシグナルを無視できる
```
```
Process.#kill <-> kill(2)
指定されたプロセスにシグナルを送る
```
- シグナルはグローバルに動作する
- プロセスはいつでもシグナルを受信できる
  -  プロセスはシグナルを受信するとすぐにシグナルハンドラを実行する

## Chapter17
- プロセス間通信 -> 複数のプロセス間で情報をやり取りする
  - プロセス間通信にはパイプとソケットがよく利用される

### パイプ(IO.pipe)
- パイプ -> プロセスからプロセスへの単方向の通信
- 「パイプを開く」 -> プロセスの片方の端を、別のプロセスの片方の端につなぐ
- 片方のプロセスが書き込み側となり、もう片方が読み込み側となる

```
読み込み側のIOオブジェクトと書き込み側のIOオブジェクトの二要素から成る配列を返す

IO.pipe <-> pip(2)
IOオブジェクトはFileオブジェクトのように扱えるが、ファイルではない
```

```ruby
reader, writer = IO.pipe

fork do
  # 子プロセス
  reader.close # 使わないパイプの端を閉じる

  10.times do
    writer.puts "I am a child"
  end
end

# 親プロセス

writer.close # 使わないパイプの端を閉じる

while message = reader.gets
  $stdout.puts message
end
```
- パイプはリソースであり、親子プロセスで共有される
  - 子プロセスにはファイルディスクリプタがコピーされるため、不要なファイルディスクリプタは閉じる必要がある
- パイプはストリームによって通信を行うため、区切り文字としてデリミタが必要
  - ストリーム -> 開始と終了の概念を持たずにデータの読み書きを行う

#### ソケット
- ストリームではなく、メッセージを使った通信を行う場合、ソケットが必要
  - ソケットはデータグラムによって通信を行い、メッセージ全体を読み書きするためデリミタは不要
- ソケットは双方向の通信

```
相互に結合されたソケットのペアを配列にして返す

require 'socket'
Socket.pair <-> socketpair(2)
```

#### リモートでプロセス間通信(IPC)する方法
- TCPソケットを使う
- RPCやZeroMQのようなメッセージングシステムを使う
- 分散システムを使う

## Chapter18
- デーモンプロセス -> バックグラウンドで動作するプロセス(WebサーバーやOSなど)
- カーネルは起動時に最初のプロセスであるinitプロセス(pid = 1、ppid = 0)を生成する
- 孤児プロセスのppidは常に1(initプロセス)となる

```
Process.daemon -> プロセスから制御端末を切り離し、 バックグラウンドでデーモンとして動作させる
```
```
Process.setsid
1. プロセスを新しいセッションのリーダーにする
2. プロセスを新しいプロセスグループのプロセスグループリーダーにする
3. プロセスから制御端末を切り離す
```

### プロセスグループ
- 関連するプロセスが集まったもの
  - 親子のプロセス
  - 任意にグループ化されたプロセス
- 全てのプロセスはどこかのプロセスグループに属している
- 各プロセスグループはプロセスグループIDを持つ
  - プロセスグループIDはプロセスグループリーダーのpid
- プロセスグループリーダーは最初のプロセス
- 端末はシグナルを受け取るとプロセスグループに含まれるプロセス全般にシグナルを転送する

### セッショングループ
- プロセスグループの集合

```
git log | grep shipped | less
↑ではコマンドごとに別のプロセスグループができる
それぞれのプロセスグループがひとつのセッショングループに属している
```

- セッションリーダーはシグナルを受け取ると、そのセッションに属する全てのプロセスグループにシグナルを転送する

```
セッショングループID

対応するRubyメソッドはない <-> getsid(2)
```

## Chapter19
- シェルアウト -> 端末から外部コマンドを動かす
  - fork(2) + execve(2)でシェルアウトを行う
    - execve(2) -> 現在のプロセスを別のプロセスに置き換える
      - 新しいプロセスは元のプロセスとメモリを共有しない
      - 現在のプロセスは終了する
    - fork(2)で新しく子プロセスを生成して、execve(2)で任意のプロセスに置き換える
      - -> 元のプロセスと別のプロセスを生成することができる

```
Kernel.#exec <-> execve(2)

指定されたコマンドを実行する
Kernel.#execはデフォルトで標準ストリーム以外のファイルディスクリプタを全て閉じるが、execve(2)は閉じない
外部コマンドを文字列で渡すと、シェルが起動して文字列を解釈する
配列として渡すと、シェルは起動せずにARGVとして新しいプロセスに渡す
```
```
Kernel.#system <-> system(3)

引数を外部コマンドとして実行し、終了コードが0ならtrue、それ以外ならfalseを返す
外部コマンド側の標準ストリームは現在のプロセスと共有される
```
```
Kernel#`

``で囲んだ文字列を外部コマンドとして実行し、STDOUTを文字列にした結果を返す
%x[]と同じ
```
```
Process.#spawn

引数を外部コマンドとして実行し、子プロセスのpidを返す
親プロセスの実行をブロックしない
```
```
IO.popen <-> popen(3)

引数を外部コマンドとして実行し、そのプロセスのSTDOUTとの間に生成したパイプをIO オブジェクトとして返す
```
```
open3 -> 引数を外部コマンドとして実行し、そのプロセスの標準入力・標準出力・ 標準エラー出力にパイプをつなぐ
```
