# プログラミングの基礎 まとめ
- 浅井健一 著

## 数
### 自然数
- (0..無限大)の整数
```
# 自然数の定義は自己参照の形を持っている

0は自然数である
nが自然数ならn + 1も自然数である
```

### 完全数
- 自分自身を除く約数の和がその数自身になる数

## 値・データ型・データ構造
- 整数
- 実数
- 文字列
- 真偽値
- 組
  - いくつかのデータをまとめて一つのデータにしたもの
- レコード
  - 名前(フィールド)を持ついくつかのデータをまとめて一つのデータにしたもの
- リスト
  - 同じ型のデータが任意の個数並んだもの
  - 再帰的なデータ型
  - 二つの要素からなる組をまとめたリスト = 連想リスト
- 配列
  - リストのように多くのデータが並んだデータ構造であり、定数時間でアクセス可能なインデックスを持っているもの
  - 値の破壊的変更が可能

### プリミティブ型
- 言語によって提供される型

### 型定義
- 自らによってプリミティブ型を組み合わせて型を定義する

### 再帰的なデータ型(自己参照するデータ型)
- 自分自身を使って定義されるデータ定義
- 自己参照を含まない無条件で使用できる定義から始まり、
自己参照によって任意に大きなデータをつくることができる
- リスト、木etc

### 多相型
- 型変数を含む型

#### 型変数
- どのような型でも良い(多相性)変数

#### 多相関数
- 多相型を持つ関数

### オプション型
- OCamlで`None`(値がない)と`Some of 'a`('a型の値)を構成子として持つデータ型

### 抽象データ型
- データ構造の実現方法については言及せず、使い方のみによって規定されるデータ型
  - モジュールインターフェースであるシグネチャなど

### unit型
- 値`()`のみを持ち、「何も返さない」ことを示す型

### 参照型
- 参照透過性がなく値の変更が可能な型

### バリアント型
- 定義したうちのどれか一つを表す型
- 自己参照が可能
  - 木など

### 木
- 木は空の木、葉、節からなるデータ構造
  - 空の木 -> データを格納していない
  - 葉 -> データを一つ格納している
  - 節 -> 自分自身のデータと左右の葉のデータを格納している
- 節における葉の数が必ず二つになる木 = 2分木

#### 2分探索木
- 全ての節について、節の左側の木に格納されているデータは、その節に格納されているどのデータよりも小さい
- 全ての節について、節の右側の木に格納されているデータは、その節に格納されているどのデータよりも大きい
- 左右のバランスを保つ木のことをバランス木という

#### 赤黒木
- 2分探索木の各節に赤または黒の色がついているもの
- 木の根から空の木に至る全てのパスにおいて黒い頂点の数が同じ
- 赤い頂点の子は必ず黒

#### ヒープ
- 各頂点の値がどちらの子の頂点よりも小さい木構造
- 兄弟の大小関係は考慮していないため、叔父叔母の値が自分の値よりも小さくなることがある
- データの数に関わらず、データの取得はO(n)、データの更新はO(log n)で行うことができる
```
要素の挿入
1. 新しい要素を配列の最後に追加
2. 追加した要素と親を比較し、自分の方が小さい場合は親と入れ替える
3. これをヒープの条件が満たされるまで繰り返す
```
```
要素の削除
1. 配列の最初の要素(根)を削除し、配列の最後の要素を移動する
2. 二つの子のよりも小さくなるまで、二つの子の小さい方と交換を繰り返す
```

## 変数
- 値や式に紐付く名前
- 関数型言語においては、参照型を除いて再代入を禁止することによって参照透過性を担保している

### スコープ
- 変数の有効範囲
- OCamlにおいては局所変数定義によって変数のスコープを限定する

### 参照透過性
- 一度定義した値が将来にわたって不変であること
  - 同じ入力を与えられた関数は常に同じ値を返す

## 関数
- 入力された値に対し、定められた処理を行って結果を返す式
- 関数型言語においては関数は第1級の値である

### 引数
- 仮引数
  - 関数定義時に使用される引数
- 実引数
  - 関数呼び出し時に使用される引数

### スコープ
- 関数の有効範囲
- OCamlにおいては局所関数定義によって関数のスコープを限定する

### 再帰関数
- 関数の中で自らを呼び出す関数
- 再帰呼び出しするケースと再帰呼び出ししないケースの処理を必ず含む
- 停止性の判定によって再帰呼び出ししないケースを呼び出すことで無限ループを防ぐ

#### 停止性の判定
- 次の二点を示し停止性の判定を行う
  - 再帰呼び出しを行う際の部分問題が、元の問題よりも簡単になっている
    - リストの長さetc
  - 有限回で自明なケースに帰着されること
    - 整数に対する操作であることetc

#### 構造に従った再帰
- 再帰データの構造と一対一に対応した再帰

### 高階関数
- 関数を入力として受け取る関数
- 関数を返り値として出力する関数

#### map関数
- 処理を示す関数と、処理を適用する値のリストを引数として入力すると
処理を適用した後の値のリストを返す関数

#### filter関数
- 条件を指定する関数と、条件を適用する値のリストを引数として入力すると
条件を満たす値のリストを返す関数

#### fold_right関数
- 処理を示す関数と、処理を適用する値のリストと、処理を適用する初期値を引数として入力すると
初期値に対してリストの要素を右から順に施し込んでいき、値をまとめ上げて返す関数(初期値と同じ型の値が返る)

### 無名関数
- 定義と同時に呼び出される関数
- 再帰呼び出しができない

### prefix関数
- 関数を引数の手前に置く関数

### infix関数
- 関数を引数と引数の間に置く関数
  - `+`、`-`、 `*`、`/` etc

## 条件分岐
- 条件の真偽によって次の実行を定める式

## パターンマッチ
- 値のパターンを認識する手続き

### パターン変数
- 構造データの要素を表す抽象化された変数

## モジュール
- 意味的につながりのある関数のまとまり

### シグネチャ
- モジュールのインターフェース

## アルゴリズム
### ダイクストラ法(最短経路問題)
```
1. 始点への最短距離は0、それ以外の点への最短距離は無限大
2. U = 最短距離が確定した点の集合
   V = 最短距離が確定していない点の集合
3. 「直前に確定した点につながっている全ての点」の最短距離を更新
   その点がすでに持っている最短距離 + 直前に確定した点経由でその点に行った場合の最短距離
4. Vのなかで最短距離が最小の点pを選択する
5. pの保持している最短距離を確定しpをVからUへ移動
6. Vが空集合になるまで繰り返す
```

### 分割統治法(クイックソート)
```
1. 問題を部分問題に分割する
2. 各々の部分問題を独立に解く
3. 得られた会から全体の会を計算する
```

### ユークリッドの互除法(最大公約数を求める)
```
# 自然数n, mの場合、次のいずれか

1. m(「n = 0」の場合)
2. 「n」と「mをnで割った余り」の最大公約数
```

### 線形探索
```
リストの要素を左から順に照らし合わせる
計算量はリストの長さに比例する
```

## アキュムレータ
- 情報を累算する値

## 例外処理
- 例外的な状況におけるプログラム上の処理

### 副作用命令
- 副作用命令はモジュール内に隠蔽する
- 関数は「どこかを書き換える」ではなく「書き換えた後の値」を返り値にする
