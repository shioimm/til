# Real World HTTP 歴史とコードに学ぶインターネットとウェブ技術 まとめ
- 渋川よしき 著

## HTTPの基本要素
- メソッドとパス
- ヘッダー
- ボディ
- ステータスコード

## ヘッダー
- `フィールド名:値`という形式で本文の前に付加される
- サーバー-クライアント間での追加情報、指示や命令、お願いなど

### リクエスト
#### [User-Agent](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/User-Agent)
- ブラウザ、OSなどのユーザーエージェント情報を識別する特性文字列

#### [Referer](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Referer)
- 現在のページにリクエストを送る前にリンクを踏んだ直前のページのアドレス

#### [Authorization](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Authorization)
- 特別なクライアントにだけ通信を許可する場合、ユーザーエージェントがサーバーから認証を受けるための証明書

### レスポンス
#### [Content-Type](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Type)
- ファイルの種別を示す識別子(MINEタイプ)

#### [Content-Length](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Length)
- サーバーから送信するボディのサイズ(バイト単位)

#### [Content-Encoding](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Encoding)
- ボディが圧縮されている場合、その圧縮形式

#### [Date](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Date)
- メッセージが発信された日時

### その他
- `X-`から始まるヘッダーは各アプリケーションで自由に設定されたもの

### コンテントネゴシエーション
- ヘッダーを利用してサーバーとクライアントがお互いにベストな設定を共有する仕組み

#### ネゴシエーションの対象
- MINEタイプ
  - リクエストヘッダー: Accept
  - レスポンスヘッダー: Content-Type
- 表示言語
  - リクエストヘッダー: Accept-Language
  - レスポンスヘッダー: Content-Type
- 文字のキャラクターセット
  - リクエストヘッダー: Accept-Charset
  - レスポンスヘッダー: Content-Type
- ボディの圧縮
  - リクエストヘッダー: Accept-Encoding
  - レスポンスヘッダー: Content-Encoding

### クッキー
- サーバー側のデータをクライアント側に保存させるための機構
- 名前=値の形式でヘッダーにてやり取りを行う
- 永続化されていないため、シークレットモードやブラウザ側の操作で削除される場合がある
- 容量は最大4KB
- HTTPSでは暗号化された場合にしか送信できないが、HTTPの場合は平文で送信される

#### クッキーの制約
- Expires / Max-Age属性
  - 有効期限(Max-Ageは秒単位)
- Domain属性
  - クライアントからクッキーを送信する対象のサーバー
    - デフォルトでクッキーを発行したサーバー
- Path属性
  - Domain属性のサーバーのパス
- Secure属性
  - https以外での通信を行わない
  - httpでの通信の場合に警告を発する
- HttpOnly属性
  - JavaScriptエンジンからクッキーを隠す
- SameSite属性
  - Chromeがバージョン51で導入した属性、同じオリジンのドメインに対して送信する

### キャッシュ機構
- 更新日時によるキャッシュ
  - リクエストに付与された日時とサーバー上のコンテンツの日時の比較
- Expiresヘッダーによるキャッシュ
  - 現在がリクエストヘッダーに付与された有効期限日時以前であることの確認
-  [Pragma: no-cache](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Pragma)(-> Cache-Control)
  - 「リクエストしたコンテンツがプロキシサーバーにキャッシュされている場合も、オリジンサーバーまでリクエストを届ける」という指示
-  [ETag](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag)
  - サーバーがレスポンスに付与する「ファイルに関するハッシュ値」
  - クライアントは二回め以降のリクエストで、If-None-MatchヘッダーにてETagを送信する
  - サーバーはリクエストのETagの値とレスポンスするファイルのETagを比較
-  [Cache-Control](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Cache-Control)
  - リクエストヘッダーとレスポンスヘッダーのキャッシュ規則を指定する
- [Vary](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Vary)
  - 同じURLでもクライアントによって返す結果が異なる理由を列挙する
    - ユーザーエージェント、言語 etc

## メソッド
### [GET](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/GET)
- サーバーに対してヘッダーとコンテンツを要求

### [HEAD](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/HEAD)
- サーバーに対してヘッダーを要求

### [POST](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/POST)
- サーバーに対してデータを送信

### [PUT](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/PUT)
- すでにURLが存在するコンテンツの置き換え

### [DELETE](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/DELETE)
- コンテンツとURLの削除

### [OPTIONS](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/OPTIONS) -> HTTP/1.1で追加
- サーバーが受け取り可能なメソッド一覧を返す
- サーバー側で使用が許可されていない場合が多い

### [TRACE](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/TRACE) -> HTTP/1.1で追加
- サーバーが受け取るとContent-Typeにmessage/httpを設定し、ステータスコード200をつけてリクエストヘッダとボディを返す
- XST脆弱性により現在は使われていない

### [CONNECT](https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/CONNECT) -> HTTP/1.1で追加
- HTTPのプロトコル上に他の他のプロトコルのパケットを流せるようにする
- プロキシサーバー経由でターゲットのサーバーに接続することを目的とする
- https通信を中継する用途で使われる

### 廃止されたメソッド
- LINK
- UNLINK
- CHECKOUT
- CHECKIN
- SHOWMETHOD
- TEXTSEARCH
- SEARCHJUMP
- SEARCH

## パス(URL)
```
https://www.oreilly.co.jp/index.shtml

# スキーマ://ホスト名/パス

# URLの全要素
# スキーマ://ユーザ:パスワード@ホスト名:ポート/パス#フラグメント?クエリ
```
- ポートはスキーマごとにデフォルト値を持つ(httpは80、httpsは443)
- URLの長さはだいたい2000文字くらい(IEは2083文字)

## ステータスコード
- 100番台 -> 処理中
- 200番台 -> 成功
- 300番台 -> サーバーからクライアントへの指示
  - リダイレクトなど -> リダイレクトはLocationヘッダを参照し、ヘッダごと送信し直す
- 400番台 -> クライアント側の異常
- 500番台 -> サーバー側の異常

## ボディ
- ヘッダーの下に空行を入れると、それ以降はボディとして扱われる
- 一通信につき、Content-Length分が指定するバイト数分の一ファイルを扱う

### フォーム
- POST以外のメソッドでボディ(フォーム)を送信することは推奨されない(サーバー側で受け付けない場合がある)
  - そのため、GETにてフォームを送信する場合は、ボディでは無くURLにクエリとして文字列を付与する

#### multipart/form-data
- フォームにてファイルを送信することができるエンコードタイプ
- Content-Typeにboundary(境界文字列・ブラウザごとに異なる)属性が加わる
- ボディ内にヘッダー + 空行 + コンテンツを構成する
  - ヘッダーにContent-Disposition(Content-Typeのようなもの)が加わる

## 認証とセッション
- BASIC認証
- Digest認証
- クッキーによるセッション管理
```
1. クライアントがフォームからIDとPASSを送信(通信時の暗号化が必須)
2. サーバーがIDをPASSを認証し、セッショントークンを発行
3. サーバーがセッショントークンをDBに保存
4. サーバーがクライアントに送信
```

- 署名つきクッキーによるセッション管理
```
1~3までは上記と同じ
4. サーバーがクライアントに対して電子署名済みのセッショントークンを発行
5. クライアントがクッキーを再送した際、サーバーが署名を確認
# サーバー側が署名・確認を行うため、クライアントは鍵を持たない
```

## プロキシ
- HTTPなどの通信を中継する仕組み
- 中継をする際に付加機能が実装される場合がある
  - キャッシュ機構
  - ファイアウォール
  - コンテンツフィルタ
  - 画像圧縮フィルタ etc
- プロキシサーバーを設定することでURL(パス)にスキーマが追加される
- X-Forwarded-Forヘッダーに中継プロキシが追加される

### ゲートウェイとの違い
- ゲートウェイ -> 通信内容をそのまま転送する
- プロキシ     -> コンテンツを改変したりサーバーの代わりに応答したりする

## ダウンロード
- レスポンスヘッダーに[Content-Disposition](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Disposition)が含まれる場合、ブラウザは保存ダイアログを出しデータを保存する
- ダウンロードの中断が中断された場合、途中から再開する方法が提供されている
  - 途中から再開 = ファイルの指定範囲を切り出してダウンロードする
  - 指定範囲ダウンロードをサポートしているサーバーは次のヘッダーをレスポンスに付与する
    - [Accept-Ranges](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Accept-Ranges)ヘッダーをレスポンスに付与する
    - [ETag](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag) -> コンテンツの変更を検知するため
  - ブラウザは[Range](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Range)ヘッダーをリクエストに与えて転送してほしい範囲を指定する
    - Rangeヘッダーは複数範囲の指定も可能
      - サーバーは`Content-Type: multipart/byteranges;`を返す
      - ダウンロード時間短縮のためRangeヘッダーを使用し並列ダウンロードを行うことは、サーバーに負荷をかけるため推奨されていない

## [XMLHttpRequest](https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest)
- curlコマンドと同等の操作をJavaScriptから行うことができる機能
- ページ全体を更新せずにデータを受け取ることができるため、Ajaxプログラミングで使用される

### ブラウザのHTTPリクエストとの違い
- 送受信時にHTMLの画面がリロードされない
- GET / POST以外のメソッドも送信できる
- キーと値が一対一になっているデータ形式以外のフォーマットでデータを送信できる(プレーンテキスト、JSON、XMLetc)
- セキュリティのための制約を持つ

### Comet
- XMLHttpRequestを使用したレガシーなリアルタイム双方向通信
- ポーリング -> 通知を受ける側が、通知の有無を頻繁に訊きにいく方式
- ロングポーリング -> クライアントからサーバーにリクエストを送った後、即時にレスポンスを返さず保留する
サーバー側から通信を完了させるか、リクエストがタイムアウトした際にレスポンスを返す
- Cometはロングポーリングを使用している
- 一メッセージあたりのオーバーヘッドが大きくサーバーからの連続したメッセージに強くない
- Cometよりも後に、より応答性の良いサーバー通知の仕組みが作られた

### セキュリティ
- アクセスできる情報の制限
  - 例: Cookieの制限(CookieにhttpOnly属性を付与し、スクリプトからアクセスできないようにするなど)
- 送信制限
  - リクエストを送信できるドメインの制限(CORS)
  - 利用できるHTTPメソッドの制限
  - ヘッダーの制限
    - 例: プロトコルのルールや環境に影響を与えるもの、セキュリティに影響を与えるもの、ブラウザの能力を超えられないもの

## Geo-Location
- クライアントの物理的な場所を測定する

### クライアント自身が場所を得る
- ブラウザに実装されたGeolocation API
  - GPS
  - WiFiのアクセスポイント
- スマートフォンを利用したクラウドソーシング

### サーバーがクライアントの場所を得る
- GeoIP(IPアドレス)

## [HTTPの歴史] HTTP/0.9
- ウェブサイトの情報をサーバーに要求する
  - ホスト名、ポート、パス、検索クエリ
- サーバーから情報をテキストで受け取る

## [HTTPの歴史] HTTP/1.0
### 変更点
- 以下の機能が追加
  - バージョン
  - ステータスコード
    - ニュースグループで使われていた機能が輸入された
  - メソッド
    - ニュースグループで使われていた機能が輸入された
  - ヘッダー
    - メールシステムで使われていた機能が輸入された
    - リクエストは先頭にメソッド + パスの行が追加される
    - レスポンスは先頭にステータスコードの行が追加される

## [HTTPの歴史] HTTP/1.1
### 変更点
- 通信の高速化
  - Keep-Aliveのデフォルト有効化
  - パイプライニング
- TLSによる暗号化通信のサポート
- 新メソッドの追加
  - PUTとDELETEが必須化
  - OPTION、TRACE、CONNECTが追加
- プロトコルのアップグレード
- 名前を使ったバーチャルホストのサポート
- サイズが事前にわからないコンテンツのチャンク転送エンコーディングのサポート

### Keep-Alive
- HTTPの下のレイヤーであるTCP/IPを効率化する仕組み
- 無効状態の場合、リクエストごとに通信を閉じる
- 有効化した場合、連続したリクエストの際に接続を再利用する
```
パケットが一往復する時間 -> 1RTT(Round Trip Time)

TLSでは通信開始前のハンドシェイクに2RTTを要する
Keep-Aliveを有効化することでハンドシェイクの回数を削減することができる
```
- リクエスト/レスポンスいずれかのヘッダーに`Connection: Close`が付与されると接続を終了する

### パイプライニング
- 最初のリクエストが完了する前に次のリクエストを送信することによってレスポンスの待ち時間を削減し、ネットワーク稼働率を向上させる(-> 速度改善を図る)機能
- Keep-Aliveの利用を前提とする
- サーバーはリクエストの順にレスポンスを返す
- 正しく動作しないサーバーがあったり、パフォーマンスが開戦しないケースがあったために、そのままではあまり利用されていない

### TLS
- サーバーを認証し、鍵を交換して通信経路を暗号化し、通信を行う仕組み
- HTTPと共同利用されることを想定してSSL3.0を元に実装された
- 既存のプロトコルに、通信経路の安全性を追加した新たなプロトコルを作り出すことができる
  - HTTP -> HTTPS、SMTP -> SMTPS
- 暗号化されており、通信の内容を覗いたり変更することができない安定した双方向通信

#### TLSを理解するために必要な技術要素
- ハッシュ関数
- 共通鍵暗号(AES)
  - RSAよりもパフォーマンスに優れる
- 公開鍵暗号(RSA)
  - 公開鍵 -> 暗号化する鍵
  - 秘密鍵 -> 複合化する鍵
  - デジタル署名
    - RSAの応用
    - 秘密鍵を公開し、公開鍵を秘密にする
    - 公開鍵によって暗号化したデータと、本文を送信する
    - 秘密鍵によってデータを復号化した際、本文との差分がないことによって、本文が改竄されていないことを保証する
- 鍵交換
  - クライアントとサーバー間で鍵の材料を作ってお互いに交換し、それぞれ計算して同じ鍵を得るアルゴリズム
- 暗号強度
  - アルゴリズムの数学的特性によって暗号強度が異なる
- 暗号スイート
  - それぞれの場面で使うアルゴリズムの組み合わせをリスト化して管理し、
サーバー/クライアント間で共通に使えるものを選択する仕組み
  - その暗号がサポートされたプロトコルバージョン、鍵交換アルゴリズム名、認証アルゴリズム、レコード暗号アルゴリズムetc
  - RFC7540では使うべきではない暗号スイートのブラックリストが定義された
- プロトコルの選択
  - アプリケーション層のプロトコルを選択する拡張機能

#### TLSの通信手順
```
1. ブラウザがサーバーの信頼性を確認
  - サーバーから発行者のデジタル署名付きのSSL証明書を取得する
2. 鍵交換
  - 公開鍵暗号もしくは鍵交換専用アルゴリズムによって鍵交換を行う
3. 通信
  - 通信の暗号化を行う
  - TLS1.2以前は通信内容のハッシュ値を計算し、共通鍵暗号で暗号化していた
  - TLS1.3以降は認証付き暗号に限定される
```
- Keep-Alive、セッション再開機能(TLS1.2)、事前共有鍵(TLS1.3)などによってRTTの削減を図っている
- TLS1.3以降は鍵交換と秘密鍵暗号が分離されたため、クライアント側から鍵の交換が行えるようになった
- TCPに代わるQUIC通信方式がIFTFに提案されている

### 新メソッドの追加
- -> メソッドを参照

### プロトコルのアップグレード
- HTTP以外の次のプロトコルへのアップグレードが可能になった
  - 安全な通信へのアップグレード(TLS/1.0、 TLS/1.1、TLS/1.2)
  - 双方向通信へのアップグレード(websocket)
  - HTTP/2へのアップグレード
- TLSを使うためには、クライアントとサーバー間の通信経路を全て暗号化する必要がある

#### クライアントからアップデートを要請する場合
- UpgradeヘッダーとConnectionヘッダーを含めたリクエストを送る
  - アップグレードをサポートしていないHTTP/1.0サーバーの場合、OPTIONSリクエストを送信してアップグレードの可否を確認する
  - アップグレード可能であればサーバーからUpgradeをサポートしたレスポンスが返る

#### サーバーからアップデートを要請する場合
- サーバーからTLSへの更新を要請する場合もUpgradeヘッダーとConnectionヘッダーを含めたリクエストを送る
- ステータスコードは426をつける

### バーチャルホストのサポート
- HTTP/1.0 -> 一台のWebサーバーでひとつのドメインのみを運用する
- HTTP/1.1 -> 一台のWebサーバーで複数のドメインのみを運用することができるようになった

#### 方法
- クライアントはHostヘッダーにリクエストを送りたいサーバー名を記述することが義務付けられた
- サーバーはリクエストヘッダーのHostヘッダーを見ると、どのサービスが要求されているのかを判断できる
- これによって同一サーバーでコンテンツを出し分けることができるようになる

### チャンク
- 全体を一括で送信するのではなく、小分けにして送信するデータ表現
- 時間のかかるデータ転送を少しずつ前倒して行うことができる(ストリーミングアップロード / ダウンロード)

#### 方法
- サーバー -> 転送に必要なブロックだけをメモリにロードしてTCPソケットに流し込む
  - [Transfer-Encoding: chunked](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Transfer-Encoding)ヘッダーを送信
  - 規定のサイズに分割されたボディを送信
  - 最後に終了の合図として0を送信
  - チャンク形式の場合のみ、ボディの末尾にヘッダーを追加できる(チャンク形式であることを示すヘッダーを除く)
- クライアント -> チャンクを結合して処理を行う

### ボディ送信の確認
- クライアントからサーバーに対して、受け入れの可否を確認してからボディを送信できるようになった

#### 方法
- クライアントは[Expect](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Expect)ヘッダーとそれ以外のヘッダーを送信
- サーバー側は受け入れ可能のレスポンスを返す(不可の場合は不可を示すステータスコードを返す)

## [HTTPの歴史] HTTP/2

## セキュリティ

## RESTful API
