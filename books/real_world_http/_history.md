# Real World HTTP 歴史とコードに学ぶインターネットとウェブ技術 まとめ
- 渋川よしき 著

## [HTTPの歴史] HTTP/0.9
- ウェブサイトの情報をサーバーに要求する
  - ホスト名、ポート、パス、検索クエリ
- サーバーから情報をテキストで受け取る

## [HTTPの歴史] HTTP/1.0
### 変更点
- 以下の機能が追加
  - バージョン
  - ステータスコード
    - ニュースグループで使われていた機能が輸入された
  - メソッド
    - ニュースグループで使われていた機能が輸入された
  - ヘッダー
    - メールシステムで使われていた機能が輸入された
    - リクエストは先頭にメソッド + パスの行が追加される
    - レスポンスは先頭にステータスコードの行が追加される

## [HTTPの歴史] HTTP/1.1
### 変更点
- 通信の高速化
  - Keep-Aliveのデフォルト有効化
  - パイプライニング
- TLSによる暗号化通信のサポート
- 新メソッドの追加
  - PUTとDELETEが必須化
  - OPTION、TRACE、CONNECTが追加
- プロトコルのアップグレード
- 名前を使ったバーチャルホストのサポート
- サイズが事前にわからないコンテンツのチャンク転送エンコーディングのサポート

### Keep-Alive
- HTTPの下のレイヤーであるTCP/IPを効率化する仕組み
- 無効状態の場合、リクエストごとに通信を閉じる
- 有効化した場合、連続したリクエストの際に接続を再利用する
```
パケットが一往復する時間 -> 1RTT(Round Trip Time)

TLSでは通信開始前のハンドシェイクに2RTTを要する
Keep-Aliveを有効化することでハンドシェイクの回数を削減することができる
```
- リクエスト/レスポンスいずれかのヘッダーに`Connection: Close`が付与されると接続を終了する

### パイプライニング
- 最初のリクエストが完了する前に次のリクエストを送信することによってレスポンスの待ち時間を削減し、ネットワーク稼働率を向上させる(-> 速度改善を図る)機能
- Keep-Aliveの利用を前提とする
- サーバーはリクエストの順にレスポンスを返す
- 正しく動作しないサーバーがあったり、パフォーマンスが開戦しないケースがあったために、そのままではあまり利用されていない

### TLS
- サーバーを認証し、鍵を交換して通信経路を暗号化し、通信を行う仕組み
- HTTPと共同利用されることを想定してSSL3.0を元に実装された
- 既存のプロトコルに、通信経路の安全性を追加した新たなプロトコルを作り出すことができる
  - HTTP -> HTTPS、SMTP -> SMTPS
- 暗号化されており、通信の内容を覗いたり変更することができない安定した双方向通信

#### TLSを理解するために必要な技術要素
- ハッシュ関数
- 共通鍵暗号(AES)
  - RSAよりもパフォーマンスに優れる
- 公開鍵暗号(RSA)
  - 公開鍵 -> 暗号化する鍵
  - 秘密鍵 -> 複合化する鍵
  - デジタル署名
    - RSAの応用
    - 秘密鍵を公開し、公開鍵を秘密にする
    - 公開鍵によって暗号化したデータと、本文を送信する
    - 秘密鍵によってデータを復号化した際、本文との差分がないことによって、本文が改竄されていないことを保証する
- 鍵交換
  - クライアントとサーバー間で鍵の材料を作ってお互いに交換し、それぞれ計算して同じ鍵を得るアルゴリズム
- 暗号強度
  - アルゴリズムの数学的特性によって暗号強度が異なる
- 暗号スイート
  - それぞれの場面で使うアルゴリズムの組み合わせをリスト化して管理し、
サーバー/クライアント間で共通に使えるものを選択する仕組み
  - その暗号がサポートされたプロトコルバージョン、鍵交換アルゴリズム名、認証アルゴリズム、レコード暗号アルゴリズムetc
  - RFC7540では使うべきではない暗号スイートのブラックリストが定義された
- プロトコルの選択
  - アプリケーション層のプロトコルを選択する拡張機能

#### TLSの通信手順
```
1. ブラウザがサーバーの信頼性を確認
  - サーバーから発行者のデジタル署名付きのSSL証明書を取得する
2. 鍵交換
  - 公開鍵暗号もしくは鍵交換専用アルゴリズムによって鍵交換を行う
3. 通信
  - 通信の暗号化を行う
  - TLS1.2以前は通信内容のハッシュ値を計算し、共通鍵暗号で暗号化していた
  - TLS1.3以降は認証付き暗号に限定される
```
- Keep-Alive、セッション再開機能(TLS1.2)、事前共有鍵(TLS1.3)などによってRTTの削減を図っている
- TLS1.3以降は鍵交換と秘密鍵暗号が分離されたため、クライアント側から鍵の交換が行えるようになった
- TCPに代わるQUIC通信方式がIFTFに提案されている

### 新メソッドの追加
- -> メソッドを参照

### プロトコルのアップグレード
- HTTP以外の次のプロトコルへのアップグレードが可能になった
  - 安全な通信へのアップグレード(TLS/1.0、 TLS/1.1、TLS/1.2)
  - 双方向通信へのアップグレード(websocket)
  - HTTP/2へのアップグレード
- TLSを使うためには、クライアントとサーバー間の通信経路を全て暗号化する必要がある

#### クライアントからアップデートを要請する場合
- UpgradeヘッダーとConnectionヘッダーを含めたリクエストを送る
  - アップグレードをサポートしていないHTTP/1.0サーバーの場合、OPTIONSリクエストを送信してアップグレードの可否を確認する
  - アップグレード可能であればサーバーからUpgradeをサポートしたレスポンスが返る

#### サーバーからアップデートを要請する場合
- サーバーからTLSへの更新を要請する場合もUpgradeヘッダーとConnectionヘッダーを含めたリクエストを送る
- ステータスコードは426をつける

### バーチャルホストのサポート
- HTTP/1.0 -> 一台のWebサーバーでひとつのドメインのみを運用する
- HTTP/1.1 -> 一台のWebサーバーで複数のドメインのみを運用することができるようになった

#### 方法
- クライアントはHostヘッダーにリクエストを送りたいサーバー名を記述することが義務付けられた
- サーバーはリクエストヘッダーのHostヘッダーを見ると、どのサービスが要求されているのかを判断できる
- これによって同一サーバーでコンテンツを出し分けることができるようになる

### チャンク
- 全体を一括で送信するのではなく、小分けにして送信するデータ表現
- 時間のかかるデータ転送を少しずつ前倒して行うことができる(ストリーミングアップロード / ダウンロード)

#### 方法
- サーバー -> 転送に必要なブロックだけをメモリにロードしてTCPソケットに流し込む
  - [Transfer-Encoding: chunked](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Transfer-Encoding)ヘッダーを送信
  - 規定のサイズに分割されたボディを送信
  - 最後に終了の合図として0を送信
  - チャンク形式の場合のみ、ボディの末尾にヘッダーを追加できる(チャンク形式であることを示すヘッダーを除く)
- クライアント -> チャンクを結合して処理を行う

### ボディ送信の確認
- クライアントからサーバーに対して、受け入れの可否を確認してからボディを送信できるようになった

#### 方法
- クライアントは[Expect](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Expect)ヘッダーとそれ以外のヘッダーを送信
- サーバー側は受け入れ可能のレスポンスを返す(不可の場合は不可を示すステータスコードを返す)

## [HTTPの歴史] HTTP/2
- 通信の高速化を目的とした改善
### 変更点
- データ表現
  - ストリームを使用してバイナリデータを多重に送信する仕組みに変更
  - ストリーム内での優先順位設定や、サーバーサイドからデータ通信を行うサーバーサイドプッシュを実装
  - ヘッダが圧縮される
#### HTTP/1.0 ~ HTTP/1.1にかけての変更
```
- キャッシュ(max-age)
  - 通信そのものをキャンセル
- キャッシュ(ETag)
  - 変更がなければボディの送信をキャンセル
- Keep-Alive
  - アクセスごとに接続にかかる時間を削減
- 圧縮
  - レスポンスのボディサイズの削減
- チャンク
  - レスポンス送信監視を早める
- パイプライニング
  - 通信の多重化
```

### ストリームによる通信の高速化
- テキストベースのプロトコル -> バイナリベースのプロトコルへ変更
  - 「フレーム」単位で送受信を行う
- TCP接続
  - HTTP/1.1まで
    - 一つのリクエストがTCPのソケットを占有する
    - 一つのオリジンサーバーに対して複数のTCP接続を行い並列化する
  - HTTP/2
    - 1本のTCP接続の内部にストリーム(擬似的なTCPソケット)を作って通信を行う
    - ストリームはハンドシェイクが不要
    - 並列化が容易
    - それぞれ接続状態のステートマシンが定義される
    - TCP
      - クローズ状態からLISTENし、クライアントからの接続リクエストによりESTABLISH状態になる
    - HTTP/2のストリーム
      - 最初からIDLE(LISTENとほぼ同じ)状態で、ヘッダーを受け取ると即座に通信可能なOPENになる
```
// 各フレームの共通ヘッダー
- Length -> ペイロードのサイズ
- Type -> フレームの種類
- Flags
- R -> 予約領域
- Stream Identifier -> ストリームの識別子 / 同じ数値なら同じストリームの関連フレーム
  - 同じStream Identifierを持つ一連のフレームが受信時にグループ化され「同じストリームから出て来たデータ」として扱われる
  - 奇数はクライアント -> サーバー / 偶数はサーバー -> クライアント
- Frame Payload -> フレームの実データ
```
```
// フレームの種類
- HEADERS -> ヘッダー
- DATA -> データ
- PRIORITY -> 依存するストリーム、優先度、排他フラグ
- SETTINGS -> エラーコード
- PUSH_PROMISE -> 識別子、設定値の組
- PING -> 8バイト分のデータ
- GOAWAY -> 最終ストリームID、エラーコード
- WINDOW_UPDATE -> ウィンドウサイズ
- CONTINUATION -> HEADERS、PUSH_PROMISEの続きのデータ
```

### HTTP/2のアプリケーション層
- メソッド、パス、ステータスコード、プロトコルバージョンは擬似ヘッダーフィールド化されてヘッダー内に組み込まれた
- HTTP/2の実装はヘッダー + ボディ
- HTTP/2はバイナリ化され、最初にフレームサイズが入っているため、TCPソケットレイヤーでデータをフレーム単位に切り分け可能
- フレーム同士は独立しているため途中で他のフレームが挟まっても問題ない

### フローコントロール
WIP
