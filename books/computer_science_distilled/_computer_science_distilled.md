# みんなのコンピュータサイエンス いま知っておきたいIT技術を支える基礎教養 まとめ
- Wladston Ferreira Filho 著
- 小山裕司 監訳

## Chapter1
- 解決案からモデルを作成し、概要ツールを使って展開可能な形にする
- 補助的に次のツールを使う
  - 論理
  - カウント
  - 確率

### 解決案
1. 問題の重要事項を全て書き出す
1. 問題のモデルを作成する
  - モデルは対象の問題と特性を表現する概念から構成される
1. 概念ツールによって問題を計算可能なプロセスに展開する
  - フローチャート
  - 擬似コード
  - 数理モデル

### 論理
- 論理は真偽値のみを扱う

### 演算子
- A / B   -> 「Aである」「Bである」
- !A / !B -> 「Aではない」「Bではない」
- A and B -> 「AかつBである」
- A or B  -> 「AもしくはBである」
- A xor B -> 「AかBどちらかである」

#### ブール代数
- 結合則
- 分配則
- ド・モルガンの法則

#### 真理値表
- 変数ごとにtrue | falseを持ち、ありうるすべての組み合わせを網羅することによって妥当性を判断する

### カウント
- 問題の可能性と構成をカウントする

#### 乗算
- ある事象ではn通りのことが起こり、別の事象ではm通りのことが起こる場合、両事象ではn * m通りのことが起こる

#### 順列
- n個の要素がある場合、これらを階乗(n!)通りに並べることができる

#### 同一要素が存在する順列
- n!通りの並びの中にr!通りの並びが重複する場合、n! / r!によって重複を排除する

#### 組み合わせ
- 二項係数
  - n要素の集合から、順に無関係にm要素を選択するときに何通りあるかを調べる

#### 総和
- Σ
  - カウント時の数列の総和を求める際の計算表現

### 確率
- 独立事象
  - 一つの事象の結果は別の事象の結果に影響を及ぼさないこと
- 排反事象
  - 二つの事象が同時に起こることがないこと
- 余事象
  - 二つの相互排他的事象がありうるすべての結果(全事象)であるとき、片方の事象はもう片方の事象の余事象である

## Chapter2
- アルゴリズムによって計算量に違いが生まれる
- 計算量が指数関数的に増加するアルゴリズムを避ける
- 計算量の増加はO記法で表現する
- メモリが十分であることを確認する

### アルゴリズム
  - 常に有限の一連の計算で完結するメソッド
  - 演算の数を減らせば必要となる計算能力も減る

### 時間計算量
- 時間計算量は計算式の支配項(増加率が最も高い項)によって表される
```
# 演算回数が大きい順
1. 支配項が階乗         -> O(n!)
2. 支配項が2 ** n以下   -> O(2n)
3. 支配項がn ** 2以下   -> O(n2)
4. 支配項がn log n 以下 -> O(n log n)
5. 支配項が線形以下     -> O(n)
6. 支配項がlog n 以下   -> O(log n)
7. 常に一定時間で実行   -> O(1)
```

### 空間計算量
- 空間計算量は消費メモリのカウントによって表される

## Chapter3
- 次の処理をアルゴリズム設計の戦略の根幹として扱う
  - 反復処理
  - 再帰処理
  - 総当たり攻撃
  - バックトラック
  - 発見的解法
  - 分割統治法
  - 動的問題解決
  - 問題の限定

### 反復処理
- 繰り返し操作

### 再帰処理
- 演算の中で自らを呼び出すケースと、自らを呼び出さないケース(基底ケース)からなる
- 再帰呼び出しを行なった回数分のメモリを消費するため、繰り返しよりもオーバーヘッドが大きい

### 総当たり攻撃
- 問題の有り得る解のの候補をすべて検査する

### バックトラック
- ある手段を用いた処理を行い、実行途中で間違っていたことがわかった場合、
再帰的手法によって直前の処理へ戻り、別の手段を検証する

### 発見的解法
- 総当たり攻撃やバックトラックせず(厳密に検査を行わず)、その時点で最も最善と思われる解を選択する
(最善とは限らない = 欲張り戦略)

### 分割統治法
- 問題を問題自身よりも小さな部分問題に分割し続け、最も単純に解ける基底状態になった時点で計算を行う

### 動的計画法
- 繰り返される部分問題を識別し、一回だけ計算を行った結果をキャッシュとして使用する

### 分枝限定法
- 問題を複数の部分問題に分割し、各部分問題の上限と下限を探し出す
- 部分問題での限定を比較し、最も解に近い部分問題を選択する
- 選択肢がなくなるまで繰り返す

## Chapter4
- データ構造によって抽象データ型の実装手段が実装される
- プログラムコード上においてはデータ構造を直接扱うのではなく抽象データ型を扱う

### 抽象表現
- 何らかの手続きのためのインターフェースであり、詳細や複雑さを隠蔽したもの

### 抽象データ型(ADT)
- 所定のデータ型に対して意味を成す操作インターフェース
- ADTは次の長所を持つ
  - 単純さ   -> 理解と修正を容易にする・仕様ではなくロジックに集中することができる
  - 柔軟さ   -> 同じADTを実装するモジュールは同じ手続きを提供する
  - 再利用性 -> 同じモジュールを何度でも使用できる
  - 整理可能 -> データ型ごとにデータ型固有のプログラムから構成されるモジュールを作成することで関心を分離できる
  - 利便性   -> 内部での処理を知ることなく利用することができる
  - 安定性   -> 多くのユーザーによって使用されていることによってバグが少ない

#### 基本データ型
- 整数 / 浮動小数点数とそれらに対する汎用的演算
- 文字列
- 真偽値 など

#### スタック(積み重ね)
- 次の操作を最低限提供する
  - push(e)
  - pop()
- 拡張版のスタックにおいては、要素の有無や要素数を取得する操作を提供する

#### キュー(待ち行列)
- 次の操作を最低限提供する
  - enqueue(e)
  - dequeue()
- 優先度付きキューにおいては次の操作を最低限提供する
  - enqueue(e, p) -> 要素eを優先度レベルpに応じて追加
  - dequeue()

#### リスト
- 次の操作を最低限提供する
  - insert(n, e) -> 位置nに要素eを挿入
  - remove(n)    -> 位置nの要素を削除
  - get(n)       -> 位置nの要素を取得
  - sort()
  - reverse()
  - slice(start, end) -> 位置startから位置endまでの部分リストを取得
- ソート済みリストにおいては次の操作を最低限提供する
  - insert(e) -> リストの正しい位置に要素eを挿入
  - remove(n)
  - get(n)

#### マップ(辞書)
- 対応づけられたキーと値の対を持つ
- 次の操作を最低限提供する
  - set(key, value) -> keyとvalueを対応づけて追加
  - delete(key)     -> keyと対応する値を削除
  - get(key)        -> keyと対応する値を取得

#### 集合
- 重複のない要素による順序のない集まり
- 次の操作を最低限提供する
  - add(e)    -> 要素eを追加
  - list()    -> 集合の要素をリストにする
  - delete(e) -> 要素eを削除

### データ構造
- データがどのように構成され、メモリ上でどのようにアクセスされるかを示したもの
- ADTの実装手段を提供する

#### 配列
- メモリ上に連続した領域を確保し、この領域に要素を順番に書き込み、列の最後にnullトークンをつけた構成
- 各オブジェクトはメモリ上に同じ量の領域を占有する
- 各オブジェクトは連続したインデックスを持つ
- 要素の探索に向いている
- 要素の追加・削除に柔軟性がない

#### 連結リスト
- 次の要素へのポインタを持つメモリセルが線形に構成されたデータ構造
- 空のポインタを持つセルはリストの終わりを示す
- スタック・キュー・リストの実装に使用できる
- 双方向連結リストは 前方と後方にポインタを持った連結リスト
- 要素の追加・削除に向いている
- 要素の探索に時間がかかる

#### 木
- 次の要素へのポインタを持つメモリセルが樹状に構成されたデータ構造
- ノード   -> メモリセル
- エッジ   -> あるセルから別のセルへのポインタ
- 葉ノード -> 子を持たないノード

#### 二分探索木
- 必ず二つの子を持つノードによって構成される木
  - 左の子は親より小さく、右の子は親より大きい
- 左右のバランスが崩れると計算量が増加するため、
平衡によって左右のバランスを保ち、探索の計算量を0(log n)に保つ必要がある
  - 平衡探索木
    - 要素の挿入・削除の操作自体が平衡状態を保証する
  - 赤黒木
    - ノードに赤・黒の色をつけることで平衡戦略をとる
  - AVL木
    - 平衡二分探索木の一種で赤黒木よりも高速
  - 二分ヒープ
    - 親が両子ノードよりも大きい要素を持つ二分探索木
    - 最大・最小の要素への操作に向いている

#### グラフ
- 親子の構造を持たない木

#### ハッシュ表
- 格納したいデータのキーを渡すと、ハッシュ関数によって要素の格納位置を決定する
- メモリ位置に対する操作ができるためO(1)で探索可能
- ハッシュ表の空きが少ない場合、格納するメモリアドレスが衝突するハッシュ衝突が起こる
- マップ・集合の実装に使われる

## Chapter5
- 代表的なアルゴリズム
  - ソート
  - 探索
  - グラフ操作
  - オペレーションズリサーチ

### ソート
- 選択ソート・挿入ソート -> O(n2)
- クイックソート         -> O(n log n)

### 探索
- 逐次探索 -> O(n)
- 二分探索 -> O(log n)

### グラフ
- 深さ優先探索
  - エッジに従いグラフを探索していく
  - 到達したノードに子がない場合、上のノードに戻り処理を実行する
  - スタックにノードをpushし、探索時にpopする
  - バックトラック戦略は深さ優先探索の流れで解を探索する
  - 幅優先探索より実装が単純で、メモリ消費量も少ない
- 幅優先探索
  - 開始ノードから隣のノードを探索していく
  - キューにノードをenqueueし、探索時にdequeueする

#### 経路探索における代表的なアルゴリズム
- ダイクストラのアルゴリズム

#### ページ探索における代表的なアルゴリズム
- ページランクアルゴリズム

### オペレーションズリサーチ
- 目的と制限のモデルを作成できる問題 -> 線形計画問題
  - シンプレックス法を用いて解く

## Chapter6
- DBにはリレーショナルDBと非リレーショナルDBがある
- 地図の類は地理DBを使用する
- DBは分散の仕組みが必要な場合がある
- システム間でデータを受け渡すためにデータシリアライゼーションを行う

#### リレーショナルDB・非リレーショナルDB
- リレーショナルDB
  - データは行(各レコード)と列(フィールド)からなるテーブルに保存される
  - スキーマ
    - フィールドとフィールドに格納できるデータ型の制限
  - 主キー
    - 表のIDフィールド
  - 外部キー
    - 別の表への参照が記録されるフィールド
  - スキーママイグレーション
    - スキーマの変更処理
  - インデックス作成
    - 行のIDからメモリ上の各アドレスへの対応づけを行う
    - 平衡二分木によって実装される
    - 一意性制約をもつフィールドに対して、インデックスを貼ることは一意性の検証のため有効
    - ソート済みの順序で行を取り出す際にも利用される
  - トランザクション
    - データの整合性を担保するために実装される
- 非リレーショナルDB
  - 大規模・揮発性・非構造のデータを素早く取り扱う
  - ドキュメントストア
  - キーバリューストア
  - グラフデータベース
  - ビッグデータ

#### 分散DB
- シングルマスターレプリケーション
  - 一台のマスターで複数のスレーブにクエリを均等に分散し、同期を保つ
- 多重マスターレプリケーション
  - 相互接続された全てのマシンをマスターとしてクエリを均等に分散し、同期を保つ
- シャーディング
  - 各マシンがDBの一部を所有する。クエリルータは担当のDBにクエリを渡す

#### シリアライゼーション
- SQL
- XML
- JSON
- CSV

## Chapter7
- コンピュータの主要構成要素はCPUとメモリ

### メモリ
- メモリは多くのセルから構成される
  - セルは微量のデータを保存する
  - セルはメモリアドレスを持つ
  - メモリのデータの読み書きは一度に一つのセルに対する操作で行われる
  - メモリは所定のセルのアドレスに対して、データを読み込むか書き込むかの操作を行う
- メモリはCPUからアドレスを受信するアドレスパスと、CPUとデータを相互にやり取りするデータパスを持つ

### CPU
- レジスタ(内部メモリセル)を持つ
  - CPUはレジスタに格納されたデータに対して演算を行う
  - レジスタとメモリ間でデータを交換する
- CPUはメモリから命令を読み出して実行することを無限に繰り返す
- CPUはプログラムカウンタレジスタによって示されるメモリアドレスの命令を取り出す
  - 命令を取り出すたびにPCレジスタを1進める
  - CPUはPCレジスタに新しい値を書き込み、分岐を指示できる

#### CPUクロック
- CPUの1秒あたりの実行サイクル

#### CPUアーキテクチャ
- CPUアーキテクチャの異なるコンピュータはそれぞれ別々のCPU命令セットを持つ

#### XX-bitアーキテクチャ
- 一つのCPU命令で最大XX桁の二進数に対して演算を行うことができる
- 2019年現在主流の64-bitアーキテクチャでは170億GB以上の二進数に対して操作が可能

#### ビッグエンディアン・リトルエンディアン
- ビッグエンディアン
  - CPUとメモリに数値を右から左へ格納する
- リトルエンディアン
  - CPUとメモリに数値を左から右へ格納する

#### エミュレータ
- あるコンピュータで別のCPUに書かれたプログラムを実行すること

### コンパイラ
- プログラミング言語で書かれた抽象度の高い命令を、コンピュータが演算するための単純な式に変換する
- チューリング完全の条件
  - メモリのデータを読み書きする
  - 条件分岐を実行する(所定の条件下でプログラムの別の位置に移動する)

#### OS
- プログラムはシステムコールを呼び出し、必要となる入出力をOSに依頼する
- コンパイラは入出力をOSに適したシステムコールに変換する

#### 最適処理
- コンパイラはコンパイル時にプログラムを最適に変換する

#### インタプリタ
- スクリプト言語はインタプリタによってソースコードを逐次実行する

#### 逆アセンブル
- コンパイル済みのソースコードを、人が読める一連の命令に変換する

### 記憶領域
- 記憶領域の容量が小さく、読み出し速度が早い順
  - レジスタ
  - L1キャッシュ
  - L2キャッシュ
  - メモリ
  - 記憶装置
  - 外部記憶装置
  - 第三次記憶装置

#### 局所性
- 時間的局所性
  - 同じメモリアドレスが高確率でアクセスされる
- 空間的局所性
  - 隣接するメモリアドレス同士が高確率でアクセスされる

#### スラッシング
- RAMを使い切ると、コンピュータが常に記憶装置からRAMにデータを取り込もうとするようになり、
コンピュータの性能が著しく落ちる

## Chapter8
### 言語学
- プログラミング言語の基本構成要素は以下
  - 値
  - 演算子
  - 式
    - リテラル
    - 関数
  - 文
    - 定義

### 変数
- 変数は名前と値の名前束縛
- 変数は型を持つ
  - 静的型付け
  - 動的型付け
  - 強い型付け
  - 弱い型付け
- 変数はスコープを持つ
  - あるコンテキストの内部で定義された変数は、実行の流れがそのコンテキストから離れると、
  即座に削除されメモリから解放される(グローバル変数を除く)

### パラダイム
- 命令型プログラミング
  - 特定の命令を使用して各段階で厳密に何をするのかをコンピュータに指示する
  - 各命令はコンピュータの状態を変更する
  - 機械語プログラミング
  - 構造型プログラミング
  - 手続き型プログラミング
- 宣言型プログラミング
  - 目的に到達するまでの手順を示さず、結果だけを宣言する
  - 関数型プログラミング
    - 変数に割り当てられた値は普遍(参照透過性)
- 論理型プログラミング
  - 問題の解が論理式である
  - プログラマは論理型のアサーションで論理の状態を表現
  - 提供されたモデルから回答を探すためにクエリが実行される
  - コンピュータは論理変数とクエリを解釈し、アサーションから解空間を構築し、
  これらすべてを満たすクエリ解を探索する
