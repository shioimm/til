# ネットワークはなぜつながるのか まとめ01
- 戸根勤 著

## 全体像
1. ブラウザがリクエストメッセージを作成する
2. ブラウザがDNSサーバーに名前解決を依頼する
  - DNSサーバーは送信先のWebサーバーのIPアドレスを調べる
3. ブラウザがプロトコルスタックにリクエストメッセージの送信を依頼する
4. プロトコルスタック(TCP担当部分)がソケットを作成する
5. プロトコルスタック(TCP/IP担当部分)が送信先のWebサーバーに接続する
6. プロトコルスタック(IP担当部分)がデータを送受信する
7. プロトコルスタックが接続を解除してソケットを抹消する


### 1. ブラウザがリクエストメッセージを作成する
- ブラウザはユーザーが指定したURLから
ユーザーが「何を」「どう」したいのかを表すリクエストメッセージを作成する
  - 「何を」 -> URL
  - 「どう」 -> HTTPメソッド
```
リクエストメッセージの構造

- リクエストライン
- メッセージヘッダ
- メッセージボディ(メソッドによっては省略される)
```

### 2. ブラウザがDNSサーバーに名前解決を依頼する
- リクエストメッセージはIPアドレス宛に送信されるため、
ブラウザは送信先のIPアドレスを取得する必要がある
- 送信先の確認のため、DNSにドメイン名とIPアドレスの名前解決を依頼する
```
ブラウザがIPアドレスを取得する手順

1. ブラウザがSocketライブラリの`gethostbyname`(DNSリゾルバ)を呼び出す
  - DNSリゾルバ -> DNSサーバーに対するクライアント(Socketの機能に含まれる)
    - Socket -> OS組み込みのネットワーク機能をアプリケーションから呼び出すライブラリ
2. リゾルバがDNSサーバーに対して名前解決を依頼するメッセージを作成する
  - メッセージはドメイン名、クラス(インターネット)、タイプを含む
3. リゾルバがOSのプロトコルスタックを呼び出し、メッセージ送信操作を依頼する
4. DNSサーバーがIPアドレスを格納した応答メッセージを返す
5. リゾルバが応答メッセージからIPアドレスを取り出し、ブラウザの指定するローカルのメモリ領域に保存する
6. ブラウザがメモリ領域からIPアドレスを取り出し、リクエストメッセージと共にOSに渡して送信を依頼する
```

#### TCP/IPの基礎
- ネットワークはサブネットをルーターで接続した集合
- サブネットは何台かのPCをハブで接続した集合
- IPアドレスは各コンピュータの住所
  - IPアドレス = ネットワーク番号(「x丁目」) + ホスト番号(「y番地」)
  - 32bitのデジタルデータを8bitずつ区切って10進数で表記する
    - ネットワーク番号とホスト番号の区切り(内訳)を表す情報 -> ネットマスク(IPアドレスの末尾に付加)
  - ホスト番号が全て0 -> サブネット全体を指す
  - ホスト番号が全て1 -> ブロードキャストを指す

### 3. ブラウザがOSのプロトコルスタックにリクエストメッセージの送信を依頼する
- ブラウザはリクエストメッセージの送信依頼のため、Socketライブラリを使用する
- ブラウザがSocketライブラリのsocketを呼び出す

#### データ送受信操作の流れ
1. ソケットを作る
2. サーバー側のソケットにパイプをつなぐ
3. データを送受信する
4. パイプを外してソケットを抹消する

#### プロトコルスタック(ネットワーク制御用ソフトウェア)
```
プロトコルスタックの内部構成

- TCP -> コネクションを使用してデータの送受信を行う
- UDP -> コネクションを使用せずデータの送受信を行う
- IP  -> パケット送受信動作をコントロールする
  - ICMP -> パケット送受信時のエラーの通知 / 制御用メッセージの通知
  - ARP  -> 送信先ルーターのMACアドレスを調べる
```

### 4. プロトコルスタック(TCP担当部分)がソケットを作成する
```
ソケット作成の手順

1. ブラウザがSocketライブラリのsocketを呼び出す
2. プロトコルスタック(TCP担当部分)がソケット一つ分のメモリ領域を確保する
3. プロトコルスタック(TCP担当部分)が通信のために必要な制御情報の初期値をメモリに記録する
4. socketが作成されたソケットのディスクリプタをブラウザに返す
  - ディスクリプタ -> 個々のソケットを一意に識別するフラグ
5. ブラウザはディスクリプタをメモリに保存する
```
- ソケットの実体は通信制御用の制御情報

#### 制御情報の種類
- TCPヘッダに書き込まれる情報
  - クライアント <-> サーバー間で連絡を取り合うために使用される
  - パケットの先頭に付加される
- ソケットに記録される情報
  - プロトコルスタックの動作を制御するために使用される
  - プロトコルスタックのメモリ領域に記録される

### 5. プロトコルスタック(TCP/IP担当部分)が送信先のWebサーバーに接続する
```
接続の手順

1. ブラウザがSocketライブラリのconnectを呼び出す
  - 引数にディスクリプタと送信先のIPアドレス / ポート番号を渡す
2. connectがプロトコルスタックを呼び出し、接続操作を依頼する
  - TCP担当部分が接続先のTCP担当部分とやりとりを行い、
    TCPヘッダの送信元と宛先のポート番号から接続に利用するソケットを特定する
  - コントロールビットのSYNを1にする
3. プロトコルスタックが接続操作を行い、送信先の制御情報をソケットに記録する
  - IP担当部分がサーバーに対して送信動作を行う
  - サーバー側のIP担当部分がコントロールビットのACKを1にしたTCPヘッダと共にレスポンスを返す
4. プロトコルスタックがコントロールビットのACKを1にしたTCPヘッダをサーバーに送り返す
5. コネクションが確立
```
- コネクションはデータ送受信動作中存在し続ける

### 6. プロトコルスタック(IP担当部分)がデータを送受信する
```
データ送信の手順

1. ブラウザがSocketライブラリのwriteを呼び出す
  - 引数にディスクリプタとリクエストメッセージを渡す
2. writeがプロトコルスタックを呼び出し、送信操作を依頼する
  - プロトコルスタックはメッセージの内容を把握しない
  - プロトコルスタックはメッセージが送信可能なデータ量を満たすまで、メッセージを送信バッファに格納する
    - MTU -> パケットあたり送信できるデータの最大長
    - MSS -> TCPのデータの最大長
  - プロトコルスタックはメッセージのデータが大きい時はMTUのサイズに分割する
3. プロトコルスタック(IP担当部分)が送信先のWebサーバーにメッセージを送信する
4. プロトコルスタック(TCP担当部分)がシーケンス番号とACK番号を利用し、パケットがサーバー側に届いたことを確認する
```

```
データ受信の手順
1. ブラウザがSocketライブラリのreadを呼び出す
2. プロトコルスタックが送信先のWebサーバーからメッセージを受信する
3. プロトコルスタックが受信したデータ断片とTCPヘッダの内容を調べて、データの抜け漏れを確認する
4. プロトコルスタックがACK番号をサーバー側に送り返す
5. プロトコルスタックが受信したデータ断片を受信バッファ(ブラウザが指定したメモリ領域)に格納する
6. プロトコルスタックが受信したデータ断片をレスポンスメッセージとして復元しブラウザに渡す
```

### 7. プロトコルスタックが接続を解除してソケットを抹消する
- サーバーはレスポンスメッセージ送信後、Socketライブラリのcloseを呼び出し切断動作を行う
  - サーバー側のプロトコルスタックがTCPヘッダにコントロールビットFIN=1を設定する
  - サーバー側のプロトコルスタックがサーバー側のソケットに切断動作の情報を書き込む
  - クライアント側のプロトコルスタックがサーバー側のプロトコルスタックからTCPヘッダを受け取り、ACK番号を送り返す
- ブラウザがreadを呼び出し受信動作を行った際、raadは受信メッセージの代わりに切断状態をブラウザへ通知する
- ブラウザも以下の切断フェーズに入る
```
切断の手順

1. ブラウザがSocketライブラリのcloseを呼び出す
2. closeがプロトコルスタックを呼び出し、切断動作を依頼する
3. プロトコルスタックがソケットを抹消する
  - 誤動作を防ぐため、しばらく待機してからソケットを抹消する
```
