# TLS
- SSL(Secure socket layer)
  - クライアント-サーバー間で間で機密情報を送信するため、インターネット接続を安全に行う技術
- TLS(Transport layer security)
  - より安全なSSLの上位互換バージョン
- HTTPS (Hyper text transfer Protocol SECURE)
  - SSL/TLSで保護されたデータの転送に使用されるHTTPプロトコル(HTTP + SSL/TLS)

## 特徴
- [OSI参照モデル]セッション層で動作し、アプリケーション層のプロトコルと組み合わせて使用される
- [TCP/IPプロトコル]アプリケーション層で実装され、TCPの直接の上位層で動作する
  - アプリケーション層の動作に影響を与えることなくネットワーク通信時の安全性を提供する
- 433番ポートで受信したデータは暗号化されているとみなされ、
  受信側のSSLサーバーにて復号してアプリケーションに渡される
- 最も広く使用されているSSLライブラリはOpenSSL
  - その他LibreSSL、GnuTLS、NSS

### TLSが提供する機能
- ハイブリッド暗号方式による情報の内容の暗号化(盗聴対策)
- MAC関数による改竄検知(改竄対策)
- デジタル署名による通信相手の認証(なりすまし対策 / 否認対策)

## TLS通信の仕組み
- ハンドシェイク + データ転送

### ハンドシェイクで実行すること
1. 暗号化アルゴリズムの合意
2. サーバーの認証
3. データ転送で使用する鍵の確立
4. ハンドシェイクが正しく行われたことの確認

### 通信フロー
1. クライアント -> サーバー
    - 暗号化鍵とMAC鍵の生成に用いる乱数を生成
    - クライアントが対応している暗号化スイートのリストと生成した乱数を送付
      - SSLのバージョン
      - サーバー認証アルゴリズム
      - データ転送で使用するデータ保護用の共通鍵暗号方式アルゴリズム
      - データ転送で使用するデータの完全性を確認するためのMACアルゴリズム
      - 圧縮アルゴリズム
2. サーバー -> クライアント
    - 暗号化鍵とMAC鍵の生成に用いる乱数を生成
    - 使用するアルゴリズムの合意、サーバーの公開鍵を含む証明書、生成した乱数を送付
3. クライアント
    - サーバーの証明書を確認
    - ランダムな文字列を生成し、2つの乱数と鍵生成関数を使用して暗号化鍵とMAC鍵を生成
    - 暗号化鍵とMAC鍵を生成するために使用したランダムな文字列をサーバーの公開鍵で暗号化
4. クライアント -> サーバー
    - 暗号化されたランダムな文字列を送付
5. サーバー
    - 暗号化されたランダムな文字列を自身の秘密鍵で複合
    - クライアントと同じ鍵生成関数を使用し、2つの乱数とランダムな文字列から暗号化鍵とMAC鍵を生成
6. クライアント / サーバー(ハンドシェイクの終了確認)
    - 互いに合意したMACアルゴリズムと生成したMAC鍵でMACを取得
    - 互いに合意した暗号化アルゴリズムと生成した暗号化鍵でMACを暗号化し、送付
    - 互いに受信したデータに対し、自ら生成した暗号化鍵で復号化したMACと自ら生成したMACが等しいことを確認
7. クライアント / サーバー(データ転送)
    - ハンドシェイク完了後はフラグメントに分割されたデータをそれぞれ暗号化して送付
    - フラグメントごとに検証用のヘッダとMACを付加する
    - ヘッダにはSSLのバージョン、Content-Type、Content-Lengthを含む

## TLS通信の構築
### 構築要素
- サーバー証明書(接続先が意図したドメイン名のサイトかどうかを保証するもの)
- 公開鍵・秘密鍵(暗号化・復号化のキー)
- 暗号化アルゴリズム(暗号化・復号化のルール)
- SSLライブラリ(SSLプロトコルを実現する暗号化・復号化ライブラリ)

## TLSレコードプロトコル
- 最大レコードサイズは16KB
- 各レコードは5バイトのヘッダ、32バイトのMAC、ブロック暗号利用時はパッディングが付与される
- 暗号を解読してレコードを検証するためにはレコード全体が必要となる

### データ転送ワークフロー
1. 送信ピアでレコードプロトコルがアプリケーションデータを受信
2. 受信データがブロックに分割される(レコードあたり16KB)
3. アプリケーションデータが圧縮される(オプション)
4. MACまたはHMACが追加される
5. ネゴシエートされた暗号化方式でデータが暗号化される
6. データがTCP層へ渡される
7. 受信ピアで`1`~`6`までのフローが逆向きに適用される

## TLSハンドシェイク
- TLSを使ったデータの交換の前にクライアント・サーバー間に暗号化されたトンネルを確立する

### フロー
1. TCPの3wayハンドシェイクを実行し、クライアント・サーバー間にコネクションを確立する
2. クライアント -> サーバー
    - 動作仕様(TLSプロトコルバージョン、暗号スイートのリスト、TLSオプションetc)を平文で送信する
3. サーバー -> クライアント
    - 動作仕様の選択とサーバー証明書を送信する
    - オプションとしてクライアント証明書とTLS拡張パラメータの要求を送信できる
4. クライアント -> サーバー
    - TLSバージョンと暗号スイートに合意し、サーバー証明書受け入れる
    - DH鍵交換プロセスを開始し、共通鍵の生成に利用する
5. サーバー -> クライアント
    - 鍵交換パラメータを処理し、MACを検証することでメッセージの整合性を確認する
    - 暗号化された`Finished`メッセージを送信する
6. クライアント -> サーバー
    - ネゴシエートされた共通鍵を使ってメッセージを復元し、MACの検証を行う
    - 問題がなければトンネルが確立する

## ALPN
- Application-Layer Protocol Negotiation
- アプリケーションプロトコルネゴシエーションのサポートをTLSハンドシェイクに導入するTLS拡張機能
- 443番ポートとTLSハンドシェイクを利用して任意のアプリケーションプロトコルを使用することができる

### フロー
1. クライアント -> サーバー
    - ClientHelloメッセージにProtocolNameListフィールドを付加して送信する
    - ProtocolNameList - サポートするアプリケーションプロトコルのリスト
2. サーバー -> クライアント
    - ProtocolNameListを検証し、ServerHelloメッセージにProtocolNameフィールドを付加して送信する
    - ProtocolName - 選択したプロトコル

### SNI
- Server Name Indication
- 一つのホストが複数のドメイン名を持つ時、ドメイン単位でサーバー証明書を利用することができるTLS拡張

#### フロー
1. クライアント -> サーバー
    - ハンドシェイクの開始時、接続するホスト名を提示する
2. サーバー -> クライアント
    - 提示されたホスト名を検証し、適切な証明書を選び、ハンドシェイクを続行する

## HTTP/2における仕様
- TLS1.2以上
- TLS SNIのサポート
- 圧縮機能無効化 -> HTTP/2自身が圧縮を行う
- 再ネゴシエーション禁止 -> クライアント証明書の要求はコネクションプリフェイス前に実行される必要がある
- 暗号スイート
  - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`をサポート
  - 仕様で禁止されている暗号スイートの使用禁止

### 暗号スイートの条件が合わない場合
- `INADEQUEATE_SECURITY`エラーコネクションによって切断される場合がある -> コネクションエラー
  - ALPNネゴシエーションと暗号スイートの選択が独立して行われるため、
    暗号スイートの条件が一致しない場合がある

## 参照
- [How is data secure over https?](https://blog.joshsoftware.com/2019/08/23/how-is-data-secure-over-https/)
- よくわかるHTTP/2の教科書P18-20/124-125
- SSLをはじめよう ～「なんとなく」から「ちゃんとわかる！」へ～
- [図解で学ぶネットワークの基礎：SSL編](https://xtech.nikkei.com/it/article/COLUMN/20071002/283518/)
- ハイパフォーマンスブラウザネットワーキング
- 食べる！SSL！　―HTTPS環境構築から始めるSSL入門
