# SSL/TLS
- SSL(Secure socket layer)
  - クライアント-サーバー間で間で機密情報を送信するため、インターネット接続を安全に行う技術
- TLS(Transport layer security)
  - より安全なSSLの上位互換バージョン
- HTTPS (Hyper text transfer Protocol SECURE)
  - SSL/TLSで保護されたデータの転送に使用されるHTTPプロトコル(HTTP + SSL/TLS)

#### 目標
1. 暗号学的なセキュリティ(Cryptographic security)
    - 情報を交換しようとする二者間で安全な通信ができるようにする
2. 相互運用性(Interoperability)
    - 独立して開発されたプログラム間でも同じパラメータを使って暗号通信ができるようにする
3. 拡張性(Extensibility)
    - フレームワークとして提供することによりプロトコルは変更せず個別の新しい要素技術に対応できるようにする
4. 効率性(Efficiency)
    - コストがかかる暗号処理を最小限にし、後続のセッションでの再計算を避けるキャッシュ方式を用意する

## 特徴
- [OSI参照モデル]セッション層で動作し、アプリケーション層のプロトコルと組み合わせて使用される
- [TCP/IPプロトコル]アプリケーション層で実装され、TCPの直接の上位層で動作する
  - アプリケーション層の動作に影響を与えることなくネットワーク通信時の安全性を提供する
- 433番ポートで受信したデータは暗号化されているとみなされ、
  受信側のSSLサーバーにて復号してアプリケーションに渡される
- 最も広く使用されているSSLライブラリはOpenSSL
  - その他LibreSSL、GnuTLS、NSS

### TLSが提供する機能
- 盗聴対策 - ハイブリッド暗号方式による情報の内容の暗号化
- 改竄対策 - MAC関数による改竄検知
- なりすまし対策 / 否認対策 - デジタル署名による通信相手の認証

## プロトコルの階層
- TLS Record + TLS Handshake(Handshake + ChangeCipherSpec + Alert + アプリケーションデータプロトコル)

### TLS Recordプロトコル
- TLS Handshakeプロトコルの下位プロトコル
- メッセージの圧出、暗号化、データの認証を行う
  - 共通鍵暗号(ハイブリッド暗号)とMACを使用する
  - 使用する共通鍵・アルゴリズムはHandshakeプロトコルレイヤーでネゴシエーションを行うことによって決定される

#### 動作フロー
1. メッセージを複数の小さなフラグメントに分割し圧縮
    - 圧縮アルゴリズムはネゴシエーションで決定する
2. フラグメントにMACを付加
    - ハッシュ関数アルゴリズムと共通鍵はネゴシエーションで決定する
3. 圧縮したフラグメントとMACを合わせて暗号化(CBCモード)
  　- 暗号化アルゴリズムと共通鍵はネゴシエーションで決定する
4. `3`にヘッダ(データタイプ・バージョン番号・圧縮した長さ)を追加して送信

### TLS Handshakeプロトコル
- TLS Recordプロトコルの上位プロトコル

#### 動作フロー
1. クライアント -> サーバー: ClientHello
    - 使用できるバージョン番号、現在時刻、クライアントランダム、セッションID、
      使用できる暗号スイート一覧、使用できる圧縮方法一覧を送信
2. サーバー -> クライアント: ServerHello
    - 使用するバージョン番号、現在時刻、サーバーランダム、セッションID、
      使用する暗号スイート、使用する圧縮方法を送信
3. サーバー -> クライアント: Certificate
    - 証明書リストを送信
    - クライアントは証明書リストを検証する
4. サーバー -> クライアント: ServerKeyExchange(optional)
    - 使用する暗号スイートの内容によって必要な場合、追加の情報を送信
5. サーバー -> クライアント: CertificateRequest(optional)
    - クライアント認証を行う場合、サーバーが理解できる証明書のタイプ・認証局の名前一覧を送信
6. サーバー -> クライアント: ServerHelloDone
7. クライアント -> サーバー: Certificate(optional)
    - クライアント認証を行う場合、証明書を送信
    - サーバーは証明書を検証する
8. クライアント -> サーバー: ClientKeyExchange
    - 暗号スイートがRSAを用いる場合、暗号化したプリマスターシークレット(乱数)を送信
    - 暗号スイートがDH鍵交換を用いる場合、Diffie-Hellman公開値を送信
    - サーバーとクライアントはプリマスターシークレットを用いてマスターシークレットを計算
    - サーバーとクライアントマスターシークレットを用いて共通鍵暗号の鍵・MACの鍵・初期化ベクトルの一部を作成
9. クライアント -> サーバー: CertificateVerify
    - クライアント認証を行う場合、クライアント証明書の秘密鍵を持っていることを通知
10. クライアント -> サーバー: ChangeCipherSpec
11. クライアント -> サーバー: Finished
12. サーバー -> クライアント: ChangeCipherSpec
13. サーバー -> クライアント: Finished
14. アプリケーションデータプロトコルへ移行
15. Alertによって異常の発生を通信相手に通知する
166. AlertによってSSL/TLSの終了を伝え、SSL/TLSセッションを終了する

#### Handshakeプロトコル
- クライアント・サーバー間でアルゴリズムと共通鍵のネゴシエーションを行うプロトコル

#### ChangeCipherSpecプロトコル
- Handshakeプロトコルによるネゴシエーションの合意後、暗号通信への切り替え通知を行うプロトコル

#### Alertプロトコル
- 異常通知のためのプロトコル

#### アプリケーションデータプロトコル
- TLSの上位レイヤーであるアプリケーションのデータを通信相手に伝えるプロトコル

#### マスターシークレット(鍵素材)
- クライアント・サーバー間で合意した鍵
- プリマスターシークレット + クライアントランダム + サーバーランダムの値から計算する
  - クライアントランダム + サーバーランダムはソルトの役割を果たす
  - 暗号スイートで決められたハッシュ関数で作った擬似乱数生成関数で計算する
- 共通鍵暗号の鍵・MACの鍵・初期化ベクトルの一部を生成する
  - 共通鍵暗号の鍵(クライアント -> サーバー)
  - 共通鍵暗号の鍵(サーバー -> クライアント)
  - MACの鍵(クライアント -> サーバー)
  - MACの鍵(サーバー -> クライアント)
  - GCMモードやCCMモードで用いる初期化ベクトルの一部(クライアント -> サーバー)
  - GCMモードやCCMモードで用いる初期化ベクトルの一部(サーバー -> クライアント)

## HTTP/2における仕様
- TLS1.2以上
- TLS SNIのサポート
- 圧縮機能無効化 -> HTTP/2自身が圧縮を行う
- 再ネゴシエーション禁止 -> クライアント証明書の要求はコネクションプリフェイス前に実行される必要がある
- 暗号スイート
  - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`をサポート
  - 仕様で禁止されている暗号スイートの使用禁止

### 暗号スイートの条件が合わない場合
- `INADEQUEATE_SECURITY`エラーコネクションによって切断される場合がある -> コネクションエラー
  - ALPNネゴシエーションと暗号スイートの選択が独立して行われるため、
    暗号スイートの条件が一致しない場合がある

## 参照
- [How is data secure over https?](https://blog.joshsoftware.com/2019/08/23/how-is-data-secure-over-https/)
- よくわかるHTTP/2の教科書P18-20/124-125
- SSLをはじめよう ～「なんとなく」から「ちゃんとわかる！」へ～
- [図解で学ぶネットワークの基礎：SSL編](https://xtech.nikkei.com/it/article/COLUMN/20071002/283518/)
- ハイパフォーマンスブラウザネットワーキング
- 食べる！SSL！　―HTTPS環境構築から始めるSSL入門
- 暗号技術入門 第3版
