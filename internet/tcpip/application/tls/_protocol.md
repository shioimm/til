# プロトコルの階層
- TLS Record + TLS Handshake(Handshake + ChangeCipherSpec + Alert + アプリケーションデータプロトコル)

## TLS Recordプロトコル
- メッセージの圧出、暗号化、転送、認証を行う
  - 共通鍵暗号(ハイブリッド暗号)とMACを使用する
  - 使用する共通鍵・アルゴリズムはHandshakeプロトコルレイヤーでネゴシエーションを行うことによって決定される
  - その他の機能はサブプロトコルによって行う

#### 動作フロー
1. メッセージを複数の小さなフラグメントに分割し圧縮
    - 圧縮アルゴリズムはネゴシエーションで決定する
2. フラグメントにMACを付加
    - ハッシュ関数アルゴリズムと共通鍵はネゴシエーションで決定する
3. 圧縮したフラグメントとMACを合わせて暗号化(CBCモード)
  　- 暗号化アルゴリズムと共通鍵はネゴシエーションで決定する
4. `3`にヘッダ(データタイプ・バージョン番号・圧縮した長さ)を追加して送信

#### TLSレコード定義
- TLSレコード = ヘッダ + メッセージデータ
  - ヘッダ - コンテントタイプ・プロトコルバージョン・レコード長
- 最大レコードサイズは16KB
  - 16KBよりも大きいバッファは小さなチャンクへと分割される
  - 16KBよりも小さいバッファは複数のバッファから単一のレコードにまとめられる
  - 各レコードは5バイトのヘッダ、32バイトのMAC、ブロック暗号利用時はパディングが付与される
- 暗号を解読してレコードを検証するためにはレコード全体が必要となる

```c
struct {
  uint8 major;
  uint8 minor;
} ProtocolVersion;

enum {
  change_cipher_spec (20),
  alert              (21),
  handshake          (22),
  application_data   (23)
} ContentType;

struct {
  ContentType     type;
  ProtocolVersion version;
  uint16          length;                         // 最長 2^14 (16,384) バイト
  opaque          fragment[TLSPlaintext.length];  // 書式が定まっていない(opaque)データのバッファ
} TLSPlaintext;

// その他に64ビットのシーケンス番号が割り当てられる
```

## TLS Handshakeプロトコル
- TLS Recordプロトコルの上位プロトコル

### Handshakeプロトコル
- クライアント・サーバー間でアルゴリズムと共通鍵のネゴシエーションを行うプロトコル

#### 役割
1. 双方のピアが接続で使いたいパラメータを提示し、互いに合意する
2. 提示された証明書か他の方法を使って認証を行う
3. セッションの保護に使うマスターシークレット(master secret)を共有する
4. ハンドシェイクのメッセージ群が第三者によって書き換えられていないことを検証する

#### Handshakeレコード定義
```c
struct {
   HandshakeType    msg_type; // メッセージの種類
   uint24           length;   // メッセージの長さ
   HandshakeMessage message;
} Handshake;

// メッセージの残りの部分はメッセージの種類によって異なる
```

#### マスターシークレット(鍵素材)
- クライアント・サーバー間で合意した鍵
- プリマスターシークレット + クライアントランダム + サーバーランダムの値から計算する
  - クライアントランダム + サーバーランダムはソルトの役割を果たす
  - 暗号スイートで決められたハッシュ関数で作った擬似乱数生成関数で計算する
```
master_secret = PRF(pre_master_secret, "master secret", client_random + server_random)
```

- マスターシークレットから鍵ブロック(通鍵暗号の鍵・MACの鍵・初期化ベクトル)を生成する
  - 共通鍵暗号の鍵(クライアント -> サーバー)
  - 共通鍵暗号の鍵(サーバー -> クライアント)
  - MACの鍵(クライアント -> サーバー)
  - MACの鍵(サーバー -> クライアント)
  - GCMモードやCCMモードで用いる初期化ベクトルの一部(クライアント -> サーバー)
  - GCMモードやCCMモードで用いる初期化ベクトルの一部(サーバー -> クライアント)
```
key_block = PRF(master_secret, "key expansion", server_random + client_random)
```

### ChangeCipherSpecプロトコル
- Handshakeプロトコルによるネゴシエーションの合意後、暗号通信への切り替え通知を行うプロトコル
- ハンドシェイク中に双方のピアから送信されるChangeCipherSpecメッセージを定義する

### Alertプロトコル
- 異常通知・接続終了のためのプロトコル
- 通信中の相手に例外的な状況を伝える

#### Alertレコード定義
```c
struct {
  AlertLevel level;
  AlertDescription description;
} Alert;

// 接続終了時はどちらかのピアがclose_notifyアラートを送信する
```

### アプリケーションデータプロトコル
- TLSの上位レイヤーであるアプリケーションのデータを通信相手に伝えるプロトコル
- アプリケーションのデータはセキュリティパラメータに従い、
  Recordプロトコルのレイヤーでパッケージ化、細分化、暗号化される

## ハンドシェイク
### 種類
- 認証を伴うフルハンドシェイク
- 前回のセッションを再開するセッションリザンプション
- クライアントとサーバの認証を伴うハンドシェイク

### フルハンドシェイク
- クライアント・サーバーがそれ以前にセッションを確立したことがない場合、フルハンドシェイクを実行する必要がある
1. クライアント -> サーバー: ClientHello
    - 使用できるバージョン番号、現在時刻、クライアントランダム、セッションID(初期値はNULL)、
      使用できる暗号スイート一覧、使用できる圧縮方法一覧を送信
    - ClientHelloは新規にコネクションを開始するとき、再ネゴシエーションするとき、
      サーバーからの再ネゴシエーションの要求(HelloRequest)に応えるときに送信される
2. サーバー -> クライアント: ServerHello
    - 使用するバージョン番号、現在時刻、サーバーランダム、セッションID(サーバーが生成した値)、
      使用する暗号スイート、使用する圧縮方法を送信
3. サーバー -> クライアント: Certificate
    - X.509証明書チェーンを送信(X.509証明書以外の形式でも可)
    - チェーンの先頭はサーバー証明書、その次に中間証明書、末尾にルート証明書がつくがルート証明書は不要なので省くべき
    - クライアントはX.509証明書チェーンを検証する
4. サーバー -> クライアント: ServerKeyExchange(optional)
    - 使用する暗号スイートの内容によって必要な場合、追加の情報を送信
5. サーバー -> クライアント: CertificateRequest(optional)
    - クライアント認証を行う場合、サーバーが理解できる証明書のタイプ・認証局の名前一覧を送信
6. サーバー -> クライアント: ServerHelloDone
7. クライアント -> サーバー: Certificate(optional)
    - クライアント認証を行う場合、証明書を送信
    - サーバーは証明書を検証する
8. クライアント -> サーバー: ClientKeyExchange
    - 暗号スイートがRSAを用いる場合、暗号化したプリマスターシークレット(乱数)を送信
    - 暗号スイートがDH鍵交換を用いる場合、Diffie-Hellman公開値を送信
    - サーバーとクライアントはプリマスターシークレットを用いてマスターシークレットを計算
    - サーバーとクライアントマスターシークレットを用いて共通鍵暗号の鍵・MACの鍵・初期化ベクトルの一部を作成
9. クライアント -> サーバー: CertificateVerify
    - クライアント認証を行う場合、クライアント証明書の秘密鍵を持っていることを通知
10. クライアント -> サーバー: ChangeCipherSpec
11. クライアント -> サーバー: Finished
    - `verify_data`フィールドを含む
12. サーバー -> クライアント: ChangeCipherSpec
13. サーバー -> クライアント: Finished
    - `verify_data`フィールドを含む
14. アプリケーションデータプロトコルへ移行
15. Alertによって異常の発生を通信相手に通知する
166. AlertによってSSL/TLSの終了を伝え、SSL/TLSセッションを終了する

#### `verify_data`
- クライアントとサーバがそれぞれ受信したハンドシェイクメッセージのすべてをハッシュ化したもの、
  `finished_label`(クライアントは`client finished`、サーバーは`server finished`)、
  マスターシークレットを組み合わせて擬似乱数生成器にかけて計算したもの

```
verify_data = PRF(master_secret, finished_label, Hash(handshake_messages))
```

- Finishedメッセージは暗号化されており、ネゴシエーション済みのMACによって真正性が保証されている

### セッションリザンプション
- 一意のSession IDを使ってセッションの再開を可能にする仕組み
- Session IDはサーバーからクライアントへ、ServerHelloを利用して送信される
- クライアントとサーバーはフルハンドシェイクによって確立した接続の終了後、Session IDを一定期間保持する
1. クライアント -> サーバー: ClientHello
    - セッションを再開する場合、 ClientHelloメッセージに適切なSession IDを含めて送信
2. サーバー -> クライアント: ServerHello
    - 当該セッションを再開する場合、同じSession IDをServerHelloメッセージに含めて送信
3. サーバー -> クライアント: [ChangeCipherSpec]
    - 以前共有したマスターシークレットを使って新しい暗号鍵(暗号化に使う鍵やMAC鍵)を生成
    - サーバー側で暗号通信に切り替え、その旨をクライアントに送信
4. サーバー -> クライアント: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信
5. クライアント -> サーバー: [ChangeCipherSpec]
    - 以前共有したマスターシークレットを使って新しい暗号鍵(暗号化に使う鍵やMAC鍵)を生成
    - クライアント側で暗号通信に切り替え、その旨をサーバーに送信
6. クライアント -> サーバー: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信

## 参照
- プロフェッショナルSSL/TLS
- 暗号技術入門 第3版
