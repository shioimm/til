# Recordプロトコル
- Recordプロトコルはデータ転送と暗号処理を行う
  - その他の機能はサブプロトコルで行われる
    - Handshakeプロトコル - TLS接続で使うパラメータのネゴシエーションと認証を行う
    - Change Cipher Specプロトコル
    - Application Dataプロトコル
    - Alertプロトコル

## TLSレコード
- TLSレコード = ヘッダ + メッセージデータ
  - ヘッダ - コンテントタイプ・プロトコルバージョン・レコード長
- 最大レコードサイズは16KB
  - 16KBよりも大きいバッファは小さなチャンクへと分割される
  - 16KBよりも小さいバッファは複数のバッファから単一のレコードにまとめられる
  - 各レコードは5バイトのヘッダ、32バイトのMAC、ブロック暗号利用時はパディングが付与される
- 暗号を解読してレコードを検証するためにはレコード全体が必要となる

```c
struct {
  uint8 major;
  uint8 minor;
} ProtocolVersion;

enum {
  change_cipher_spec (20),
  alert              (21),
  handshake          (22),
  application_data   (23)
} ContentType;

struct {
  ContentType     type;
  ProtocolVersion version;
  uint16          length;                         // 最長 2^14 (16,384) バイト
  opaque          fragment[TLSPlaintext.length];  // 書式が定まっていない(opaque)データのバッファ
} TLSPlaintext;

// その他に64ビットのシーケンス番号が割り当てられる
```

## サブプロトコル
### Handshakeプロトコル
#### 役割
1. 双方のピアが接続で使いたいパラメータを提示し、互いに合意する
2. 提示された証明書か他の方法を使って認証を行う
3. セッションの保護に使うマスターシークレット(master secret)を共有する
4. ハンドシェイクのメッセージ群が第三者によって書き換えられていないことを検証する

```c
struct {
   HandshakeType    msg_type; // メッセージの種類
   uint24           length;   // メッセージの長さ
   HandshakeMessage message;
} Handshake;
```

#### 種類
- 認証を伴うフルハンドシェイク
- 前回のセッションを再開するセッションリザンプション
- クライアントとサーバの認証を伴うハンドシェイク

#### フルハンドシェイク
1. クライアント -> サーバー: ClientHello
    - 新規のハンドシェイクを開始
    - 希望の暗号スイートや鍵交換の方法などを送信
2. サーバー -> クライアント: ServerHello
    - サーバーがパラメータを決定
3. サーバー -> クライアント: Certificate
    - 自身の証明書チェーンを送信(サーバ認証が必要な場合)
4. サーバー -> クライアント: ServerKeyExchange
    - マスターシークレットの生成に必要な情報を送信(ある場合)
5. サーバー -> クライアント: ServerHelloDone
    - ネゴシエーションにおけるサーバーからの送信が終わったことを送信
    - サーバーはクライアントからのメッセージ送信を待機
6. クライアント -> サーバー: ClientKeyExchange
    - マスターシークレットの生成に必要な情報を送信
7. クライアント -> サーバー: [ChangeCipherSpec]
    - クライアント側で暗号通信に切り替え、その旨をサーバーに送信
8. クライアント -> サーバー: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信
    - Finishedメッセージは暗号化されており、ネゴシエーション済みのMACによって完全性が保証される
9. サーバー -> クライアント: [ChangeCipherSpec]
    - サーバー側で暗号通信に切り替え、その旨をクライアントに送信
10. サーバー -> クライアント: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信

#### セッションリザンプション
- 一意のSession IDを使ってセッションの再開を可能にする仕組み
- Session IDはサーバーからクライアントへ、ServerHelloを利用して送信される
- クライアントとサーバーはフルハンドシェイクによって確立した接続の終了後、Session IDを一定期間保持する
1. クライアント -> サーバー: ClientHello
    - セッションを再開する場合、 ClientHelloメッセージに適切なSession IDを含めて送信
2. サーバー -> クライアント: ServerHello
    - 当該セッションを再開する場合、同じSession IDをServerHelloメッセージに含めて送信
3. サーバー -> クライアント: [ChangeCipherSpec]
    - 以前共有したマスターシークレットを使って新しい暗号鍵(暗号化に使う鍵やMAC鍵)を生成
    - サーバー側で暗号通信に切り替え、その旨をクライアントに送信
4. サーバー -> クライアント: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信
5. クライアント -> サーバー: [ChangeCipherSpec]
    - 以前共有したマスターシークレットを使って新しい暗号鍵(暗号化に使う鍵やMAC鍵)を生成
    - クライアント側で暗号通信に切り替え、その旨をサーバーに送信
6. クライアント -> サーバー: Finished
    - 送信および受信したハンドシェイクメッセージのMACを送信

### Change Cipher Specプロトコル
- ハンドシェイク中に双方のピアから送信されるChangeCipherSpecメッセージを定義するプロトコル

### Application Dataプロトコル
- アプリケーションのデータを運ぶプロトコル
- アプリケーションのデータはセキュリティパラメータに従い、
  Recordプロトコルのレイヤーでパッケージ化、細分化、暗号化される

### Alertプロトコル
- 通信中の相手に例外的な状況を伝えるプロトコル

## 参照
- プロフェッショナルSSL/TLS
