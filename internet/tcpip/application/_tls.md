# TLS
- SSL(Secure socket layer)
  - クライアント-サーバー間で間で機密情報を送信するため、インターネット接続を安全に行う技術
- TLS(Transport layer security)
  - より安全なSSLの上位互換バージョン
- HTTPS (Hyper text transfer Protocol SECURE)
  - SSL/TLSで保護されたデータの転送に使用されるHTTPプロトコル(HTTP + SSL/TLS)

## 特徴
### プロトコル
- セッション層
- アプリケーション層で実装され、TCPの直接の上位層で動作する
  - アプリケーション層の動作に影響を与えることなくネットワーク通信時の安全性を提供する
- 433番ポートで受信したデータは暗号化されているとみなされ、
  受信側のSSLサーバーにて復号してアプリケーションに渡される

### TLSが提供するサービス
- 暗号化 - メッセージの内容を見えなくする
- 認証 - 提供された証明書の正当性を検証する
- データ整合性 - メッセージの改竄・偽造を検出する

#### TLSハンドシェイクが提供するサービス
- 本人性 - ピアのがなりすましのユーザーではないことを証明する

### TLSによる通信の特性
- 機密性 - データを第三者に見られない(暗号化)
- 完全性 - データが改ざんされない(改ざんの検知)
- 真正性 - 通信相手が正しい相手である(証明書)

## TLSハンドシェイク
- TLSを使ったデータの交換の前にクライアント・サーバー間に暗号化されたトンネルを確立する

### フロー
1. TCPの3wayハンドシェイクを実行し、クライアント・サーバー間にコネクションを確立する
2. クライアント -> サーバー
    - 動作仕様(TLSプロトコルバージョン、暗号スイートのリスト、TLSオプションetc)を平文で送信する
3. サーバー -> クライアント
    - 動作仕様の選択とサーバー証明書を送信する
    - オプションとしてクライアント証明書とTLS拡張パラメータの要求を送信できる
4. クライアント -> サーバー
    - TLSバージョンと暗号スイートに合意し、サーバー証明書受け入れる
    - DH鍵交換プロセスを開始し、共通鍵の生成に利用する
5. サーバー -> クライアント
    - 鍵交換パラメータを処理し、MACを検証することでメッセージの整合性を確認する
    - 暗号化された`Finished`メッセージを送信する
6. クライアント -> サーバー
    - ネゴシエートされた共通鍵を使ってメッセージを復元し、MACの検証を行う
    - 問題がなければトンネルが確立する

## 暗号方式
- 共通鍵暗号方式と公開鍵暗号方式の組み合わせによって暗号化を行う
  - 共通鍵暗号方式 - 暗号化と復号に同じ鍵を使う
  - 公開鍵暗号方式 - 公開鍵と秘密鍵から成るペアの鍵を使う

### フロー
1. クライアント -> サーバー
    - SSL通信の要求を送信する
2. サーバー -> クライアント
    - 自身の公開鍵が入った証明書を送信する
3. クライアント -> サーバー
    - サーバーの公開鍵を使い`アプリケーション同士の暗号通信に使う共通鍵`を暗号化して送信する
4. サーバー -> クライアント
    - 秘密鍵を使ってクライアントから送られてきた暗号データを復号し`暗号通信に使う共通鍵`を取り出す
5. 共有した共通鍵を使ってクライアントとサーバー間でデータの暗号化・復号化を処理する

## ALPN
- Application-Layer Protocol Negotiation
- アプリケーションプロトコルネゴシエーションのサポートをTLSハンドシェイクに導入するTLS拡張機能
- 443番ポートとTLSハンドシェイクを利用して任意のアプリケーションプロトコルを使用することができる

### フロー
1. クライアント -> サーバー
    - ClientHelloメッセージにProtocolNameListフィールドを付加して送信する
    - ProtocolNameList - サポートするアプリケーションプロトコルのリスト
2. サーバー -> クライアント
    - ProtocolNameListを検証し、ServerHelloメッセージにProtocolNameフィールドを付加して送信する
    - ProtocolName - 選択したプロトコル

### SNI
- Server Name Indication
- 一つのホストが複数のドメイン名を持つ時、ドメイン単位でサーバー証明書を利用することができるTLS拡張

#### フロー
1. クライアント -> サーバー
    - ハンドシェイクの開始時、接続するホスト名を提示する
2. サーバー -> クライアント
    - 提示されたホスト名を検証し、適切な証明書を選び、ハンドシェイクを続行する

## TLSセッション再開(TLS Session Resumption)
- TLSは複数回にわたる接続においてネゴシエート済の秘密鍵を再利用または共有する機能を提供する

### セッションキャッシング
1. サーバー -> クライアント
    - 32バイトのセッションIDを生成し、ServerHelloメッセージに付加して送信する
    - サーバーはそれぞれのピアのセッションIDとネゴシエートされたセッションパラメータをキャッシュできる
2. クライアント -> サーバー
    - セッションID情報をキャッシュし、次のセッションのClientHelloメッセージに付加する
3. サーバー -> クライアント
    - それぞれのピアのセッションIDとネゴシエートされたセッションパラメータをキャッシュする
4. クライアント・サーバーの両者が共有セッションIDパラメータをキャッシュしている場合、
   短縮ハンドシェイクを行うことができる

#### 課題
- サーバーが全てのピアのセッションキャッシュを生成し、維持する必要がある
  - 確立したTLS接続後おtにメモリが消費される
  - セッションIDのキャッシュと削除ポリシーが必要

### ステートレスなセッション再開
1. クライアント -> サーバー
    - セッションチケットをサポートしていることをサーバーに伝える
2. サーバー -> クライアント
    - TLSハンドシェイクの最後にNewSessionTicketレコードを含める
    - NewSessionTicket - サーバーが持つ秘密鍵で暗号化された全てのセッションデータを含む
3. クライアント -> サーバー
    - セッションチケットを保持し、次のセッションのClientHelloメッセージのSessionTicket拡張に付加する

## SSL証明書
### 種類
- クライアント証明書 - クライアントの身元を証明する
- サーバー証明書 - サーバーの身元を証明する

### 役割
- なりすまし防止
  - レスポンスが正しいサーバーから送信されたことを認証する
- データの改ざん防止
  - リクエストデータが送信中に改ざんされていないことを確認する
  - レスポンスデータが送信中に改ざんされていないことを確認する
- 情報漏洩防止
  - リクエストデータが漏洩しないように暗号化する
  - レスポンスデータが漏洩しないように暗号化する

## サーバー証明書
### クライアント - サーバー間の認証
- クライアントは予め信頼できるルート認証局の証明書を複数インストールしている
- クライアントは予め自身にインストールされている証明書と
  サーバーから送信されたルート認証局の証明書が一致するかを確認する
  (クライアントにはサーバー証明書とルート認証局の自己証明書が両方送信される)
  一致したら受信した証明書は信頼できると判断する
- クライアントはルート認証局の証明書の中に入っている公開鍵でサーバー証明書に付けられた署名を検証する
  一致したら受信した証明書は信頼できると判断する

### 種類
- DV証明書 - ドメインの所有確認
- OV証明書 - ドメインの所有確認、発行先の組織の存在を示す
- EV証明書 - ドメインの所有確認、発行先の組織の存在をガイドラインに従って厳格に示す

### フロー
0. 認証局がサーバーにSSL証明書を発行する
1. クライアントがサーバーからSSL証明書を取得する
2. クライアントが認証局へSSL証明書の信頼性を確認する
3. クライアントが共通鍵を作成し、SSL証明書内の公開鍵で暗号化
4. サーバーが暗号化された鍵を複製する
5. サーバー・クライアントが複合した鍵で通信を行う

### 証明書の失効
- 証明書は自身の失効を確かめる方法を証明書自身に内包する
  - 証明書失効リスト(CRL)
  - オンライン証明書状態プロトコル(OCSP)

### 証明書発行手順
1. OpenSSLで秘密鍵を生成
```
$ openssl genrsa -out ./xxx.key 2048`
$ chmod 600 ./xxx.key
```

2. 秘密鍵からCSR(証明書署名リクエスト)を作成
```
$ openssl req -new -key xxx.key -out xxx.csr
```
3. 認証局にCSRを提出しSSL証明書の発行を依頼
  - FujiSSL
4. CAによる審査・証明書の発行
5. CAから発行される値でネームサーバー上にTXTレコードを作りDNS認証
6. SSL証明書・中間CA証明書が届く
    - SSL証明書(`.crt`)
    - 中間CA証明書(`.ca`)
    - SSL証明書 + 中間CA証明書
7. WebサーバーにSSL証明書・中間CA証明書を設置
    - 証明書を一ファイルにまとめる(`$ awk 1 xxx.crt yyy.ca > zzz.crt`)
8. Webサーバー上にHTTPSのバーチャルホストを作成
    - 秘密鍵・SSL証明書 + 中間CA証明書・暗号スイート・TLSプロトコルバージョンを指定

### 証明書の記載内容
- 参照: サーバ／インフラエンジニアの基本がこれ1冊でしっかり身につく本 3.6
- 主体者(申請者)
- 主体者の公開鍵
- 発行元
- 有効期間

### CAA(Certification Authority Authorization)レコード
- 運営者以外の第三者がSSL証明書を勝手に発行することを防止するための仕組み
- 該当のドメインの証明書を発行できる認証局を事前に設定しておく

### SSLターミネーション
- Webサーバー手前のロードバランサーにSSL証明書を設置する手法
- ロードバランサーとWebサーバー間はHTTPで通信を行う

## HTTP/2における仕様
- TLS1.2以上
- TLS SNIのサポート
- 圧縮機能無効化 -> HTTP/2自身が圧縮を行う
- 再ネゴシエーション禁止 -> クライアント証明書の要求はコネクションプリフェイス前に実行される必要がある
- 暗号スイート
  - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`をサポート
  - 仕様で禁止されている暗号スイートの使用禁止

### 暗号スイートの条件が合わない場合
- `INADEQUEATE_SECURITY`エラーコネクションによって切断される場合がある -> コネクションエラー
  - ALPNネゴシエーションと暗号スイートの選択が独立して行われるため、
    暗号スイートの条件が一致しない場合がある

## 参照
- [How is data secure over https?](https://blog.joshsoftware.com/2019/08/23/how-is-data-secure-over-https/)
- よくわかるHTTP/2の教科書P18-20/124-125
- SSLをはじめよう ～「なんとなく」から「ちゃんとわかる！」へ～
- [図解で学ぶネットワークの基礎：SSL編](https://xtech.nikkei.com/it/article/COLUMN/20071002/283518/)
- ハイパフォーマンスブラウザネットワーキング
