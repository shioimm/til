# TCP
- 参照: よくわかるHTTP/2の教科書P21-22/40-41
- 参照: Linuxプログラミングインターフェース 58章 / 61章

## TCPによる通信の特徴
- データの信頼性
  - 失われたパケットの再送
  - 順番の入れ替わったパケットの並べ直し
- 輻輳制御
  - スロースタート
  - 輻輳状態の検知
  - フロー制御

### TCPエンドポイント
- TCPコネクションの一方の接続端点に対応するカーネルが管理する情報(受信TCP / 送信TCP)
  - 送信バッファ
  - 受信バッファ
  - 接続済みエンドポイントを同期するための状態情報

### 通信の確立
- 通信前に通信チャネルを確立する
- 送信データは複数のセグメントに分割される
  セグメントごとに送信エラーを検出可能なチェックサムを持つ
- TCPセグメントが受信側へ到着すると受信TCPは送信TCPへ確認応答を送信する

### シーケンス番号
- TCPコネクション上を流れる全てのバイトには論理シーケンス番号が振られ、
  そのコネクションのストリーム内での位置を示す
- TCPセグメント送信時はセグメントの先頭バイトのシーケンス番号をTCPヘッダに格納する
- シーケンス番号は32ビットの幅を持ち、最大値に達すると0に戻る

### フロー制御
- 高速な送信側が低速な送信側を飽和させるのを防ぐための機能
- 受信TCPが送信TCPから受信したデータは受信バッファへ保持され、
  アプリケーションがデータを読み取ると削除される
  - 受信TCPは確認応答送信時に受信バッファサイズを送信TCPに告知する
  - 確認応答前のセグメントが最大合計Nバイト(ウィンドウサイズ)まで存在して良いとする
    (スライディングウィンドウ)
  - 受信バッファが一杯になると、送信TCPは送信を停止する

### 輻輳制御
- 高速な送信側がネットワークを飽和させるのを防ぐための機能
  - 中継ルーターがパケットを中継するよりも早く送信TCPがパケットを送出した場合、
    ルーターでパケットが欠落する
- スロースタート
  - 送信TCPは遅い速度で送信を開始し、受信TCPが確認応答を返すたびに級数的に速度を上昇させる
- 輻輳回避
  - 接続直後は送信TCPは小さな輻輳ウィンドウを設けて送信可能な未応答データ量を制限し、
    送信側がピアTCPから確認応答を受信するたびに輻輳ウィンドウのサイズを級数的に上昇させる
  - ネットワークキャパシティに近い規定の閾値に達すると増加ペースを級数的から線形へ落とす

## TCPセグメントの形式
- ヘッダ
  - 送信TCP / 受信TCPポート番号
    - 送信TCP(16ビット) - データの送信元
    - 受信TCP(16ビット) - データの送信先
  - セグメントのシーケンス番号
    - 「送信時のシーケンス番号 + この方向に送信する全データの先頭バイトからのオフセット」を示す数値
    - 初期値にはランダムな数値が割り振られる
  - 確認応答番号
    - ACKビットがセットされている場合、受信側が次に期待するデータのシーケンス番号
  - ヘッダサイズ・予約領域・制御フラグ / ウィンドウサイズ
    - ヘッダサイズ(4ビット)
    - 予約領域(4ビット)
    - 制御フラグ(8ビット) - セグメントに意味を付加するフィールド・複数指定可能
    - ウィンドウサイズ(16ビット) - 受信側がACKを送信する際に受信可能とするデータバイト数
  - TCPチェックサム / 緊急ポインタ
    - TCPチェックサム(16ビット) - TCPヘッダ・TCPデータ両方を対象とする
    - 緊急ポインタ(16ビット) - URG制御フラグがセットされている場合、緊急データの位置を示す
  - オプション(0~40バイト)
    - TCPコネクションを操作するオプション
- データ(0 + nバイト)
  - ユーザーデータ

### シーケンス番号と確認応答
- TCPコネクション上を流れる全てのバイト数には論理的なシーケンス番号が割り振られる
- 受信側はセグメントを正常に受信すると送信側へ確認応答(ACKフラグがセットされたセグメント)を返す
- 確認応答番号フィールドは次に期待する論理シーケンス番号を表す
- 送信TCPはセグメント送信時にタイマーを仕掛ける
  タイマーが切れる前に確認応答しなければそのセグメントを再送する

## TCPエンドポイントにおける状態遷移
- TCPコネクションの管理のため両端TCPエンドポイントはステートマシンを実装する
  - TCPは状態を持つ
  - TCPはイベントをきっかけにある状態から別の状態へ遷移する

### TCPの状態
- `LISTEN`
  - ピアTCPからの接続要求を待っている
- `SYN_SENT`
  - アプリケーションがアクティブオープンを実行し、TCPがSYNを送信し、
    コネクションを完了するべくピアTCPからのSYNに対する応答を待っている
- `SYN_RECV`
  - `LISTEN`状態だったTCPがSYNを受信し、SYN/ACKを返し、
    コネクションを完了するべくピアTCPからのACKを待っている
- `ESTABLISHED`
  - ピアTCPへのコネクションが確立された
- [アクティブクローズ]`FIN_WAIT1`
  - アプリケーションがコネクションをアクティブクローズし、
    自TCPはピアTCPへFINを送信し、ACKを待っている
    -> `FIN_WAIT2` / `CLOSING`
- [アクティブクローズ]`FIN_WAIT2`
  - `FIN_WAIT1`だったTCPがACKを受信した
    -> `TIME_WAIT`
- [アクティブクローズ]`CLOSING`
  - `FIN_WAIT1`だったTCPのピアTCPがアクティブクローズし、
    自TCPがピアTCPからFINを受信した
    -> `TIME_WAIT`
- [アクティブクローズ]`TIME_WAIT`
  - TCPがアクティブクローズを実行し、ピアTCPがパッシブクローズを実行し、
    自TCPがピアTCPからFINを受信した
  - 規定時間経過後にコネクションはクローズされ、使用していたカーネルリソースが解放される
    規定時間は2MSL(最長セグメント寿命)(Linuxは1MSLが30秒)
    - 規定時間中に同じポートを別ソケットにバインドしようとすると`EADDRINUSE`が発生する
    - `SO_REUSEADDR`オプションは`TIME_WAIT`の信頼性を維持しつつ`EADDRINUSE`を回避する
- [パッシブクローズ]`CLOSE_WAIT`
  - ピアアプリケーションがアクティブクローズを実行し、自TCPがピアTCPからFINを受信した
    -> `LAST_ACK`
- [パッシブクローズ]`LAST_ACK`
  - アプリケーションがパッシブクローズを実行し、`CLOSE_WAIT`だったTCPがFINを送信し、
    ピアTCPからのACKを待っている
  - ACKを受信するとコネクションはクローズされ、使用していたカーネルリソースが解放される

### TCPヘッダの制御フラグ
- 参照: サーバ・インフラエンジニアの基本がこれ一冊でしっかり身につく本 2.10

| フラグ | 意味                             | 利用シーン               |
| -      | -                                | -                        |
| URG    | Urgent Pointer field significant | urgent領域を使用する場合 |
| ACK    | Acknowledge field significant    | 返答                     |
| PSH    | Push Function                    | データ送信               |
| RST    | Reset the connection             | コネクションリセット     |
| SYN    | Synchronize sequence numbers     | コネクション確立         |
| FIN    | no more data from sender         | コネクション切断         |

## コネクションの確立 / 切断
### ストリームソケットの接続
- サーバーは`listen()`によりソケットをパッシブオープンし、`accept()`する
  `accept()`はコネクションが確立するまでブロックする
- クライアントは`connect()`によりソケットをアクティブオープンし、
  サーバーのパッシブソケットとのコネクションを確立する

### コネクションの確立(3wayハンドシェイク)
1. クライアント -> サーバー
   `connect()`によりSYNフラグをセットしたセグメントを送信
    - クライアント自身の初期シーケンス番号の通知
2. サーバー -> クライアント
   SYNフラグ・ACKフラグをセットしたセグメントを送信
    - クライアントのSYNに対する確認応答とサーバー自身の初期シーケンス番号の通知
3. クライアント -> サーバー
   ACKフラグをセットしたセグメントを送信
    - サーバーのSYNに対する確認応答

### コネクションの切断
1. クライアントがアクティブクローズを実行する
    - サーバーも実行できるが通常は通常はクライアントが実行する
2. クライアント -> サーバー
   FINフラグをセットしたセグメントを送信
3. サーバー -> クライアント
   ACKフラグをセットしたセグメントを送信
    - クライアントのFINに対する確認応答
    - 以降サーバーが当該ソケットを`read()`するとEOFを検出する
4. サーバーが自身のソケットをクローズする
5. サーバー -> クライアント
   FINフラグをセットしたセグメントを送信
6. クライアント -> サーバー
   ACKフラグをセットしたセグメントを送信
    - サーバーのFINに対する確認応答

## KeepAlive
- 一度確立したTCPコネクション上で複数のHTTP通信を行う技術(HTTP/1.1)
- クライアントは複数のリクエストを送信できる
- サーバーは複数のレスポンスを送信できる
  - サーバーはクライアントがリクエストを送信した順でレスポンスを返す必要がある
- クライアントがKeepAlive接続を要求する際はConnectionリクエストヘッダをkeep-aliveに設定する
- サーバーがKeepAlive接続を行う場合はConnectionレスポンスヘッダをkeep-aliveに設定する
  - サーバーがKeepAlive接続を行わない場合はConnectionレスポンスヘッダをcloseに設定する

## TCP FAST OPEN
- 参照: [TCP FAST OPENとは？](https://blog.redbox.ne.jp/tcp-fast-open-cdn.html)
- TCPレイヤーにおける高速化の手法のひとつ
- 通信確立時の1RTTを節約する

### 手法
- 初回通信開始時、クライアントからSYNにFast Open Cookieを付けてハンドシェイクを行う
  - サーバーはTCPオプション34番でTFOクッキーを返す
  - クライアントはTFOクッキーをキャッシュする
- 初回以降の通信時、クライアントはSYNパケットにTFOクッキーとリクエストデータを含めて送信する
  - サーバーはクライアントから送られてきたTFOクッキーと自身の生成したTFOクッキーを比較検証
  - 正しければサーバーはリクエストデータをアプリケーションに渡し、クライアントにはSYN-ACKを返却
