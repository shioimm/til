# TCPの仕様
## TCPセグメントの形式
### ヘッダ(20バイト)
#### 送信TCP / 受信TCPポート番号
- 送信TCP(16ビット) - データの送信元
- 受信TCP(16ビット) - データの送信先

#### セグメントのシーケンス番号
- 「送信時のシーケンス番号 + この方向に送信する全データの先頭バイトからのオフセット」を示す数値
- 初期値にはランダムな数値が割り振られる

#### 確認応答番号
- ACKビットがセットされている場合、受信側が次に期待するデータのシーケンス番号

#### ヘッダサイズ・予約領域・制御フラグ / ウィンドウサイズ
- ヘッダサイズ(4ビット)
- 予約領域(4ビット)
- 制御フラグ(8ビット) - セグメントに意味を付加するフィールド・複数指定可能
- ウィンドウサイズ(16ビット) - 受信側がACKを送信する際に受信可能とするデータバイト数

#### TCPチェックサム / 緊急ポインタ
- TCPチェックサム(16ビット) - TCPヘッダ・TCPデータ両方を対象とする
- 緊急ポインタ(16ビット) - URG制御フラグがセットされている場合、緊急データの位置を示す

#### オプション(0~40バイト)
- TCPコネクションを操作するオプション

### ペイロード(0 + nバイト)
- ユーザーデータ

### シーケンス番号と確認応答
- TCPコネクション上を流れる全てのバイトにはランダムな論理シーケンス番号が振られ、
  そのコネクションのストリーム内での位置を示す
- TCPセグメント送信時はセグメントの先頭バイトのシーケンス番号をTCPヘッダに格納する
- シーケンス番号は32ビットの幅を持ち、最大値に達すると0に戻る
- 受信側はセグメントを正常に受信すると送信側へ確認応答(ACKフラグがセットされたセグメント)を返す
- 確認応答番号フィールドは次に期待する論理シーケンス番号を表す
- 送信TCPはセグメント送信時にタイマーを仕掛ける
  タイマーが切れる前に確認応答しなければそのセグメントを再送する

### TCPヘッダの制御フラグ
- 参照: サーバ・インフラエンジニアの基本がこれ一冊でしっかり身につく本 2.10

| フラグ | 意味                             | 利用シーン               |
| -      | -                                | -                        |
| URG    | Urgent Pointer field significant | urgent領域を使用する場合 |
| ACK    | Acknowledge field significant    | 返答                     |
| PSH    | Push Function                    | データ送信               |
| RST    | Reset the connection             | コネクションリセット     |
| SYN    | Synchronize sequence numbers     | コネクション確立         |
| FIN    | no more data from sender         | コネクション切断         |

## TCPエンドポイント
- TCPコネクションの一方の接続端点に対応するカーネルが管理する情報(受信TCP / 送信TCP)
  - 送信バッファ
  - 受信バッファ
  - 接続済みエンドポイントを同期するための状態情報
- TCPコネクションの管理のため両端TCPエンドポイントはステートマシンを実装する
  - TCPは状態を持つ
  - TCPはイベントをきっかけにある状態から別の状態へ遷移する

### TCPの状態
#### `LISTEN`
- ピアTCPからの接続要求を待っている

#### `SYN_SENT`
- アプリケーションがアクティブオープンを実行し、TCPがSYNを送信し、
  コネクションを完了するべくピアTCPからのSYNに対する応答を待っている

#### `SYN_RECV`
- `LISTEN`状態だったTCPがSYNを受信し、SYN/ACKを返し、
  コネクションを完了するべくピアTCPからのACKを待っている

#### `ESTABLISHED`
- ピアTCPへのコネクションが確立された

#### [アクティブクローズ]`FIN_WAIT1`
- アプリケーションがコネクションをアクティブクローズし、
  自TCPはピアTCPへFINを送信し、ACKを待っている
  - -> `FIN_WAIT2`
  - -> `CLOSING`

#### [アクティブクローズ]`FIN_WAIT2`
- `FIN_WAIT1`だったTCPがACKを受信した
  - -> `TIME_WAIT`

#### [アクティブクローズ]`CLOSING`
- `FIN_WAIT1`だったTCPのピアTCPがアクティブクローズし、
  自TCPがピアTCPからFINを受信した
  - -> `TIME_WAIT`

#### [アクティブクローズ]`TIME_WAIT`
- TCPがアクティブクローズを実行し、ピアTCPがパッシブクローズを実行し、
  自TCPがピアTCPからFINを受信した
- 規定時間経過後にコネクションはクローズされ、使用していたカーネルリソースが解放される
  規定時間は2MSL(最長セグメント寿命)(Linuxは1MSLが30秒)
  - 規定時間中に同じポートを別ソケットにバインドしようとすると`EADDRINUSE`が発生する
  - `SO_REUSEADDR`オプションは`TIME_WAIT`の信頼性を維持しつつ`EADDRINUSE`を回避する

#### [パッシブクローズ]`CLOSE_WAIT`
- ピアアプリケーションがアクティブクローズを実行し、自TCPがピアTCPからFINを受信した
  - -> `LAST_ACK`

#### [パッシブクローズ]`LAST_ACK`
- アプリケーションがパッシブクローズを実行し、`CLOSE_WAIT`だったTCPがFINを送信し、
  ピアTCPからのACKを待っている
- ACKを受信するとコネクションはクローズされ、使用していたカーネルリソースが解放される

## コネクションの確立と切断
### コネクションの確立(3wayハンドシェイク)
1. クライアント -> サーバー: `connect()`によりSYNフラグをセットしたセグメントを送信
    - クライアント自身の初期シーケンス番号の通知
    - シーケンス番号: クライアントが無作為に選んだ番号x
2. サーバー -> クライアント: SYNフラグ・ACKフラグをセットしたセグメントを送信
    - クライアントのSYNに対する確認応答とサーバー自身の初期シーケンス番号の通知
    - シーケンス番号: サーバーが無作為に選んだ番号y
    - 確認応答番号: クライアントから受け取った番号x + 1
3. クライアント -> サーバー: ACKフラグをセットしたセグメントを送信
    - サーバーのSYNに対する確認応答
    - シーケンス番号: サーバーから受け取った番号x + 1
    - 確認応答番号: クライアントから受け取った番号y + 1
- 3wayハンドシェイク完了後、コネクションが確立する
- クライアントはACKパケットの送信直後にデータパケットを送信できる
- サーバーはデータパケットの受信前にACKの到着を待つ

### コネクションの切断
1. クライアントがアクティブクローズを実行する
    - サーバーも実行できるが通常は通常はクライアントが実行する
2. クライアント -> サーバー
   FINフラグをセットしたセグメントを送信
3. サーバー -> クライアント
   ACKフラグをセットしたセグメントを送信
    - クライアントのFINに対する確認応答
    - 以降サーバーが当該ソケットを`read()`するとEOFを検出する
4. サーバーが自身のソケットをクローズする
5. サーバー -> クライアント
   FINフラグをセットしたセグメントを送信
6. クライアント -> サーバー
   ACKフラグをセットしたセグメントを送信
    - サーバーのFINに対する確認応答

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
