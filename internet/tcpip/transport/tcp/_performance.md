# 輻輳回避と輻輳制御
## TCPにおけるレイテンシと輻輳制御
- 3wayハンドシェイクはパケット1往復分のレイテンシを発生させる
- スロースタートは全ての新規接続に適用される
- フロー制御と輻輳制御は全ての接続のスループットを制御する
- TCPのスループットは現在の輻輳ウィンドウサイズによって制限される
- 現代の高速ネットワークにおいてTCP接続の転送できるデータの速度は
  受送信ホスト間のパケット往復時間によって制限される

### 帯域幅遅延積
- `リンク容量 * エンドツーエンドの遅延` = 任意の時点における送信中未応答データの最大量
  - 送信側と受信側の最適なウィンドウサイズはパケット往復時間と目標データ転送速度に依存する
  - 許容される未応答データの最大量を超えた場合、次のデータ送信を延期し、
    相手がACKを返すまで(パケットの往復時間分)待機する必要がある
- ウィンドウサイズの通常ネットワークスタックによって自動的にネゴシエーション・チューニングされる

## ウインドウ制御
#### ウィンドウ
- 規定サイズのMSSを受信するまで受信データをバッファ領域に溜めておくことでACKの送信を遅延させるメカニズム
  - ウィンドウサイズ - ACKを待たずに送信できるMSSのサイズ

### スライディングウィンドウ
- 複数のセグメントを並列に送信して通信機能を向上させる仕組み
1. 送信ホストはウィンドウサイズ分の送信データを用意し、セグメント単位で送信する
2. 送信済みセグメントのACKが届くまで、最初に用意した送信データは確保したままにしておく
3. 送信済みセグメントのACKが届いたら、最初に用意した送信データのうち該当するセグメントのデータを破棄する
4. ウィンドウサイズに対してデータの空きが発生するため、空いたサイズ分の新たな送信用データを用意する

#### 高速再送制御
- スライディングウィンドウ中に送信セグメントが失われたとき:
  - 受信ホストは次に受信するべきシーケンス番号以外のデータを受け取った場合、
    今までに受信したデータに対するACKを返す
  - 送信ホストは一度受け取ったACKと同じものを3回連続で受け取った場合、
    そのACKが示しているデータを再送する

## フロー制御
- 受信側が処理できないほどの大量のデータが送信側から送出されるのをふせぐためのメカニズム
  - 受信側はビジー状態、重い負荷がかかっている、決まった量のバッファ領域しか割り当てたくないなど
- 接続中の両ホストにおいて、受信データの維持に使用可能なバッファサイズを知らせるために
  各ホストは通信相手に対して受信ウィンドウサイズ(rwnd)値を告知する
  - ACKパケットが各ホストの最新のrwnd値を送信する
- データ受信側の容量をオーバーフローさせないようデータ送信側で制御できる

### 仕組み
- 接続確立時、各ホストはシステムデフォルト値のrwnd値で通信を開始する
- 各ホストのどちらかが現在のペースの通信を維持できなくなった場合:
  より小さなrwnd値を通信相手へ告知する
- rwnd値が0になった場合:
  今までに送信されたバッファ上のデータがアプリケーションによって処理されるまで
  新たにデータを送るべきではないという合図になる

### ウィンドウスケーリングオプション
- 最大rwnd値をデフォルトの64Kbytes以上に設定するためのオプション
- 通常はデフォルトで有効になっている

### 課題
- ネットワークの帯域幅を超える通信を防ぐメカニズムが送受信どちら側にも組み込まれていない

## スロースタート
- 常に変化するネットワークの帯域幅を超えないように通信を行うためのメカニズム
  - ルーターがパケットを中継するよりも早く送信TCPがパケットを送出した場合、
    ルーターでパケットが欠落する(パケットロス)
- 送信TCPは小さい輻輳ウィンドウサイズ(cwnd)変数値で送信を開始し、
  受信TCPがACKを返すたびに級数的にcwnd値を増加させる

### 仕組み
- サーバーはTCP接続ごとにcwnd変数を初期化し、初期値として控えめなシステム設定値を設定する
  - cwnd値 - データ送信側がクライアントからACKを受け取る前に続けて送信できるデータ量
  - cwnd値はサーバーにプライベート変数として保存される
- クライアント・サーバー間の新規TCP接続における送信中未応答データの最大量は
  rwnd値とcwnd値のうちどちらか小さい方に制限される
  - 送信中未応答データ - ACKが返されていないデータ
- サーバーはパケットにACKが返されるごと(パケット1往復ごと)にcwnd値を1セグメントずつ増加させていく
  - ACKを受け取るごとに新たに2つのパケットを送信できる(指数的増加アルゴリズム)
- ネットワークキャパシティの閾値に達した(パケットロスが発生した)場合:
  増加ペースを級数的から線形へ落とす

## TCP Fast Open
- SYNパケット内でのデータ転送を許可することによってTCP接続開始の際のレイテンシを軽減する
- 短いTCP通信におけるハンドシェイクのコストを下げる

### 仕組み
1. クライアント -> サーバー: SYNにFast Open Cookie Requestをつけて送信する
2. サーバー -> クライアント: SYN・ACK時にTCPオプションの34番でTFO Cookieを返す
3. クライアント -> サーバー: ACKを返し接続確立を終える・TFO Cookieをキャッシュする
4. クライアント -> サーバー: リクエストにTFO Cookieをつけて送信する
5. サーバー -> クライアント: TFO Cookieが正しいIPであればクライアントからのACK受信前にレスポンスを送信する
6. 以降繰り返し
- 参照: [TCP FAST OPENとは？](https://blog.redbox.ne.jp/tcp-fast-open-cdn.html)

## チューニング
### サーバー設定
- システムのバージョンアップデートを行う
- TCP接続開始時の輻輳ウィンドウサイズを大きくする
- アイドル後のスロースタート(スロースタートリスタート)を無効にする
- ウィンドウスケーリングを有効にする
- TCP Fast Openを利用する

### アプリケーション
- 不要なデータ送信を除去する
- 送信データを圧縮する
- 物理的にサーバーをユーザーの近くに配置し、RTT時間を削減する
- 可能な限り既存のTCP接続を再利用する

# Keep-Alive
- 一度確立したTCPコネクションを再利用して複数回のHTTP通信を行う技術

### 手法
- 初回通信開始時、クライアントからSYNにFast Open Cookieを付けてハンドシェイクを行う
  - サーバーはTCPオプション34番でTFO Cookieを返す
  - クライアントはTFO Cookieをキャッシュする
- 初回以降の通信時、クライアントはSYNパケットにTFO Cookieとリクエストデータを含めて送信する
  - サーバーはクライアントから送られてきたTFO Cookieと自身の生成したTFOクッキーを比較検証
  - 正しければサーバーはリクエストデータをアプリケーションに渡し、クライアントにはSYN-ACKを返却

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
