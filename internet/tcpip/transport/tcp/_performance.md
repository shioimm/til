# 輻輳回避と輻輳制御
## TCPにおけるレイテンシと輻輳制御
- 3wayハンドシェイクはパケット1往復分のレイテンシを発生させる
- スロースタートは全ての新規接続に適用される
- フロー制御と輻輳制御は全ての接続のスループットを制御する
- TCPのスループットは現在の輻輳ウィンドウサイズによって制限される
- 現代の高速ネットワークにおいてTCP接続の転送できるデータの速度は
  受送信ホスト間のパケット往復時間によって制限される

### 帯域幅遅延積
- `リンク容量 * エンドツーエンドの遅延` = 任意の時点における送信中未応答データの最大量
  - 送信側と受信側の最適なウィンドウサイズはパケット往復時間と目標データ転送速度に依存する
  - 許容される未応答データの最大量を超えた場合、次のデータ送信を延期し、
    相手がACKを返すまで(パケットの往復時間分)待機する必要がある
- ウィンドウサイズの通常ネットワークスタックによって自動的にネゴシエーション・チューニングされる

## ウインドウ制御
#### ウィンドウ
- 規定サイズのMSSを受信するまで受信データをバッファ領域に溜めておくことでACKの送信を遅延させるメカニズム
  - ウィンドウサイズ - 送信側がACKを待たずに送信できるMSSのサイズ

### スライディングウィンドウ制御方式
- 複数のセグメントを並列に送信して通信機能を向上させる仕組み
1. 送信ホストはウィンドウサイズ分の送信データを用意し、セグメント単位で送信する
2. 送信済みセグメントのACKが届くまで、最初に用意した送信データは確保したままにしておく
3. 送信済みセグメントのACKが届いたら、最初に用意した送信データのうち該当するセグメントのデータを破棄する
4. ウィンドウサイズに対してデータの空きが発生するため、空いたサイズ分の新たな送信用データを用意する

#### 高速再送制御
- スライディングウィンドウ中に送信セグメントが失われたとき:
  - 受信ホストは次に受信するべきシーケンス番号以外のデータを受け取った場合、
    今までに受信したデータに対するACKを返す
  - 送信ホストは一度受け取ったACKと同じものを3回連続で受け取った場合、
    そのACKが示しているデータを再送する

## フロー制御
- 受信側が処理できないほどの大量のデータが送信側から送出されるのをふせぐためのメカニズム
  - 受信側はビジー状態、重い負荷がかかっている、決まった量のバッファ領域しか割り当てたくないなど
- 接続中の両ホストにおいて、受信データの維持に使用可能なバッファサイズを知らせるために
  各ホストは通信相手に対して受信ウィンドウサイズ(rwnd値)を告知する
  - ACKパケットが各ホストの最新のrwnd値を送信する
- データ受信側の容量をオーバーフローさせないようデータ送信側で制御できる

### 仕組み
- 接続確立時、各ホストはシステムデフォルト値のrwnd値で通信を開始する
- 各ホストのどちらかが現在のペースの通信を維持できなくなった場合:
  より小さなrwnd値を通信相手へ告知する
- rwnd値が0になった場合:
  今までに送信されたバッファ上のデータがアプリケーションによって処理されるまで
  新たにデータを送るべきではないという合図になる
  - 受信ホストはバッファに空きができた場合、送信相手にウィンドウ更新通知を送信する
  - 送信ホストは通信が再開するまで時々受信ホストのバッファの空き状況を確認する(ウィンドウプルーブ)

### ウィンドウスケーリングオプション
- 最大rwnd値をデフォルトの64Kbytes以上に設定するためのオプション
- 通常はデフォルトで有効になっている

### 課題
- ネットワークの帯域幅を超える通信を防ぐメカニズムが送受信どちら側にも組み込まれていない

## スロースタート
- 常に変化するネットワークの帯域幅を超えないように通信を行うためのメカニズム
  - ルーターがパケットを中継するよりも早く送信TCPがパケットを送出した場合、
    ルーターでパケットが欠落する(パケットロス)
- 送信TCPは輻輳ウィンドウサイズ(cwnd)変数値を設定して送信を開始し、
  受信TCPがACKを返すたびに級数的にcwnd値を増加させる
  - 初期cwnd値は1セグメント(1MSS)

### スロースタート閾値
- トラフィックの急激な増加を防ぐために設定する値(ネットワークキャパシティの閾値)
- cwnd値がスロースタート閾値を超えた場合、cwnd値がACKの度に増加するペースを級数的から線形へ落とす
- 通信開始時に閾値は設定されておらず、タイムアウトによる再送が発生した際にその時のcwnd値の半分の値に設定される

### 仕組み
- サーバーはTCP接続ごとにcwnd変数を初期化し、初期値として控えめなシステム設定値を設定する
  - cwnd値はサーバーにプライベート変数として保存される
- クライアント・サーバー間の新規TCP接続における送信中未応答データの最大量は
  rwnd値とcwnd値のうちどちらか小さい方に制限される
  - 送信中未応答データ - ACKが返されていないデータ
- サーバーはパケットにACKが返されるごと(パケット1往復ごと)にcwnd値を1セグメントずつ増加させていく
  - ACKを受け取るごとに新たに2つのパケットを送信できる(指数的増加アルゴリズム)

## Nagleアルゴリズム
- ネットワークの利用効率を上げるため、送信するべきデータが少ない場合はすぐに送信せず送信回数を減らすメカニズム
- データの発生に時間的な魔がある場合はNagleアルゴリズムは無効にされるべきである

#### 送信条件
- いずれかに当てはまる際にデータセグメントを送信する
  - すべての送信済みデータにACKが返ってきている場合
  - 最大セグメント長(MSS)のデータを送信できる場合

## 遅延確認応答
- ネットワークの利用効率を上げるため、小さいサイズのデータを受信してもすぐにACKせずACK回数を減らすメカニズム
  - 2 * MSSのデータを受信するまでACKしない
    - そうでない場合はACKを最大で0.5秒遅延させる(0.2秒程度のOSが一般的)

## ピギーバック
- 送信したメッセージに対して相手が処理をして返すアプリケーションプロトコルにおいて、
  ネットワークの利用効率を上げるため、返信データの送信とACKを一つのパケットで送信するメカニズム
  - アプリケーションがデータを処理して返事となるデータを送信するまでACKが遅延される

## TCP Fast Open
- SYNパケット内でのデータ転送を許可することによってTCP接続開始の際のレイテンシを軽減する
- 短いTCP通信におけるハンドシェイクのコストを下げる

### 仕組み
1. クライアント -> サーバー: SYNにFast Open Cookie Requestをつけて送信する
2. サーバー -> クライアント: SYN・ACK時にTCPオプションの34番でTFO Cookieを返す
3. クライアント -> サーバー: ACKを返し接続確立を終える・TFO Cookieをキャッシュする
4. クライアント -> サーバー: リクエストにTFO Cookieをつけて送信する
5. サーバー -> クライアント: TFO Cookieが正しいIPであればクライアントからのACK受信前にレスポンスを送信する
6. 以降繰り返し
- 参照: [TCP FAST OPENとは？](https://blog.redbox.ne.jp/tcp-fast-open-cdn.html)

## チューニング
### サーバー設定
- システムのバージョンアップデートを行う
- TCP接続開始時の輻輳ウィンドウサイズを大きくする
- アイドル後のスロースタート(スロースタートリスタート)を無効にする
- ウィンドウスケーリングを有効にする
- TCP Fast Openを利用する

### アプリケーション
- 不要なデータ送信を除去する
- 送信データを圧縮する
- 物理的にサーバーをユーザーの近くに配置し、RTT時間を削減する
- 可能な限り既存のTCP接続を再利用する

## Keep-Alive
- 一度確立したTCPコネクションを再利用して複数回のHTTP通信を行う技術

### 手法
- 初回通信開始時、クライアントからSYNにFast Open Cookieを付けてハンドシェイクを行う
  - サーバーはTCPオプション34番でTFO Cookieを返す
  - クライアントはTFO Cookieをキャッシュする
- 初回以降の通信時、クライアントはSYNパケットにTFO Cookieとリクエストデータを含めて送信する
  - サーバーはクライアントから送られてきたTFO Cookieと自身の生成したTFOクッキーを比較検証
  - 正しければサーバーはリクエストデータをアプリケーションに渡し、クライアントにはSYN-ACKを返却

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
