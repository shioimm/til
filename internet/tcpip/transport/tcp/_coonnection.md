# コネクションの確立と切断
## コネクションの確立(3wayハンドシェイク)
1. クライアント -> サーバー
    - `connect()`によりSYNフラグをセットしたセグメントを送信
    - クライアント自身の初期シーケンス番号の通知
    - シーケンス番号: クライアントが無作為に選んだ番号x
2. サーバー -> クライアント
    - SYNフラグ・ACKフラグをセットしたセグメントを送信
    - クライアントのSYNに対する確認応答とサーバー自身の初期シーケンス番号の通知
    - シーケンス番号: サーバーが無作為に選んだ番号y
    - 確認応答番号: クライアントから受け取った番号x + 1
3. クライアント -> サーバー
    - ACKフラグをセットしたセグメントを送信
    - サーバーのSYNに対する確認応答
    - シーケンス番号: サーバーから受け取った番号x + 1
    - 確認応答番号: クライアントから受け取った番号y + 1
- 3wayハンドシェイク完了後、コネクションが確立する
- クライアントはACKパケットの送信直後にデータパケットを送信できる
- サーバーはデータパケットの受信前にACKの到着を待つ

### シーケンス番号と確認応答
- TCPコネクション上を流れる全てのバイトにはランダムな論理シーケンス番号が振られ、
  そのコネクションのストリーム内での位置を示す
- TCPセグメント送信時はセグメントの先頭バイトのシーケンス番号をTCPヘッダに格納する
- シーケンス番号は32ビットの幅を持ち、最大値に達すると0に戻る
- 受信側はセグメントを正常に受信すると送信側へ確認応答(ACKフラグがセットされたセグメント)を返す
- 確認応答番号フィールドは次に期待する論理シーケンス番号を表す
- 送信TCPはセグメント送信時にタイマーを仕掛ける
  タイマーが切れる前に確認応答しなければそのセグメントを再送する

## コネクションの切断
1. クライアントがアクティブクローズを実行する
    - サーバーも実行できるが通常は通常はクライアントが実行する
2. クライアント -> サーバー
   FINフラグをセットしたセグメントを送信
3. サーバー -> クライアント
   ACKフラグをセットしたセグメントを送信
    - クライアントのFINに対する確認応答
    - 以降サーバーが当該ソケットを`read()`するとEOFを検出する
4. サーバーが自身のソケットをクローズする
5. サーバー -> クライアント
   FINフラグをセットしたセグメントを送信
6. クライアント -> サーバー
   ACKフラグをセットしたセグメントを送信
    - サーバーのFINに対する確認応答

## 参照
- よくわかるHTTP/2の教科書P21-22/40-41
- Linuxプログラミングインターフェース 58章 / 61章
- Software Design 2021年5月号 ハンズオンTCP/IP
- ハイパフォーマンスブラウザネットワーキング
