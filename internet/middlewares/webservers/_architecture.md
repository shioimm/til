# Webサーバーアーキテクチャ
- Webサーバーアーキテクチャにおける主な関心 = リクエスト処理をどのようにして効率良く並行実行するか
  - シリアル、マルチプロセス、マルチスレッド、イベント駆動、それらのハイブリッドモデル

##  シリアルモデル
- 並行処理を行わない

## マルチプロセス
- リクエスト毎にforkし、生成した子プロセスによってリクエスト処理を行う
  - CoWによってメモリコピーの負荷を抑える

### prefork型サーバー(Ex. Unicorn, Puma)
- サーバー起動時にメインプロセスから一定数の子プロセスを予め生成しておく
- サーバー起動中は事前に生成した子プロセス(ワーカープロセス)を使い回す
- 同時接続数分のプロセスをメモリ上に確保しておく必要があるため、メモリ消費量が多くなる
- 子プロセス数以上のリクエストを同時に処理することができない

### RubyのpreforkサーバーがmacOSでクラッシュする問題
- 参照: [Why Ruby app servers break on macOS High Sierra and what can be done about it](https://blog.phusion.nl/2017/10/13/why-ruby-app-servers-break-on-macos-high-sierra-and-what-can-be-done-about-it/)
- CoWにより、forkした時点で他のスレッドが矛盾した状態になっている可能性がある
  - メモリを直接読み取り・変更するコードが壊れる可能性がある
- MacOS HighSierraより後のOSは、gemの依存関係によってはこの挙動により即時クラッシュする
  - シェルに`export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES`の設定が必要
  - Ruby公式の回避策はまだ無い(2019/12/11)

## マルチスレッド
- リクエスト毎にスレッドを生成し、生成したスレッドによってリクエスト処理を行う
  - スレッド = OSが提供するネイティブスレッド
- スレッドは生成元のプロセスとアドレス空間を共有するため、プロセス生成よりもコストが小さい
- 複数のスレッドが生成元のプロセスとメモリアドレス空間を共有するため、
  リソース競合が発生する危険がある

### スレッドプール
- サーバー起動時に行って異数のスレッドをあらかじめ生成しておく
- サーバー起動中は事前に生成したスレッドを使い回す
- スレッド数以上のリクエストを同時に処理することができない

## イベント駆動(Ex. EventMachine)
- I/O多重化とイベントループにより、リクエスト処理を一つのスレッドで実行する
  - ブロッキングI/Oモデルではaccept、read、writeなどの実行時、
    I/Oが処理を完了するまで処理をブロックするため
    一つのスレッドで複数のソケットを扱うことが難しい
  - イベント駆動モデルではI/Oを多重化することにより、
    どのソケットからI/Oがあるかを把握し、複数のネットワークI/Oを捌けるようにする
  - select/pollなどのシステムコールを用いてソケットのI/Oイベントを監視する
- 同時に接続できるクライアント数に上限がない
- 一スレッドで動作するため、マルチコアスケールしない
- リクエスト処理中にブロッキングするコードがあるとスレッドごとブロックされてしまう

## ハイブリッド
- マルチプロセス / スレッド -> イベント駆動(Ex. Nginx)
  - prefork/スレッドプールとイベント駆動モデルを組み合わせることにより、
    マルチコアスケールさせることを目的としたアーキテクチャ
- イベント駆動 -> マルチプロセス / スレッド(Ex. Monoceros)
  - メインスレッドはイベントループで接続管理
  - メインスレッドがacceptで得たクライアントソケットを後続のプロセス/スレッドに渡し、
    リクエスト処理を委譲するアーキテクチャ

## 参照
- [2015年Webサーバアーキテクチャ序論](https://blog.yuuk.io/entry/2015-webserver-architecture)
